{
  "version": "2026-01-01T16:50:12.005Z",
  "pages": {
    "api-reference": {
      "name": "api-reference",
      "title": "index",
      "description": "",
      "category": "api-reference",
      "sections": [
        "How to use this reference",
        "A note for our long-term users",
        "A note for JavaScript users"
      ],
      "content": "import { ContentGrid, ContentGridItem } from '@xyflow/xy-ui';\nimport { BlogPostPreview } from 'xy-shared';\n\n# API Reference\n\nThis reference attempts to document every function, hook, component, and type\nexported by React Flow. If you are looking for guides and tutorials, please refer to our [learn section](/learn).\n\n## How to use this reference\n\nWe think that documentation should answer two broad\nquestions: \"what is this thing?\" and \"how do I use it?\"\n\nTo that end, our API reference aims to **concisely** answer that first question\nand learn section goes into more detail on the second. If you find yourself clicking\naround the reference wondering what the heck any of this means, maybe we have a\nguide that can help you out!\n\n<ContentGrid className=\"mt-8\">\n  <ContentGridItem route=\"/learn/customization/custom-nodes\">\n    <BlogPostPreview\n      title=\"Custom nodes\"\n      intro=\"A powerful feature of React Flow is the ability to add custom nodes. Within your custom nodes you can render everything you want. You can define multiple source and target handles and render form inputs or charts for example. In this guide we will implement a node with an input field that updates some text in another part of the application.\"\n    />\n  </ContentGridItem>\n  <ContentGridItem route=\"/learn/layouting/layouting\">\n    <BlogPostPreview\n      title=\"Layouting\"\n      intro=\"We regularly get asked how to handle layouting in React Flow. While we could build some basic layouting into React Flow, we believe that you know your app's requirements best and with so many options out there we think it's better you choose the best right tool for the job. In this guide we'll look at four layouting libraries and how to use them.\"\n    />\n  </ContentGridItem>\n</ContentGrid>\n\n## A note for our long-term users\n\nIf you're coming here from our old API pages things might look a bit different!\nWe've reorganized our documentation to make it easier to look things up if you\nknow what you're looking for. All our types, components, hooks, and util functions\nget their own page now to help you find exactly what you need.\n\nIf you're new to React Flow or you're not sure where to look for something, take\na look at the section below.\n\n## A note for JavaScript users\n\nReact Flow is written in TypeScript, but we know that not everyone uses it. We\nencourage developers to use the technology that works best for them, and\nthroughout our documentation there is a blend of TypeScript and JavaScript\nexamples.\n\nFor our API reference, however, we use TypeScript's syntax to document the types\nof props and functions. Here's a quick crash course on how to read it:\n\n• `?` means that the field or argument is optional.\n\n• `<T>` in a type definition represents a generic type parameter. Like a function\nargument but for types! The definition `type Array<T> = ...` means a type called\n`Array` that takes a generic type parameter `T`.\n\n• `<T>` when referring to a type is like \"filling in\" a generic type parameter.\nIt's like calling a function but for types! The type `Array<number>` is the\ntype `Array` with the generic type parameter `T` filled in with the type\n`number`.\n\n• `T | U` means that the type is either `T` or `U`: this is often called a\n_union_.\n\n• `T & U` means that the type is both `T` and `U`: this is often called an\n_intersection_.\n\nThe TypeScript folks have their own\n[handy guide for reading types](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\nthat you might find useful. If you're still stuck on something, feel free to\ndrop by our [Discord](https://discord.com/invite/RVmnytFmGW) and ask for help!"
    },
    "api-reference/react-flow-provider": {
      "name": "api-reference/react-flow-provider",
      "title": "The ReactFlowProvider component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<ReactFlowProvider />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ReactFlowProvider/index.tsx/#L9)\n\nThe `<ReactFlowProvider />` component is a\n[context provider](https://react.dev/learn/passing-data-deeply-with-context#) that\nmakes it possible to access a flow's internal state outside of the\n[`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\nprovide rely on this component to work.\n\n```tsx\nimport { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n\nexport default function Flow() {\n  return (\n    <ReactFlowProvider>\n      <ReactFlow nodes={...} edges={...} />\n      <Sidebar />\n    </ReactFlowProvider>\n  )\n}\n\nfunction Sidebar() {\n  // This hook will only work if the component it's used in is a child of a\n  // <ReactFlowProvider />.\n  const nodes = useNodes()\n\n  return (\n    <aside>\n      {nodes.map((node) => (\n        <div key={node.id}>\n          Node {node.id} -\n            x: {node.position.x.toFixed(2)},\n            y: {node.position.y.toFixed(2)}\n        </div>\n      ))}\n    </aside>\n  )\n}\n```\n\n## Props\n\n<APIDocs componentName=\"ReactFlowProvider\" />\n\n## Notes\n\n- If you're using a router and want your flow's state to persist across routes,\n  it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n  your router.\n- If you have multiple flows on the same page you will need to use a separate\n  `<ReactFlowProvider />` for each flow."
    },
    "api-reference/react-flow": {
      "name": "api-reference/react-flow",
      "title": "The ReactFlow component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Common props",
        "Viewport props",
        "Edge props",
        "Event handlers",
        "General Events",
        "Node Events",
        "Edge Events",
        "Connection Events",
        "Pane Events",
        "Selection Events",
        "Interaction props",
        "Connection line props",
        "Keyboard props",
        "Style props",
        "Notes"
      ],
      "content": "import { ReactFlowAPIProps } from '@/references/ReactFlow.props';\n\n# \\<ReactFlow />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/container/ReactFlow/index.tsx/#L47)\n\nThe `<ReactFlow />` component is the heart of your React Flow application. It\nrenders your nodes and edges, handles user interaction, and can manage its own\nstate if used as an [uncontrolled flow](/learn/advanced-use/uncontrolled-flow).\n\n```tsx\nimport { ReactFlow } from '@xyflow/react'\n\nexport default function Flow() {\n  return <ReactFlow\n    nodes={...}\n    edges={...}\n    onNodesChange={...}\n    ...\n  />\n}\n```\n\nThis component takes a lot of different props, most of which are optional. We've\ntried to document them in groups that make sense to help you find your way.\n\n## Common props\n\nThese are the props you will most commonly use when working with React Flow. If\nyou are working with a controlled flow with custom nodes, you will likely use\nalmost all of these!\n\n<ReactFlowAPIProps group=\"common\" />\n\n## Viewport props\n\n<ReactFlowAPIProps group=\"viewport\" />\n\n## Edge props\n\n<ReactFlowAPIProps group=\"edge\" />\n\n## Event handlers\n\n> [!WARNING]\n>\n> It's important to remember to define any event handlers outside of your\n> component or using React's `useCallback` hook. If you don't, this can cause\n> React Flow to enter an infinite re-render loop!\n\n### General Events\n\n<ReactFlowAPIProps group=\"generalEvents\" />\n\n### Node Events\n\n<ReactFlowAPIProps group=\"nodeEvents\" />\n\n### Edge Events\n\n<ReactFlowAPIProps group=\"edgeEvents\" />\n\n### Connection Events\n\n<ReactFlowAPIProps group=\"connectionEvents\" />\n\n### Pane Events\n\n<ReactFlowAPIProps group=\"paneEvents\" />\n\n### Selection Events\n\n<ReactFlowAPIProps group=\"selectionEvents\" />\n\n## Interaction props\n\n<ReactFlowAPIProps group=\"interaction\" />\n\n## Connection line props\n\n<ReactFlowAPIProps group=\"connectionLine\" />\n\n## Keyboard props\n\nReact Flow let's you pass in a few different keyboard shortcuts as another way\nto interact with your flow. We've tried to set up sensible defaults like using\nbackspace to delete any selected nodes or edges, but you can use these props to\nset your own.\n\nTo disable any of these shortcuts, pass in `null` to the prop you want to\ndisable.\n\n<ReactFlowAPIProps group=\"keyboard\" />\n\n## Style props\n\nApplying certain classes to elements rendered inside the canvas will change how\ninteractions are handled. These props let you configure those class names if you\nneed to.\n\n<ReactFlowAPIProps group=\"style\" />\n\n## Notes\n\n- The props of this component get exported as `ReactFlowProps`"
    },
    "api-reference/components/background": {
      "name": "api-reference/components/background",
      "title": "The Background component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Examples",
        "Combining multiple backgrounds",
        "Notes"
      ],
      "content": "# \\<Background />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx)\n\nThe `<Background />` component makes it convenient to render different types of\nbackgrounds common in node-based UIs. It comes with three variants: `lines`,\n`dots` and `cross`.\n\n```jsx\nimport { useState } from 'react';\nimport { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n      <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n    </ReactFlow>\n  );\n}\n```\n\n## Props\n\n<APIDocs componentName=\"Background\" />\n\n## Examples\n\n### Combining multiple backgrounds\n\nIt is possible to layer multiple `<Background />` components on top of one another\nto create something more interesting. The following example shows how to render a\nsquare grid accented every 10th line.\n\n```tsx\nimport { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n\nimport '@xyflow/react/dist/style.css';\n\nexport default function Flow() {\n  return (\n    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n      <Background\n        id=\"1\"\n        gap={10}\n        color=\"#f1f1f1\"\n        variant={BackgroundVariant.Lines}\n      />\n\n      <Background\n        id=\"2\"\n        gap={100}\n        color=\"#ccc\"\n        variant={BackgroundVariant.Lines}\n      />\n    </ReactFlow>\n  );\n}\n```\n\n## Notes\n\n- When combining multiple `<Background />` components it's important to give each\n  of them a unique `id` prop!"
    },
    "api-reference/components/base-edge": {
      "name": "api-reference/components/base-edge",
      "title": "The BaseEdge component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<BaseEdge />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/BaseEdge.tsx)\n\nThe `<BaseEdge />` component gets used internally for all the edges. It can be\nused inside a custom edge and handles the invisible helper edge and the edge label\nfor you.\n\n```jsx\nimport { BaseEdge } from '@xyflow/react';\n\nexport function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n  const [edgePath] = getStraightPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n  });\n\n  const { label, labelStyle, markerStart, markerEnd, interactionWidth } = props;\n\n  return (\n    <BaseEdge\n      path={edgePath}\n      label={label}\n      labelStyle={labelStyle}\n      markerEnd={markerEnd}\n      markerStart={markerStart}\n      interactionWidth={interactionWidth}\n    />\n  );\n}\n```\n\n## Props\n\n<APIDocs\n  componentName=\"BaseEdge\"\n  groupKeys=\"Omit<SVGAttributes<SVGPathElement>, 'd' | 'path' | 'markerStart' | 'markerEnd'>\"\n/>\n\n## Notes\n\n- If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n  you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n  through to the [`<BaseEdge />`](/api-reference/components/base-edge) component. You can see all the props\n  passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type."
    },
    "api-reference/components/control-button": {
      "name": "api-reference/components/control-button",
      "title": "The ControlButton component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# \\<ControlButton />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Controls/ControlButton.tsx)\n\nYou can add buttons to the control panel by using the `<ControlButton />` component\nand pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n\n```jsx\nimport { MagicWand } from '@radix-ui/react-icons'\nimport { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]} edges={[...]}>\n      <Controls>\n        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>\n          <MagicWand />\n        </ControlButton>\n      </Controls>\n    </ReactFlow>\n  )\n}\n```\n\n## Props\n\nThe `<ControlButton />` component accepts any prop valid on a HTML `<button />`\nelement.\n\n<APIDocs componentName=\"ControlButton\" groupKeys=\"ButtonHTMLAttributes<HTMLButtonElement>\" />"
    },
    "api-reference/components/controls": {
      "name": "api-reference/components/controls",
      "title": "The Controls component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<Controls />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Controls/Controls.tsx)\n\nThe `<Controls />` component renders a small panel that contains convenient\nbuttons to zoom in, zoom out, fit the view, and lock the viewport.\n\n```tsx\nimport { ReactFlow, Controls } from '@xyflow/react'\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]} edges={[...]}>\n      <Controls />\n    </ReactFlow>\n  )\n}\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<Controls />` component is exported\nas `ControlProps`.\n\n<APIDocs componentName=\"Controls\" />\n\n## Notes\n\n- To extend or customize the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button)\n  component"
    },
    "api-reference/components/edge-label-renderer": {
      "name": "api-reference/components/edge-label-renderer",
      "title": "The EdgeLabelRenderer component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<EdgeLabelRenderer />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/EdgeLabelRenderer/index.tsx)\n\nEdges are SVG-based. If you want to render more complex labels you can use the\n`<EdgeLabelRenderer />` component to access a div based renderer. This component\nis a portal that renders the label in a `<div />` that is positioned on top of\nthe edges. You can see an example usage of the component in the [edge label renderer](/examples/edges/edge-label-renderer)\nexample.\n\n```jsx\nimport React from 'react';\nimport { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n\nconst CustomEdge = ({ id, data, ...props }) => {\n  const [edgePath, labelX, labelY] = getBezierPath(props);\n\n  return (\n    <>\n      <BaseEdge id={id} path={edgePath} />\n      <EdgeLabelRenderer>\n        <div\n          style={{\n            position: 'absolute',\n            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n            background: '#ffcc00',\n            padding: 10,\n            borderRadius: 5,\n            fontSize: 12,\n            fontWeight: 700,\n          }}\n          className=\"nodrag nopan\"\n        >\n          {data.label}\n        </div>\n      </EdgeLabelRenderer>\n    </>\n  );\n};\n\nexport default CustomEdge;\n```\n\n## Props\n\n<APIDocs componentName=\"EdgeLabelRenderer\" />\n\n## Notes\n\n- The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n  add mouse interactions you need to set the style `pointerEvents: 'all'` and add\n  the `nopan` class on the label or the element you want to interact with."
    },
    "api-reference/components/edge-text": {
      "name": "api-reference/components/edge-text",
      "title": "The EdgeText component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# \\<EdgeText />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/EdgeText.tsx)\n\nYou can use the `<EdgeText />` component as a helper component to display text\nwithin your custom edges.\n\n```jsx\nimport { EdgeText } from '@xyflow/react';\n\nexport function CustomEdgeLabel({ label }) {\n  return (\n    <EdgeText\n      x={100}\n      y={100}\n      label={label}\n      labelStyle={{ fill: 'white' }}\n      labelShowBg\n      labelBgStyle={{ fill: 'red' }}\n      labelBgPadding={[2, 4]}\n      labelBgBorderRadius={2}\n    />\n  );\n}\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<EdgeText />` component is exported\nas `EdgeTextProps`.\n\n<APIDocs componentName=\"EdgeText\" groupKeys=\"Omit<SVGAttributes<SVGElement>, 'x' | 'y'>\" />\n\nAdditionally, you may also pass any standard React HTML attributes such as `onClick`,\n`className` and so on."
    },
    "api-reference/components/edge-toolbar": {
      "name": "api-reference/components/edge-toolbar",
      "title": "The EdgeToolbar component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<EdgeToolbar />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/EdgeToolbar/EdgeToolbar.tsx)\n\nThis component can render a toolbar to one side of a custom edge. This toolbar doesn't\nscale with the viewport so that the content doesn't get too small when zooming out.\n\n```jsx\nimport { memo } from 'react';\nimport { EdgeToolbar, BaseEdge, getBezierPath, type EdgeProps } from '@xyflow/react';\n\nfunction CustomEdge(props: EdgeProps) {\n  const [edgePath, centerX, centerY] = getBezierPath(props);\n\n  return (\n    <>\n      <BaseEdge id={props.id} path={edgePath} />\n      <EdgeToolbar\n        edgeId={props.id}\n        x={centerX}\n        y={centerY}\n        isVisible\n      >\n        <button>\n          some button\n        </button>\n      </EdgeToolbar>\n    </>\n  );\n}\n\nexport default memo(CustomEdge);\n```\n\n## Props\n\n<APIDocs componentName=\"EdgeToolbar\" groupKeys=\"HTMLAttributes<HTMLDivElement>\" />\n\n## Notes\n\n- By default, the toolbar is only visible when the edge is selected. You can override this\n  behavior by setting the `isVisible` prop to `true`."
    },
    "api-reference/components/handle": {
      "name": "api-reference/components/handle",
      "title": "The Handle component",
      "description": "The Handle component is used in your custom nodes to define connection points.",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# \\<Handle />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Handle/index.tsx)\n\nThe `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\nto define connection points.\n\n```jsx\nimport { Handle, Position } from '@xyflow/react';\n\nexport const CustomNode = ({ data }) => {\n  return (\n    <>\n      <div style={{ padding: '10px 20px' }}>\n        {data.label}\n      </div>\n\n      <Handle type=\"target\" position={Position.Left} />\n      <Handle type=\"source\" position={Position.Right} />\n    </>\n  );\n};\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<Handle />` component is exported\nas `HandleProps`.\n\n<APIDocs componentName=\"Handle\" groupKeys=\"Omit<ComponentProps<'div'>, 'id'>\" />"
    },
    "api-reference/components": {
      "name": "api-reference/components",
      "title": "index",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "import { ApiReferenceSummary } from 'xy-shared/server';\n\n# Components\n\n<ApiReferenceSummary category=\"components\" />"
    },
    "api-reference/components/minimap": {
      "name": "api-reference/components/minimap",
      "title": "The MiniMap component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Examples",
        "Making the mini map interactive",
        "Implement a custom mini map node",
        "Customising mini map node color",
        "TypeScript"
      ],
      "content": "# \\<MiniMap />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/MiniMap/MiniMap.tsx)\n\nThe `<MiniMap />` component can be used to render an overview of your flow. It\nrenders each node as an SVG element and visualizes where the current viewport is\nin relation to the rest of the flow.\n\n```jsx\nimport { ReactFlow, MiniMap } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]]} edges={[...]]}>\n      <MiniMap nodeStrokeWidth={3} />\n    </ReactFlow>\n  );\n}\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<MiniMap />` component is exported\nas `MiniMapProps`.\n\n<APIDocs componentName=\"MiniMap\" groupKeys=\"Omit<HTMLAttributes<SVGSVGElement>, 'onClick'>\" />\n\n## Examples\n\n### Making the mini map interactive\n\nBy default, the mini map is non-interactive. To allow users to interact with the\nviewport by panning or zooming the minimap, you can set either of the `zoomable`\nor `pannable` (or both!) props to `true`.\n\n```jsx\nimport { ReactFlow, MiniMap } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]]} edges={[...]]}>\n      <MiniMap pannable zoomable />\n    </ReactFlow>\n  );\n}\n```\n\n### Implement a custom mini map node\n\nIt is possible to pass a custom component to the `nodeComponent` prop to change\nhow nodes are rendered in the mini map. If you do this you **must** use only\nSVG elements in your component if you want it to work correctly.\n\n```jsx\nimport { ReactFlow, MiniMap } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]]} edges={[...]]}>\n      <MiniMap nodeComponent={MiniMapNode} />\n    </ReactFlow>\n  );\n}\n\nfunction MiniMapNode({ x, y }) {\n  return <circle cx={x} cy={y} r=\"50\" />;\n}\n```\n\nCheck out the documentation for [`MiniMapNodeProps`](/api-reference/types/mini-map-node-props)\nto see what props are passed to your custom component.\n\n### Customising mini map node color\n\nThe `nodeColor`, `nodeStrokeColor`, and `nodeClassName` props can be a function\nthat takes a [`Node`](/api-reference/types/node) and computes a value for the prop. This can\nbe used to customize the appearance of each mini map node.\n\nThis example shows how to color each mini map node based on the node's type:\n\n```jsx\nimport { ReactFlow, MiniMap } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]]} edges={[...]]}>\n      <MiniMap nodeColor={nodeColor} />\n    </ReactFlow>\n  );\n}\n\nfunction nodeColor(node) {\n  switch (node.type) {\n    case 'input':\n      return '#6ede87';\n    case 'output':\n      return '#6865A5';\n    default:\n      return '#ff0072';\n  }\n}\n```\n\n## TypeScript\n\nThis component accepts a generic type argument of custom node types. See this\n[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\n<MiniMap<CustomNodeType> nodeColor={nodeColor} />\n```"
    },
    "api-reference/components/node-resize-control": {
      "name": "api-reference/components/node-resize-control",
      "title": "The NodeResizeControl component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# \\<NodeResizeControl />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizeControl.tsx)\n\nTo create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n\n## Props\n\nFor TypeScript users, the props type for the `<NodeResizeControl />` component is exported\nas `ResizeControlProps`.\n\n<APIDocs componentName=\"NodeResizeControl\" />"
    },
    "api-reference/components/node-resizer": {
      "name": "api-reference/components/node-resizer",
      "title": "The NodeResizer component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Examples",
        "Custom Resize Controls",
        "Notes"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\n\n# \\<NodeResizer />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizer.tsx)\n\nThe `<NodeResizer />` component can be used to add a resize functionality to your\nnodes. It renders draggable controls around the node to resize in all directions.\n\n```jsx\nimport { memo } from 'react';\nimport { Handle, Position, NodeResizer } from '@xyflow/react';\n\nconst ResizableNode = ({ data }) => {\n  return (\n    <>\n      <NodeResizer minWidth={100} minHeight={30} />\n      <Handle type=\"target\" position={Position.Left} />\n      <div style={{ padding: 10 }}>{data.label}</div>\n      <Handle type=\"source\" position={Position.Right} />\n    </>\n  );\n};\n\nexport default memo(ResizableNode);\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<NodeResizer />` component is exported\nas `NodeResizerProps`.\n\n<APIDocs componentName=\"NodeResizer\" />\n\n## Examples\n\nHead over to the [example page](/examples/nodes/node-resizer) to see how this is done.\n\n<RemoteCodeViewer route=\"examples/nodes/node-resizer\" framework=\"react\" />\n\n### Custom Resize Controls\n\nTo build custom resize controls, you can use the [NodeResizeControl](/api-reference/components/node-resize-control) component and customize it.\n\n## Notes\n\n- Take a look at the docs for the [`NodeProps`](/api-reference/types/node-props) type or the\n  guide on [custom nodes](/learn/customization/custom-nodes) to see how to\n  implement your own nodes."
    },
    "api-reference/components/node-toolbar": {
      "name": "api-reference/components/node-toolbar",
      "title": "The NodeToolbar component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props",
        "Notes"
      ],
      "content": "# \\<NodeToolbar />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeToolbar/NodeToolbar.tsx)\n\nThis component can render a toolbar or tooltip to one side of a custom node. This\ntoolbar doesn't scale with the viewport so that the content is always visible.\n\n```jsx\nimport { memo } from 'react';\nimport { Handle, Position, NodeToolbar } from '@xyflow/react';\n\nconst CustomNode = ({ data }) => {\n  return (\n    <>\n      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n        <button>delete</button>\n        <button>copy</button>\n        <button>expand</button>\n      </NodeToolbar>\n\n      <div style={{ padding: '10px 20px' }}>\n        {data.label}\n      </div>\n\n      <Handle type=\"target\" position={Position.Left} />\n      <Handle type=\"source\" position={Position.Right} />\n    </>\n  );\n};\n\nexport default memo(CustomNode);\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<NodeToolbar />` component is exported\nas `NodeToolbarProps`. Additionally, the `<NodeToolbar />` component accepts all props of the HTML `<div />`\nelement.\n\n<APIDocs componentName=\"NodeToolbar\" groupKeys=\"HTMLAttributes<HTMLDivElement>\" />\n\n## Notes\n\n- By default, the toolbar is only visible when a node is selected. If multiple\n  nodes are selected it will not be visible to prevent overlapping toolbars or\n  clutter. You can override this behavior by setting the `isVisible` prop to\n  `true`."
    },
    "api-reference/components/panel": {
      "name": "api-reference/components/panel",
      "title": "The Panel component",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# \\<Panel />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Panel/index.tsx)\n\nThe `<Panel />` component helps you position content above the viewport. It is\nused internally by the [`<MiniMap />`](/api-reference/components/minimap) and [`<Controls />`](/api-reference/components/controls)\ncomponents.\n\n```jsx\nimport { ReactFlow, Panel } from '@xyflow/react';\n\nexport default function Flow() {\n  return (\n    <ReactFlow nodes={[...]} fitView>\n      <Panel position=\"top-left\">top-left</Panel>\n      <Panel position=\"top-center\">top-center</Panel>\n      <Panel position=\"top-right\">top-right</Panel>\n      <Panel position=\"bottom-left\">bottom-left</Panel>\n      <Panel position=\"bottom-center\">bottom-center</Panel>\n      <Panel position=\"bottom-right\">bottom-right</Panel>\n      <Panel position=\"center-left\">center-left</Panel>\n      <Panel position=\"center-right\">center-right</Panel>\n    </ReactFlow>\n  );\n}\n```\n\n## Props\n\nFor TypeScript users, the props type for the `<Panel />` component is exported\nas `PanelProps`. Additionally, the `<Panel />` component accepts all props of the HTML `<div />`\nelement.\n\n<APIDocs componentName=\"Panel\" groupKeys=\"ComponentProps<'div'>\" />"
    },
    "api-reference/components/viewport-portal": {
      "name": "api-reference/components/viewport-portal",
      "title": "The ViewportPortal component",
      "description": "The ViewportPortal component can be used to add components to the same viewport of the flow where nodes and edges are rendered. This is useful when you want to render your own components that are adhere to the same coordinate system as the nodes & edges and are also affected by zooming and panning",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# &lt;ViewportPortal />\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ViewportPortal/index.tsx)\n\n`<ViewportPortal />` component can be used to add components to the same viewport of the flow where nodes and edges are rendered.\nThis is useful when you want to render your own components that adhere to the same coordinate system as the nodes & edges and are also\naffected by zooming and panning\n\n```jsx\nimport React from 'react';\nimport { ViewportPortal } from '@xyflow/react';\n\nexport default function () {\n  return (\n    <ViewportPortal>\n      <div\n        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n      >\n        This div is positioned at [100, 100] on the flow.\n      </div>\n    </ViewportPortal>\n  );\n}\n```\n\n## Props\n\n<APIDocs componentName=\"ViewportPortal\" />"
    },
    "api-reference/hooks": {
      "name": "api-reference/hooks",
      "title": "index",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "import { ApiReferenceSummary } from 'xy-shared/server';\n\n# Hooks\n\n<ApiReferenceSummary category=\"hooks\" />"
    },
    "api-reference/hooks/use-connection": {
      "name": "api-reference/hooks/use-connection",
      "title": "use-connection",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# useConnection()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useConnection.ts)\n\nThe `useConnection` hook returns the current connection state when there is an active connection interaction. If no connection interaction is active, it returns `null` for every property. A typical use case for this hook is to colorize handles based on a certain condition (e.g. if the connection is valid or not).\n\n```tsx\nimport { useConnection } from '@xyflow/react';\n\nexport default function App() {\n  const connection = useConnection();\n\n  return (\n    <div>\n      {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useConnection\" />"
    },
    "api-reference/hooks/use-edges-state": {
      "name": "api-reference/hooks/use-edges-state",
      "title": "use-edges-state",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript",
        "Notes"
      ],
      "content": "# useEdgesState()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)\n\nThis hook makes it easy to prototype a controlled flow where you manage the\nstate of nodes and edges outside the `ReactFlowInstance`. You can think of it\nlike React's `useState` hook with an additional helper callback.\n\n```jsx\nimport { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n\nconst initialNodes = [];\nconst initialEdges = [];\n\nexport default function () {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n    />\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useEdgesState\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom edge types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodes = useEdgesState<CustomEdgeType>();\n```\n\n## Notes\n\n- This hook was created to make prototyping easier and our documentation\n  examples clearer. Although it is OK to use this hook in production, in\n  practice you may want to use a more sophisticated state management solution\n  like [Zustand](/docs/guides/state-management/) instead."
    },
    "api-reference/hooks/use-edges": {
      "name": "api-reference/hooks/use-edges",
      "title": "use-edges",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript",
        "Notes"
      ],
      "content": "# useEdges()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useEdges.ts)\n\nThis hook returns an array of the current edges. Components that use this hook\nwill re-render **whenever any edge changes**.\n\n```jsx\nimport { useEdges } from '@xyflow/react';\n\nexport default function () {\n  const edges = useEdges();\n\n  return <div>There are currently {edges.length} edges!</div>;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useEdges\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom edge types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodes = useEdges<CustomEdgeType>();\n```\n\n## Notes\n\n- Relying on `useEdges` unnecessarily can be a common cause of performance\n  issues. Whenever any edge changes, this hook will cause the component to\n  re-render. Often we actually care about something more specific, like when\n  the _number_ of edges changes: where possible try to use\n  [`useStore`](/api-reference/hooks/use-store) instead."
    },
    "api-reference/hooks/use-handle-connections": {
      "name": "api-reference/hooks/use-handle-connections",
      "title": "use-handle-connections",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# useHandleConnections()\n\n> [!WARNING]\n>\n>  `useHandleConnections` is deprecated in favor of the more capable\n>  [useNodeConnections](/api-reference/hooks/use-node-connections).\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useHandleConnections.ts)\n\nThis hook returns an array connections on a specific handle or handle type.\n\n```jsx\nimport { useHandleConnections } from '@xyflow/react';\n\nexport default function () {\n  const connections = useHandleConnections({ type: 'target', id: 'my-handle' });\n\n  return (\n    <div>There are currently {connections.length} incoming connections!</div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useHandleConnections\" />"
    },
    "api-reference/hooks/use-internal-node": {
      "name": "api-reference/hooks/use-internal-node",
      "title": "use-internal-node",
      "description": "This hook returns an InternalNode object for the given node ID.",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript"
      ],
      "content": "# useInternalNode()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useInternalNode.ts)\n\nThis hook returns the internal representation of a specific node. Components that use this hook\nwill re-render **whenever any node changes**, including when a node is selected\nor moved.\n\n```jsx\nimport { useInternalNode } from '@xyflow/react';\n\nexport default function () {\n  const internalNode = useInternalNode('node-1');\n  const absolutePosition = internalNode.internals.positionAbsolute;\n\n  return (\n    <div>\n      The absolute position of the node is at:\n      <p>x: {absolutePosition.x}</p>\n      <p>y: {absolutePosition.y}</p>\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useInternalNode\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst internalNode = useInternalNode<CustomNodeType>();\n```"
    },
    "api-reference/hooks/use-key-press": {
      "name": "api-reference/hooks/use-key-press",
      "title": "use-key-press",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useKeyPress()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useKeyPress.ts)\n\nThis hook lets you listen for specific key codes and tells you whether they are\ncurrently pressed or not.\n\n```jsx\nimport { useKeyPress } from '@xyflow/react';\n\nexport default function () {\n  const spacePressed = useKeyPress('Space');\n  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n\n  return (\n    <div>\n      {spacePressed && <p>Space pressed!</p>}\n      {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useKeyPress\" />\n\n## Notes\n\n- This hook does not rely on a `ReactFlowInstance` so you are free to use it\n  anywhere in your app!"
    },
    "api-reference/hooks/use-node-connections": {
      "name": "api-reference/hooks/use-node-connections",
      "title": "use-node-connections",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# useNodeConnections()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodeConnections.ts)\n\nThis hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n\n```jsx\nimport { useNodeConnections } from '@xyflow/react';\n\nexport default function () {\n  const connections = useNodeConnections({\n    handleType: 'target',\n    handleId: 'my-handle',\n  });\n\n  return (\n    <div>There are currently {connections.length} incoming connections!</div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodeConnections\" />"
    },
    "api-reference/hooks/use-node-id": {
      "name": "api-reference/hooks/use-node-id",
      "title": "use-node-id",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useNodeId()\n\n[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/contexts/NodeIdContext.ts/#L7)\n\nYou can use this hook to get the id of the node it is used inside. It is useful\nif you need the node's id deeper in the render tree but don't want to manually\ndrill down the id as a prop.\n\n```js\nimport { useNodeId } from '@xyflow/react';\n\nexport default function CustomNode() {\n  return (\n    <div>\n      <span>This node has an id of </span>\n      <NodeIdDisplay />\n    </div>\n  );\n}\n\nfunction NodeIdDisplay() {\n  const nodeId = useNodeId();\n\n  return <span>{nodeId}</span>;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodeId\" />\n\n## Notes\n\n- This hook should only be used within a custom node or its children."
    },
    "api-reference/hooks/use-nodes-data": {
      "name": "api-reference/hooks/use-nodes-data",
      "title": "use-nodes-data",
      "description": "With this hook you can subscribe to changes of a node data of a specific node.",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript"
      ],
      "content": "# useNodesData()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesData.ts)\n\nThis hook lets you subscribe to changes of a specific nodes `data` object.\n\n```jsx\nimport { useNodesData } from '@xyflow/react';\n\nexport default function () {\n  const nodeData = useNodesData('nodeId-1');\n\n  const nodesData = useNodesData(['nodeId-1', 'nodeId-2']);\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodesData\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodesData = useNodesData<NodesType>(['nodeId-1', 'nodeId-2']);\n```"
    },
    "api-reference/hooks/use-nodes-initialized": {
      "name": "api-reference/hooks/use-nodes-initialized",
      "title": "use-nodes-initialized",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useNodesInitialized()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesInitialized.ts)\n\nThis hook tells you whether all the nodes in a flow have been measured and given\na width and height. When you add a node to the flow, this hook will return\n`false` and then `true` again once the node has been measured.\n\n```jsx\nimport { useReactFlow, useNodesInitialized } from '@xyflow/react';\nimport { useEffect, useState } from 'react';\n\nconst options = {\n  includeHiddenNodes: false,\n};\n\nexport default function useLayout() {\n  const { getNodes } = useReactFlow();\n  const nodesInitialized = useNodesInitialized(options);\n  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n\n  useEffect(() => {\n    if (nodesInitialized) {\n      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n    }\n  }, [nodesInitialized]);\n\n  return layoutedNodes;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodesInitialized\" />\n\n## Notes\n\n- This hook always returns `false` if the internal nodes array is empty."
    },
    "api-reference/hooks/use-nodes-state": {
      "name": "api-reference/hooks/use-nodes-state",
      "title": "use-nodes-state",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript",
        "Notes"
      ],
      "content": "# useNodesState()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)\n\nThis hook makes it easy to prototype a controlled flow where you manage the\nstate of nodes and edges outside the `ReactFlowInstance`. You can think of it\nlike React's `useState` hook with an additional helper callback.\n\n```jsx\nimport { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n\nconst initialNodes = [];\nconst initialEdges = [];\n\nexport default function () {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n    />\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodesState\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodes = useNodesState<CustomNodeType>();\n```\n\n## Notes\n\n- This hook was created to make prototyping easier and our documentation\n  examples clearer. Although it is OK to use this hook in production, in\n  practice you may want to use a more sophisticated state management solution\n  like [Zustand](/docs/guides/state-management/) instead."
    },
    "api-reference/hooks/use-nodes": {
      "name": "api-reference/hooks/use-nodes",
      "title": "use-nodes",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript",
        "Notes"
      ],
      "content": "# useNodes()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodes.ts)\n\nThis hook returns an array of the current nodes. Components that use this hook\nwill re-render **whenever any node changes**, including when a node is selected\nor moved.\n\n```jsx\nimport { useNodes } from '@xyflow/react';\n\nexport default function () {\n  const nodes = useNodes();\n\n  return <div>There are currently {nodes.length} nodes!</div>;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useNodes\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodes = useNodes<CustomNodeType>();\n```\n\n## Notes\n\n- Relying on `useNodes` unnecessarily can be a common cause of performance\n  issues. Whenever any node changes, this hook will cause the component to\n  re-render. Often we actually care about something more specific, like when\n  the _number_ of nodes changes: where possible try to use\n  [`useStore`](/api-reference/hooks/use-store) instead."
    },
    "api-reference/hooks/use-on-selection-change": {
      "name": "api-reference/hooks/use-on-selection-change",
      "title": "use-on-selection-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useOnSelectionChange()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnSelectionChange.ts)\n\nThis hook lets you listen for changes to both node and edge selection. As the\nname implies, the callback you provide will be called whenever the selection of\n_either_ nodes or edges changes.\n\n> [!WARNING]\n>\n> You need to memoize the passed `onChange` handler, otherwise the hook will not\n> work correctly.\n\n```jsx\nimport { useState } from 'react';\nimport { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n\nfunction SelectionDisplay() {\n  const [selectedNodes, setSelectedNodes] = useState([]);\n  const [selectedEdges, setSelectedEdges] = useState([]);\n\n  // the passed handler has to be memoized, otherwise the hook will not work correctly\n  const onChange = useCallback(({ nodes, edges }) => {\n    setSelectedNodes(nodes.map((node) => node.id));\n    setSelectedEdges(edges.map((edge) => edge.id));\n  }, []);\n\n  useOnSelectionChange({\n    onChange,\n  });\n\n  return (\n    <div>\n      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n      <p>Selected edges: {selectedEdges.join(', ')}</p>\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useOnSelectionChange\" />\n\n## Notes\n\n- This hook can only be used in a component that is a child of a\n  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a\n  [`<ReactFlow />`](/api-reference/react-flow) component."
    },
    "api-reference/hooks/use-on-viewport-change": {
      "name": "api-reference/hooks/use-on-viewport-change",
      "title": "use-on-viewport-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useOnViewportChange()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnViewportChange.ts)\n\nThe `useOnViewportChange` hook lets you listen for changes to the viewport such\nas panning and zooming. You can provide a callback for each phase of a viewport\nchange: `onStart`, `onChange`, and `onEnd`.\n\n```tsx\nimport { useCallback } from 'react';\nimport { useOnViewportChange } from '@xyflow/react';\n\nfunction ViewportChangeLogger() {\n  useOnViewportChange({\n    onStart: (viewport: Viewport) => console.log('start', viewport),\n    onChange: (viewport: Viewport) => console.log('change', viewport),\n    onEnd: (viewport: Viewport) => console.log('end', viewport),\n  });\n\n  return null;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useOnViewportChange\" />\n\n## Notes\n\n- This hook can only be used in a component that is a child of a\n  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a\n  [`<ReactFlow />`](/api-reference/react-flow) component."
    },
    "api-reference/hooks/use-react-flow": {
      "name": "api-reference/hooks/use-react-flow",
      "title": "use-react-flow",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript",
        "Notes"
      ],
      "content": "# useReactFlow()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useReactFlow.ts)\n\nThis hook returns a [`ReactFlowInstance`](/api-reference/types/react-flow-instance) that can\nbe used to update nodes and edges, manipulate the viewport, or query the current\nstate of the flow.\n\n```jsx\nimport { useCallback, useState } from 'react';\nimport { useReactFlow } from '@xyflow/react';\n\nexport function NodeCounter() {\n  const reactFlow = useReactFlow();\n  const [count, setCount] = useState(0);\n  const countNodes = useCallback(() => {\n    setCount(reactFlow.getNodes().length);\n    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n    // because at the first render, it's not initialized yet and some functions might not work.\n  }, [reactFlow]);\n\n  return (\n    <div>\n      <button onClick={countNodes}>Update count</button>\n      <p>There are {count} nodes in the flow.</p>\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useReactFlow\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node & edge types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst reactFlow = useReactFlow<CustomNodeType, CustomEdgeType>();\n```\n\n## Notes\n\n- This hook can only be used in a component that is a child of a\n  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a\n  [`<ReactFlow />`](/api-reference/react-flow) component.\n- Unlike [`useNodes`](/api-reference/hooks/use-nodes) or [`useEdges`](/api-reference/hooks/use-edges), this hook won't\n  cause your component to re-render when state changes. Instead, you can query\n  the state when you need it by using methods on the [`ReactFlowInstance`](/api-reference/types/react-flow-instance)\n  this hook returns."
    },
    "api-reference/hooks/use-store-api": {
      "name": "api-reference/hooks/use-store-api",
      "title": "use-store-api",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "TypeScript"
      ],
      "content": "# useStoreApi()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)\n\nIn some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n\n> [!NOTE]\n>\n> This hook should only be used if there is no other way to access the internal\n> state. For many of the common use cases, there are dedicated hooks available\n> such as [`useReactFlow`](/api-reference/hooks/use-react-flow),\n> [`useViewport`](/api-reference/hooks/use-viewport), etc.\n\n\n```tsx\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, useStoreApi } from '@xyflow/react';\n\nconst NodesLengthDisplay = () => {\n  const [nodesLength, setNodesLength] = useState(0);\n  const store = useStoreApi();\n\n  const onClick = useCallback(() => {\n    const { nodes } = store.getState();\n    const length = nodes.length || 0;\n\n    setNodesLength(length);\n  }, [store]);\n\n  return (\n    <div>\n      <p>The current number of nodes is: {nodesLength}</p>\n      <button onClick={onClick}>Update node length.</button>\n    </div>\n  );\n};\n\nfunction Flow() {\n  return (\n    <ReactFlow nodes={nodes}>\n      <NodesLengthLogger />\n    </ReactFlow>\n  );\n}\n```\n\nThis example computes the number of nodes in the flow _on-demand_. This is in\ncontrast to the example in the [`useStore`](/api-reference/hooks/use-store) hook that re-renders\nthe component whenever the number of nodes changes.\n\nChoosing whether to calculate values on-demand or to subscribe to changes as they\nhappen is a bit of a balancing act. On the one hand, putting too many heavy\ncalculations in an event handler can make your app feel sluggish or unresponsive.\nOn the other hand, computing values eagerly can lead to slow or unnecessary\nre-renders.\n\nWe make both this hook and [`useStore`](/api-reference/hooks/use-store) available so that you can\nchoose the approach that works best for your use-case.\n\n## Signature\n\n<APIDocs functionName=\"useStoreApi\" />\n\n## TypeScript\n\nThis hook accepts a generic type argument of custom node & edge types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst store = useStoreApi<CustomNodeType, CustomEdgeType>();\n```"
    },
    "api-reference/hooks/use-store": {
      "name": "api-reference/hooks/use-store",
      "title": "use-store",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Examples",
        "Triggering store actions",
        "TypeScript"
      ],
      "content": "import { Callout } from 'nextra/components';\n\n# useStore()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)\n\nThis hook can be used to subscribe to internal state changes of the React Flow\ncomponent. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\nstate management library, so you should check out their docs for more details.\n\n<Callout type=\"info\">\n  This hook should only be used if there is no other way to access the internal\n  state. For many of the common use cases, there are dedicated hooks available\n  such as [`useReactFlow`](/api-reference/hooks/use-react-flow),\n  [`useViewport`](/api-reference/hooks/use-viewport), etc.\n</Callout>\n\n```jsx\nimport { ReactFlow, useStore } from '@xyflow/react';\n\nconst nodesLengthSelector = (state) =>\n  state.nodes.length || 0;\n\nconst NodesLengthDisplay = () => {\n  const nodesLength = useStore(nodesLengthSelector);\n\n  return <div>The current number of nodes is: {nodesLength}</div>;\n};\n\nfunction Flow() {\n  return (\n    <ReactFlow nodes={[...]}>\n      <NodesLengthDisplay />\n    </ReactFlow>\n  );\n}\n```\n\nThis example computes the number of nodes eagerly. Whenever the number of nodes\nin the flow changes, the `<NodesLengthDisplay />` component will re-render. This\nis in contrast to the example in the [`useStoreApi`](/api-reference/hooks/use-store-api) hook that only\ncomputes the number of nodes when a button is clicked.\n\nChoosing whether to calculate values on-demand or to subscribe to changes as they\nhappen is a bit of a balancing act. On the one hand, putting too many heavy\ncalculations in an event handler can make your app feel sluggish or unresponsive.\nOn the other hand, computing values eagerly can lead to slow or unnecessary\nre-renders.\n\nWe make both this hook and [`useStoreApi`](/api-reference/hooks/use-store-api) available so that you\ncan choose the approach that works best for your use-case.\n\n## Signature\n\n<APIDocs functionName=\"useStore\" />\n\n## Examples\n\n### Triggering store actions\n\nYou can manipulate the internal React Flow state by triggering internal actions\nthrough the `useStore` hook. These actions are already used internally throughout\nthe library, but you can also use them to implement custom functionality.\n\n```jsx\nimport { useStore } from '@xyflow/react';\n\nconst setMinZoomSelector = (state) => state.setMinZoom;\n\nfunction MinZoomSetter() {\n  const setMinZoom = useStore(setMinZoomSelector);\n\n  return <button onClick={() => setMinZoom(6)}>set min zoom</button>;\n}\n```\n\n## TypeScript\n\nThis hook can be typed by typing the selector function. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst nodes = useStore((s: ReactFlowState<CustomNodeType>) => s.nodes);\n```"
    },
    "api-reference/hooks/use-update-node-internals": {
      "name": "api-reference/hooks/use-update-node-internals",
      "title": "use-update-node-internals",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useUpdateNodeInternals()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useUpdateNodeInternals.ts)\n\nWhen you programmatically add or remove handles to a node or update a node's\nhandle position, you need to let React Flow know about it using this hook. This\nwill update the internal dimensions of the node and properly reposition handles\non the canvas if necessary.\n\n```jsx\nimport { useCallback, useState } from 'react';\nimport { Handle, useUpdateNodeInternals } from '@xyflow/react';\n\nexport default function RandomHandleNode({ id }) {\n  const updateNodeInternals = useUpdateNodeInternals();\n  const [handleCount, setHandleCount] = useState(0);\n  const randomizeHandleCount = useCallback(() => {\n    setHandleCount(Math.floor(Math.random() * 10));\n    updateNodeInternals(id);\n  }, [id, updateNodeInternals]);\n\n  return (\n    <>\n      {Array.from({ length: handleCount }).map((_, index) => (\n        <Handle\n          key={index}\n          type=\"target\"\n          position=\"left\"\n          id={`handle-${index}`}\n        />\n      ))}\n\n      <div>\n        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n        <p>There are {handleCount} handles on this node.</p>\n      </div>\n    </>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useUpdateNodeInternals\" />\n\n## Notes\n\n- This hook can only be used in a component that is a child of a\n  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a\n  [`<ReactFlow />`](/api-reference/react-flow) component."
    },
    "api-reference/hooks/use-viewport": {
      "name": "api-reference/hooks/use-viewport",
      "title": "use-viewport",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# useViewport()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useViewport.ts)\n\nThe `useViewport` hook is a convenient way to read the current state of the\n[`Viewport`](/api-reference/types/viewport) in a component. Components that use this hook\nwill re-render **whenever the viewport changes**.\n\n```jsx\nimport { useViewport } from '@xyflow/react';\n\nexport default function ViewportDisplay() {\n  const { x, y, zoom } = useViewport();\n\n  return (\n    <div>\n      <p>\n        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n      </p>\n    </div>\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"useViewport\" />\n\n## Notes\n\n- This hook can only be used in a component that is a child of a\n  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a\n  [`<ReactFlow />`](/api-reference/react-flow) component."
    },
    "api-reference/types/align": {
      "name": "api-reference/types/align",
      "title": "align",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# Align\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts#L174)\n\nThe `Align` type contains the values expected by the `align` prop of the [NodeToolbar](/api-reference/components/node-toolbar) component \n\n```ts\nexport type Align = 'center' | 'start' | 'end';\n```"
    },
    "api-reference/types/aria-label-config": {
      "name": "api-reference/types/aria-label-config",
      "title": "aria-label-config",
      "description": "With the AriaLabelConfig you can customize the aria labels and descriptions used by React Flow.",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Default config"
      ],
      "content": "# AriaLabelConfig\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/constants.ts/)\n\nWith the `AriaLabelConfig` you can customize the aria labels used by React Flow. This is useful if you want to translate the labels or if you want to change them to better suit your application.\n\n## Fields\n\n<APIDocs typeName=\"AriaLabelConfig\" packageName=\"react\" />\n\n## Default config\n\n```js\nconst defaultAriaLabelConfig = {\n  'node.a11yDescription.default':\n    'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n  'node.a11yDescription.keyboardDisabled':\n    'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n  'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }: { direction: string; x: number; y: number }) =>\n    `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n  'edge.a11yDescription.default':\n    'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n\n  // Control elements\n  'controls.ariaLabel': 'Control Panel',\n  'controls.zoomIn.ariaLabel': 'Zoom In',\n  'controls.zoomOut.ariaLabel': 'Zoom Out',\n  'controls.fitView.ariaLabel': 'Fit View',\n  'controls.interactive.ariaLabel': 'Toggle Interactivity',\n\n  // Mini map\n  'minimap.ariaLabel': 'Mini Map',\n\n  // Handle\n  'handle.ariaLabel': 'Handle',\n};\n```"
    },
    "api-reference/types/background-variant": {
      "name": "api-reference/types/background-variant",
      "title": "background-variant",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# BackgroundVariant\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/types.ts)\n\nThe three variants are exported as an enum for convenience. You can either import\nthe enum and use it like `BackgroundVariant.Lines` or you can use the raw string\nvalue directly.\n\n```ts\nexport enum BackgroundVariant {\n  Lines = 'lines',\n  Dots = 'dots',\n  Cross = 'cross',\n}\n```"
    },
    "api-reference/types/color-mode": {
      "name": "api-reference/types/color-mode",
      "title": "color-mode",
      "description": "The ColorMode type defines the available color modes for the ReactFlow component.",
      "category": "api-reference",
      "sections": [],
      "content": "# ColorMode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts)\n\nThe `ColorMode` type defines the available color modes for the ReactFlow component. This can be used to control the theme of the flow diagram.\n\n```ts\nexport type ColorMode = 'light' | 'dark' | 'system';\n```"
    },
    "api-reference/types/connection-line-component-props": {
      "name": "api-reference/types/connection-line-component-props",
      "title": "connection-line-component-props",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Props"
      ],
      "content": "# ConnectionLineComponentProps\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L193)\n\nIf you want to render a custom component for connection lines, you can set the\n`connectionLineComponent` prop on the\n[`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineComponent) component.\nThe `ConnectionLineComponentProps` are passed to your custom component.\n\n## Props\n\n<APIDocs typeName=\"ConnectionLineComponentProps\" />"
    },
    "api-reference/types/connection-line-component": {
      "name": "api-reference/types/connection-line-component",
      "title": "connection-line-component",
      "description": "Custom React component for rendering the connection line during edge creation.",
      "category": "api-reference",
      "sections": [],
      "content": "# ConnectionLineComponent\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L265)\n\nThe `ConnectionLineComponent` type allows you to provide a custom React component to render the connection line when users create new edges. The component receives `ConnectionLineComponentProps` as its props.\n\n```ts\ntype ConnectionLineComponent = React.ComponentType<ConnectionLineComponentProps>;\n```"
    },
    "api-reference/types/connection-line-type": {
      "name": "api-reference/types/connection-line-type",
      "title": "connection-line-type",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Notes"
      ],
      "content": "# ConnectionLineType\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L62)\n\nIf you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\ncomponent, it will dictate the style of connection line rendered when creating\nnew edges.\n\n```ts\nexport enum ConnectionLineType {\n  Bezier = 'default',\n  Straight = 'straight',\n  Step = 'step',\n  SmoothStep = 'smoothstep',\n  SimpleBezier = 'simplebezier',\n}\n```\n\n## Notes\n\n- If you choose to render a custom connection line component, this value will be\n  passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props)."
    },
    "api-reference/types/connection-mode": {
      "name": "api-reference/types/connection-mode",
      "title": "connection-mode",
      "description": "Specifies the rules for how connections between nodes are established.",
      "category": "api-reference",
      "sections": [],
      "content": "# ConnectionMode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L68)\n\nThe `ConnectionMode` enum provides two options for connection behavior in React Flow:\n\n- `Strict`: Connections can only be made starting from a source handle and ending on a target handle\n- `Loose`: Connections can be made between any handles, regardless of type\n\n```ts\nenum ConnectionMode {\n  Strict = 'strict',\n  Loose = 'loose',\n}\n```"
    },
    "api-reference/types/connection-state": {
      "name": "api-reference/types/connection-state",
      "title": "connection-state",
      "description": "Data about an ongoing connection.",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# ConnectionState\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L148-L174)\n\nThe `ConnectionState` type bundles all information about an ongoing connection. It is returned by the [`useConnection`](/api-reference/hooks/use-connection) hook.\n\n```ts\ntype NoConnection = {\n  inProgress: false;\n  isValid: null;\n  from: null;\n  fromHandle: null;\n  fromPosition: null;\n  fromNode: null;\n  to: null;\n  toHandle: null;\n  toPosition: null;\n  toNode: null;\n};\ntype ConnectionInProgress = {\n  inProgress: true;\n  isValid: boolean | null;\n  from: XYPosition;\n  fromHandle: Handle;\n  fromPosition: Position;\n  fromNode: NodeBase;\n  to: XYPosition;\n  toHandle: Handle | null;\n  toPosition: Position;\n  toNode: NodeBase | null;\n};\n\ntype ConnectionState = ConnectionInProgress | NoConnection;\n```\n\n## Fields\n\n<APIDocs typeName=\"ConnectionState\" />"
    },
    "api-reference/types/connection": {
      "name": "api-reference/types/connection",
      "title": "connection",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# Connection\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L29-L34)\n\nThe `Connection` type is the basic minimal description of an\n[`Edge`](/api-reference/types/edge) between two nodes. The\n[`addEdge`](/api-reference/utils/add-edge) util can be used to upgrade a `Connection` to\nan [`Edge`](/api-reference/types/edge).\n\n## Fields\n\n<APIDocs typeName=\"Connection\" />"
    },
    "api-reference/types/coordinate-extent": {
      "name": "api-reference/types/coordinate-extent",
      "title": "coordinate-extent",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Notes"
      ],
      "content": "# CoordinateExtent\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L36-L37)\n\nA coordinate extent represents two points in a coordinate system: one in the top\nleft corner and one in the bottom right corner. It is used to represent the\nbounds of nodes in the flow or the bounds of the viewport.\n\n```ts\nexport type CoordinateExtent = [[number, number], [number, number]];\n```\n\n## Notes\n\n- Props that expect a `CoordinateExtent` usually default to `[[-∞, -∞], [+∞, +∞]]`\n  to represent an unbounded extent."
    },
    "api-reference/types/default-edge-options": {
      "name": "api-reference/types/default-edge-options",
      "title": "default-edge-options",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# DefaultEdgeOptions\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L88-L89)\n\nMany properties on an [`Edge`](/api-reference/types/edge) are optional. When a new edge is\ncreated, the properties that are not provided will be filled in with the default values\npassed to the `defaultEdgeOptions` prop of the\n[`<ReactFlow />`](/api-reference/react-flow#defaultedgeoptions) component.\n\n## Fields\n\n<APIDocs typeName=\"DefaultEdgeOptions\" />"
    },
    "api-reference/types/delete-elements": {
      "name": "api-reference/types/delete-elements",
      "title": "delete-elements",
      "description": "DeleteElements deletes nodes and edges from the flow and return the deleted edges and nodes asynchronously.",
      "category": "api-reference",
      "sections": [],
      "content": "# DeleteElements\n\nDeleteElements deletes provided nodes and edges and handles deleting any connected edges as well as child nodes. Returns successfully deleted edges and nodes asynchronously.\n\n```ts\nexport type DeleteElements = (payload: {\n  nodes?: (Partial<Node> & { id: Node['id'] })[];\n  edges?: (Partial<Edge> & { id: Edge['id'] })[];\n}) => Promise<{\n  deletedNodes: Node[];\n  deletedEdges: Edge[];\n}>;\n```"
    },
    "api-reference/types/edge-change": {
      "name": "api-reference/types/edge-change",
      "title": "edge-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Variants",
        "EdgeAddChange",
        "EdgeRemoveChange",
        "EdgeReplaceChange",
        "EdgeSelectionChange"
      ],
      "content": "# EdgeChange\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/changes.ts/#L68-L72)\n\nThe [`onEdgesChange`](/api-reference/react-flow#on-edges-change) callback takes\nan array of `EdgeChange` objects that you should use to update your flow's state.\nThe `EdgeChange` type is a union of four different object types that represent that\nvarious ways an edge can change in a flow.\n\n```ts\nexport type EdgeChange =\n  | EdgeAddChange\n  | EdgeRemoveChange\n  | EdgeReplaceChange\n  | EdgeSelectionChange;\n```\n\n## Variants\n\n### EdgeAddChange\n\n<APIDocs typeName=\"EdgeAddChange\" />\n\n### EdgeRemoveChange\n\n<APIDocs typeName=\"EdgeRemoveChange\" />\n\n### EdgeReplaceChange\n\n<APIDocs typeName=\"EdgeReplaceChange\" />\n\n### EdgeSelectionChange\n\n<APIDocs typeName=\"EdgeSelectionChange\" />"
    },
    "api-reference/types/edge-marker": {
      "name": "api-reference/types/edge-marker",
      "title": "edge-marker",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# EdgeMarker\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L70-L78)\n\nEdges can optionally have markers at the start and end of an edge. The `EdgeMarker` type\nis used to configure those markers! Check the docs for\n[`MarkerType`](/api-reference/types/marker-type) for details on what types of edge marker\nare available.\n\n## Fields\n\n<APIDocs typeName=\"EdgeMarker\" />"
    },
    "api-reference/types/edge-mouse-handler": {
      "name": "api-reference/types/edge-mouse-handler",
      "title": "edge-mouse-handler",
      "description": "The EdgeMouseHandler type defines the callback function that is called when mouse events occur on an edge.",
      "category": "api-reference",
      "sections": [],
      "content": "# EdgeMouseHandler\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L81)\n\nThe `EdgeMouseHandler` type defines the callback function that is called when mouse events occur on an edge. This callback receives the event and the edge that triggered it.\n\n```ts\ntype EdgeMouseHandler = (event: React.MouseEvent, edge: Edge) => void;\n```\n\n<APIDocs typeName=\"EdgeMouseHandler\" packageName=\"react\" />"
    },
    "api-reference/types/edge-props": {
      "name": "api-reference/types/edge-props",
      "title": "edge-props",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# EdgeProps\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L100)\n\nWhen you implement a custom edge it is wrapped in a component that enables some basic\nfunctionality. The `EdgeProps` type takes a generic parameter to specify the type of edges\nyou use in your application:\n\n```ts\ntype AppEdgeProps = EdgeProps<MyEdgeType>;\n```\n\nYour custom edge component receives the following props:\n\n## Fields\n\n<APIDocs typeName=\"EdgeProps\" />"
    },
    "api-reference/types/edge-types": {
      "name": "api-reference/types/edge-types",
      "title": "edge-types",
      "description": "The EdgeTypes type is used to define custom edge types.",
      "category": "api-reference",
      "sections": [],
      "content": "# EdgeTypes\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L76)\n\nThe `EdgeTypes` type is used to define custom edge types. Each key in the object represents an edge type, and the value is the component that should be rendered for that type.\n\n```ts\nexport type EdgeTypes = {\n  [key: string]: React.ComponentType<EdgeProps>;\n};\n```"
    },
    "api-reference/types/edge": {
      "name": "api-reference/types/edge",
      "title": "edge",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Variants",
        "Edge",
        "SmoothStepEdge",
        "BezierEdge",
        "Default edge types"
      ],
      "content": "# Edge\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)\n\nWhere a [`Connection`](/api-reference/types/connection) is the minimal description of an edge between\ntwo nodes, an `Edge` is the complete description with everything React Flow needs\nto know in order to render it.\n\n```ts\nexport type Edge<T> = DefaultEdge<T> | SmoothStepEdge<T> | BezierEdge<T>;\n```\n\n## Variants\n\n### Edge\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)\n\n<APIDocs typeName=\"Edge\" />\n\n### SmoothStepEdge\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L45-L46)\n\nThe `SmoothStepEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:\n\n{/* type SmoothStepEdge isn't exported, and conflicts with SmoothStepEdge component name */}\n<APIDocs code={`\ntype $ = {\n  type: \"smoothstep\"\n  pathOptions?: { offset?: number; borderRadius?: number }\n}\nexport default $\n`} />\n\n### BezierEdge\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L52-L53)\n\nThe `BezierEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:\n\n{/* type BezierEdge isn't exported, and conflicts with BezierEdge component name */}\n<APIDocs code={`\ntype $ = {\n  type: \"default\"\n  pathOptions?: { curvature?: number }\n}\nexport default $\n`} />\n\n## Default edge types\n\nYou can create any of React Flow's default edges by setting the `type` property\nto one of the following values:\n\n- `\"default\"`\n- `\"straight\"`\n- `\"step\"`\n- `\"smoothstep\"`\n- `\"simplebezier\"`\n\nIf you don't set the `type` property at all, React Flow will fallback to the\n`\"default\"` bezier curve edge type.\n\nThese default edges are available even if you set the [`edgeTypes`](/api-reference/react-flow#edge-types)\nprop to something else, unless you override any of these keys directly."
    },
    "api-reference/types/fit-view-options": {
      "name": "api-reference/types/fit-view-options",
      "title": "fit-view-options",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# FitViewOptions\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts/#L67-L68)\n\nWhen calling [`fitView`](/api-reference/types/react-flow-instance#fitview) these options\ncan be used to customize the behavior. For example, the `duration` option can be used to\ntransform the viewport smoothly over a given amount of time.\n\n## Fields\n\n<APIDocs typeName=\"FitViewOptions\" />"
    },
    "api-reference/types/handle-connection": {
      "name": "api-reference/types/handle-connection",
      "title": "handle-connection",
      "description": "The HandleConnection type is a Connection that includes the edgeId.",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# HandleConnection\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)\n\nThe `HandleConnection` type is an extension of a basic\n[Connection](/api-reference/types/connection) that includes the `edgeId`.\n\n## Fields\n\n<APIDocs typeName=\"HandleConnection\" packageName=\"system\" />"
    },
    "api-reference/types/handle": {
      "name": "api-reference/types/handle",
      "title": "handle",
      "description": "Handle attributes like id, position, and type.",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# Handle\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/handles.ts/#L5)\n\nThe `Handle` type represents the attributes of a handle.\n\n## Fields\n\n<APIDocs typeName=\"Handle\" packageName=\"system\" />"
    },
    "api-reference/types": {
      "name": "api-reference/types",
      "title": "index",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "import { ApiReferenceSummary } from 'xy-shared/server';\n\n# Types\n\n<ApiReferenceSummary category=\"types\" />"
    },
    "api-reference/types/internal-node": {
      "name": "api-reference/types/internal-node",
      "title": "internal-node",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# InternalNode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/99985b52026cf4ac65a1033178cf8c2bea4e14fa/packages/system/src/types/nodes.ts#L68)\n\nThe `InternalNode` type is identical to the base [`Node`](/api-reference/types/node) type\nbut is extended with some additional properties used internally by React Flow. Some\nfunctions and callbacks that return nodes may return an `InternalNode`.\n\n## Fields\n\n<APIDocs typeName=\"InternalNodeBase\" packageName=\"system\" />"
    },
    "api-reference/types/is-valid-connection": {
      "name": "api-reference/types/is-valid-connection",
      "title": "is-valid-connection",
      "description": "Function type that determines whether a connection between nodes is valid.",
      "category": "api-reference",
      "sections": [],
      "content": "# IsValidConnection\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L212)\n\nThe `IsValidConnection` type represents a function that validates whether a connection between nodes is allowed. It receives a [`Connection`](/api-reference/types/connection) and returns a boolean indicating whether the connection is valid and therefore should be created.\n\n```ts\ntype IsValidConnection = (edge: Edge | Connection) => boolean;\n```\n\n<APIDocs typeName=\"IsValidConnection\" packageName=\"react\" />"
    },
    "api-reference/types/key-code": {
      "name": "api-reference/types/key-code",
      "title": "key-code",
      "description": "Represents keyboard key codes or combinations.",
      "category": "api-reference",
      "sections": [],
      "content": "# KeyCode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L155)\n\nThe `KeyCode` type is used to specify keyboard key codes or combinations, such as deleting nodes or enabling multi-selection. It can be a single string or an array of strings representing key codes.\n\n```ts\ntype KeyCode = string | Array<string>;\n```"
    },
    "api-reference/types/marker-type": {
      "name": "api-reference/types/marker-type",
      "title": "marker-type",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# MarkerType\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L82-L83)\n\nEdges may optionally have a marker on either end. The MarkerType type enumerates\nthe options available to you when configuring a given marker.\n\n```ts\nexport enum MarkerType {\n  Arrow = 'arrow',\n  ArrowClosed = 'arrowclosed',\n}\n```"
    },
    "api-reference/types/mini-map-node-props": {
      "name": "api-reference/types/mini-map-node-props",
      "title": "mini-map-node-props",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# MiniMapNodeProps\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/react/src/additional-components/MiniMap/types.ts/#L60)\n\nThe MiniMapNodeProps type defines the props for nodes in the MiniMap component. This is\nonly relevant if you pass a custom node type to the MiniMap.\n\n## Fields\n\n<APIDocs typeName=\"MiniMapNodeProps\" />\n```"
    },
    "api-reference/types/node-change": {
      "name": "api-reference/types/node-change",
      "title": "node-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Variant types",
        "NodeDimensionChange",
        "NodePositionChange",
        "NodeSelectionChange",
        "NodeRemoveChange",
        "NodeAddChange",
        "NodeReplaceChange"
      ],
      "content": "# NodeChange\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/system/src/types/changes.ts/#L47)\n\nThe [`onNodesChange`](/api-reference/react-flow#on-nodes-change) callback takes\nan array of `NodeChange` objects that you should use to update your flow's state.\nThe `NodeChange` type is a union of six different object types that represent that\nvarious ways an node can change in a flow.\n\n```ts\nexport type NodeChange =\n  | NodeDimensionChange\n  | NodePositionChange\n  | NodeSelectionChange\n  | NodeRemoveChange\n  | NodeAddChange\n  | NodeReplaceChange;\n```\n\n## Variant types\n\n### NodeDimensionChange\n\n<APIDocs typeName=\"NodeDimensionChange\" />\n\n### NodePositionChange\n\n<APIDocs typeName=\"NodePositionChange\" />\n\n### NodeSelectionChange\n\n<APIDocs typeName=\"NodeSelectionChange\" />\n\n### NodeRemoveChange\n\n<APIDocs typeName=\"NodeRemoveChange\" />\n\n### NodeAddChange\n\n<APIDocs typeName=\"NodeAddChange\" />\n\n### NodeReplaceChange\n\n<APIDocs typeName=\"NodeReplaceChange\" />"
    },
    "api-reference/types/node-connection": {
      "name": "api-reference/types/node-connection",
      "title": "node-connection",
      "description": "The NodeConnection type is a Connection that includes the edgeId.",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# NodeConnection\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)\n\nThe `NodeConnection` type is an extension of a basic\n[Connection](/api-reference/types/connection) that includes the `edgeId`.\n\n## Fields\n\n<APIDocs typeName=\"NodeConnection\" />"
    },
    "api-reference/types/node-handle": {
      "name": "api-reference/types/node-handle",
      "title": "node-handle",
      "description": "The NodeHandle type is used to define a handle for a node if server side rendering is used.",
      "category": "api-reference",
      "sections": [],
      "content": "# NodeHandle\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/13897512d3c57e72c2e27b14ffa129412289d948/packages/system/src/types/nodes.ts#L139)\n\nThe `NodeHandle` type is used to define a handle for a node if server-side rendering is used. On the server, React Flow can't measure DOM nodes, so it's necessary to define the handle position dimensions.\n\n<APIDocs typeName=\"NodeHandle\" packageName=\"system\" />"
    },
    "api-reference/types/node-mouse-handler": {
      "name": "api-reference/types/node-mouse-handler",
      "title": "node-mouse-handler",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# NodeMouseHandler\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts)\n\nThe `NodeMouseHandler` type defines the callback function that is called when mouse events\noccur on a node. This callback receives the event and the node that triggered it.\n\n```ts\nexport type NodeMouseHandler = (event: React.MouseEvent, node: Node) => void;\n```\n\n<APIDocs typeName=\"NodeMouseHandler\" packageName=\"react\" />"
    },
    "api-reference/types/node-origin": {
      "name": "api-reference/types/node-origin",
      "title": "node-origin",
      "description": "The origin of a Node determines how it is placed relative to its own coordinates.",
      "category": "api-reference",
      "sections": [],
      "content": "# NodeOrigin\n\nThe origin of a Node determines how it is placed relative to its own coordinates.\n`[0, 0]` places it at the top left corner, `[0.5, 0.5]` right in the center and `[1, 1]` at the bottom right of its position.\n\n```ts\nexport type NodeOrigin = [number, number];\n```"
    },
    "api-reference/types/node-props": {
      "name": "api-reference/types/node-props",
      "title": "NodeProps",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Usage",
        "Fields"
      ],
      "content": "# NodeProps\\<T>\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L89)\n\nWhen you implement a [custom node](/learn/customization/custom-nodes) it is wrapped in a\ncomponent that enables basic functionality like selection and dragging.\n\n## Usage\n\n```tsx\nimport { useState } from 'react';\nimport { NodeProps, Node } from '@xyflow/react';\n\nexport type CounterNode = Node<\n  {\n    initialCount?: number;\n  },\n  'counter'\n>;\n\nexport default function CounterNode(props: NodeProps<CounterNode>) {\n  const [count, setCount] = useState(props.data?.initialCount ?? 0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button className=\"nodrag\" onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n```\n\nRemember to register your custom node by adding it to the\n[`nodeTypes`](/api-reference/react-flow#nodetypes) prop of your `<ReactFlow />` component.\n\n```tsx\nimport { ReactFlow } from '@xyflow/react';\nimport CounterNode from './CounterNode';\n\nconst nodeTypes = {\n  counterNode: CounterNode,\n};\n\nexport default function App() {\n  return <ReactFlow nodeTypes={nodeTypes} ... />\n}\n```\n\nYou can read more in our [custom node guide](/learn/customization/custom-nodes).\n\n## Fields\n\nYour custom node receives the following props:\n\n<APIDocs typeName=\"NodeProps\" />"
    },
    "api-reference/types/node-types": {
      "name": "api-reference/types/node-types",
      "title": "node-types",
      "description": "The NodeTypes type is used to define custom node types.",
      "category": "api-reference",
      "sections": [],
      "content": "# NodeTypes\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts)\n\nThe `NodeTypes` type is used to define custom node types. Each key in the object represents a node type, and the value is the component that should be rendered for that type.\n\n```ts\ntype NodeTypes = {\n  [key: string]: React.ComponentType<NodeProps>;\n};\n```"
    },
    "api-reference/types/node": {
      "name": "api-reference/types/node",
      "title": "node",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Default node types",
        "Notes"
      ],
      "content": "# Node\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L10)\n\nThe `Node` type represents everything React Flow needs to know about a given node.\nMany of these properties can be manipulated both by React Flow or by you, but\nsome such as `width` and `height` should be considered read-only.\n\n## Fields\n\n<APIDocs typeName=\"Node\" packageName=\"react\" />\n\n## Default node types\n\nYou can create any of React Flow's default nodes by setting the `type` property\nto one of the following values:\n\n- `\"default\"`\n- `\"input\"`\n- `\"output\"`\n- `\"group\"`\n\nIf you don't set the `type` property at all, React Flow will fallback to the\n`\"default\"` node with both an input and output port.\n\nThese default nodes are available even if you set the [`nodeTypes`](/api-reference/react-flow#node-types)\nprop to something else, unless you override any of these keys directly.\n\n## Notes\n\n- You shouldn't try to set the `width` or `height` of a node directly. It is\n  calculated internally by React Flow and used when rendering the node in the\n  viewport. To control a node's size you should use the `style` or `className`\n  props to apply CSS styles instead."
    },
    "api-reference/types/on-before-delete": {
      "name": "api-reference/types/on-before-delete",
      "title": "on-before-delete",
      "description": "The OnBeforeDelete type defines the callback function that is called before nodes or edges are deleted.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnBeforeDelete\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L207)\n\nThe `OnBeforeDelete` type defines the callback function that is called before nodes or edges are deleted. This callback receives an object containing the nodes and edges that are about to be deleted.\n\n```ts\ntype OnBeforeDelete = (params: {\n  nodes: Node[];\n  edges: Edge[];\n}) => Promise<boolean | {\n  nodes: Node[];\n  edges: Edge[];\n})>;\n```\n\n<APIDocs typeName=\"OnBeforeDelete\" packageName=\"react\" />"
    },
    "api-reference/types/on-connect-end": {
      "name": "api-reference/types/on-connect-end",
      "title": "on-connect-end",
      "description": "Callback function triggered when finishing or canceling a connection attempt between nodes.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnConnectEnd\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L89)\n\nThe `OnConnectEnd` type represents a callback function that is called when finishing or canceling a connection attempt. It receives the mouse or touch event and the final state of the connection attempt.\n\n```ts\ntype OnConnectEnd = (\n  event: MouseEvent | TouchEvent,\n  connectionState: FinalConnectionState,\n) => void;\n```\n\n<APIDocs typeName=\"OnConnectEnd\" packageName=\"system\" />"
    },
    "api-reference/types/on-connect-start": {
      "name": "api-reference/types/on-connect-start",
      "title": "on-connect-start",
      "description": "Callback function triggered when starting to create a connection between nodes.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnConnectStart\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L79)\n\nThe `OnConnectStart` type represents a callback function that is called when starting to create a connection between nodes. It receives the mouse or touch event and information about the source node and handle.\n\n```ts\ntype OnConnectStart = (\n  event: MouseEvent | TouchEvent,\n  params: OnConnectStartParams,\n) => void;\n```\n\n<APIDocs typeName=\"OnConnectStart\" packageName=\"system\" />"
    },
    "api-reference/types/on-connect": {
      "name": "api-reference/types/on-connect",
      "title": "on-connect",
      "description": "Callback function triggered when a new connection is created between nodes.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnConnect\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L80)\n\nThe `OnConnect` type represents a callback function that is called when a new connection is created between nodes. It receives a [`Connection`](/api-reference/types/connection) containing the source and target node IDs and their respective handle IDs.\n\n```ts\ntype OnConnect = (connection: Connection) => void;\n```\n\n<APIDocs typeName=\"OnConnect\" packageName=\"system\" />"
    },
    "api-reference/types/on-delete": {
      "name": "api-reference/types/on-delete",
      "title": "on-delete",
      "description": "The OnDelete type defines the callback function that is called when nodes or edges are deleted.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnDelete\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L59)\n\nThe `OnDelete` type defines the callback function that is called when nodes or edges are deleted. This callback receives an object containing the deleted nodes and edges.\n\n```ts\ntype OnDelete = (params: { nodes: Node[]; edges: Edge[] }) => void;\n```\n\n<APIDocs typeName=\"OnDelete\" packageName=\"react\" />"
    },
    "api-reference/types/on-edges-change": {
      "name": "api-reference/types/on-edges-change",
      "title": "on-edges-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Usage"
      ],
      "content": "# OnEdgesChange\n\nThis type is used for typing the [`onEdgesChange`](/api-reference/react-flow#on-edges-change) function.\n\n```tsx\nexport type OnEdgesChange<EdgeType extends Edge = Edge> = (\n  changes: EdgeChange<EdgeType>[],\n) => void;\n```\n\n## Fields\n\n<APIDocs typeName=\"OnEdgesChange\" />\n\n## Usage\n\nThis type accepts a generic type argument of custom edge types. See this\n[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst onEdgesChange: OnEdgesChange = useCallback(\n  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),\n  [setEdges],\n);\n```"
    },
    "api-reference/types/on-edges-delete": {
      "name": "api-reference/types/on-edges-delete",
      "title": "on-edges-delete",
      "description": "The OnEdgesDelete type defines the callback function that is called when edges are deleted.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnEdgesDelete\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L52)\n\nThe `OnEdgesDelete` type defines the callback function that is called when edges are deleted. This callback receives an array of the deleted edges.\n\n```ts\ntype OnEdgesDelete = (edges: Edge[]) => void;\n```\n\n<APIDocs typeName=\"OnEdgesDelete\" packageName=\"react\" />"
    },
    "api-reference/types/on-error": {
      "name": "api-reference/types/on-error",
      "title": "on-error",
      "description": "The OnError type defines the callback function that is called when an error occurs.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnError\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L233)\n\nThe `OnError` type defines the callback function that is called when an error occurs. This callback receives an error id and the error message as its argument.\n\n```ts\ntype OnError = (id: string, error: string) => void;\n```\n\n<APIDocs typeName=\"OnError\" packageName=\"system\" />"
    },
    "api-reference/types/on-init": {
      "name": "api-reference/types/on-init",
      "title": "on-init",
      "description": "The OnInit type defines the callback function that is called when the ReactFlow instance is initialized.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnInit\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L113)\n\nThe `OnInit` type defines the callback function that is called when the ReactFlow instance is initialized. This callback receives the ReactFlow instance as its argument.\n\n```ts\ntype OnInit = (reactFlowInstance: ReactFlowInstance) => void;\n```\n\n<APIDocs typeName=\"OnInit\" packageName=\"react\" />"
    },
    "api-reference/types/on-move": {
      "name": "api-reference/types/on-move",
      "title": "on-move",
      "description": "Invoked when the viewport is moved, such as by panning or zooming.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnMove\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L16)\n\nThe `OnMove` type is a callback that fires whenever the viewport is moved, either by user interaction or programmatically. It receives the triggering event and the new viewport state.\n\n```ts\ntype OnMove = (event: MouseEvent | TouchEvent | null, viewport: Viewport) => void;\n```\n\n<APIDocs typeName=\"OnMove\" packageName=\"system\" />"
    },
    "api-reference/types/on-node-drag": {
      "name": "api-reference/types/on-node-drag",
      "title": "on-node-drag",
      "description": "The OnNodeDrag type defines the callback function that is called when a node is being dragged.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnNodeDrag\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L34)\n\nThe `OnNodeDrag` type defines the callback function that is called when a node is being dragged. This callback receives the event and the node that is being dragged.\n\n```ts\ntype OnNodeDrag = (event: React.MouseEvent, node: Node) => void;\n```\n\n<APIDocs typeName=\"OnNodeDrag\" packageName=\"react\" />"
    },
    "api-reference/types/on-nodes-change": {
      "name": "api-reference/types/on-nodes-change",
      "title": "on-nodes-change",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Usage"
      ],
      "content": "# OnNodesChange\n\nThis type is used for typing the [`onNodesChange`](/api-reference/react-flow#on-nodes-change) function.\n\n```tsx\nexport type OnNodesChange<NodeType extends Node = Node> = (\n  changes: NodeChange<NodeType>[],\n) => void;\n```\n\n## Fields\n\n<APIDocs typeName=\"OnNodesChange\" />\n\n## Usage\n\nThis type accepts a generic type argument of custom nodes types. See this\n[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.\n\n```tsx\nconst onNodesChange: OnNodesChange = useCallback(\n  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),\n  [setNodes],\n);\n```"
    },
    "api-reference/types/on-nodes-delete": {
      "name": "api-reference/types/on-nodes-delete",
      "title": "on-nodes-delete",
      "description": "The OnNodesDelete type defines the callback function that is called when nodes are deleted.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnNodesDelete\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L51)\n\nThe `OnNodesDelete` type defines the callback function that is called when nodes are deleted. This callback receives an array of the deleted nodes.\n\n```ts\ntype OnNodesDelete = (nodes: Node[]) => void;\n```\n\n<APIDocs typeName=\"OnNodesDelete\" packageName=\"react\" />"
    },
    "api-reference/types/on-reconnect": {
      "name": "api-reference/types/on-reconnect",
      "title": "on-reconnect",
      "description": "Callback function triggered when an existing edge is reconnected to a different node or handle.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnReconnect\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L83)\n\nThe `OnReconnect` type represents a callback function that is called when an existing edge is reconnected to a different node or handle. It receives the old edge and the new connection details.\n\n```ts\ntype OnReconnect<EdgeType extends EdgeBase = EdgeBase> = (\n  oldEdge: EdgeType,\n  newConnection: Connection,\n) => void;\n```\n\n<APIDocs typeName=\"OnReconnect\" packageName=\"react\" />"
    },
    "api-reference/types/on-selection-change-func": {
      "name": "api-reference/types/on-selection-change-func",
      "title": "on-selection-change-func",
      "description": "Called whenever the selection of nodes or edges changes in the flow diagram.",
      "category": "api-reference",
      "sections": [],
      "content": "# OnSelectionChangeFunc\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#98)\n\nThe `OnSelectionChangeFunc` type is a callback that is triggered when the selection of nodes or edges changes. It receives an object containing the currently selected nodes and edges.\n\n```ts\ntype OnSelectionChangeFunc = (params: { nodes: Node[]; edges: Edge[] }) => void;\n```\n\n<APIDocs typeName=\"OnSelectionChangeFunc\" packageName=\"react\" />"
    },
    "api-reference/types/pan-on-scroll-mode": {
      "name": "api-reference/types/pan-on-scroll-mode",
      "title": "pan-on-scroll-mode",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# PanOnScrollMode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L166)\n\nThe `PanOnScrollMode` enum controls the panning behavior of the viewport when the user\nscrolls. Choose `Free` for unrestricted panning, `Vertical` for up-and-down only, or\n`Horizontal` for left-and-right only.\n\n```ts\nenum PanOnScrollMode {\n  Free = 'free',\n  Vertical = 'vertical',\n  Horizontal = 'horizontal',\n}\n```"
    },
    "api-reference/types/panel-position": {
      "name": "api-reference/types/panel-position",
      "title": "panel-position",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# PanelPosition\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L111-L112)\n\nThis type is mostly used to help position things on top of the flow viewport. For\nexample both the [`<MiniMap />`](/api-reference/components/minimap) and\n[`<Controls />`](/api-reference/components/controls) components take a `position`\nprop of this type.\n\n```ts\nexport type PanelPosition =\n  | 'top-left'\n  | 'top-center'\n  | 'top-right'\n  | 'bottom-left'\n  | 'bottom-center'\n  | 'bottom-right'\n  | 'center-left'\n  | 'center-right';\n```"
    },
    "api-reference/types/position": {
      "name": "api-reference/types/position",
      "title": "position",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# Position\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L1)\n\nWhile [`PanelPosition`](/api-reference/types/panel-position) can be used to place a component in the\ncorners of a container, the `Position` enum is less precise and used primarily\nin relation to edges and handles.\n\n```ts\nexport enum Position {\n  Left = 'left',\n  Top = 'top',\n  Right = 'right',\n  Bottom = 'bottom',\n}\n```"
    },
    "api-reference/types/pro-options": {
      "name": "api-reference/types/pro-options",
      "title": "pro-options",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# ProOptions\n\nBy default, we render a small attribution in the corner of your flows that links back to\nthe project. Anyone is free to remove this attribution whether they're a Pro subscriber or\nnot but we ask that you take a quick look at our\n[removing attribution](/learn/troubleshooting/remove-attribution) guide before doing so.\n\n<APIDocs typeName=\"ProOptions\" />"
    },
    "api-reference/types/react-flow-instance": {
      "name": "api-reference/types/react-flow-instance",
      "title": "react-flow-instance",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Nodes and edges",
        "Intersections",
        "Viewport"
      ],
      "content": "import {\n  NodesAndEdgesFields,\n  IntersectionFields,\n  ViewportFields,\n} from '@/references/react-flow-instance';\n\n# ReactFlowInstance\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L178-L179)\n\nThe `ReactFlowInstance` provides a collection of methods to query and manipulate the\ninternal state of your flow. You can get an instance by using the\n[`useReactFlow`](/api-reference/hooks/use-react-flow) hook or attaching a listener to the\n[`onInit`](/api-reference/react-flow#event-oninit) event.\n\n## Fields\n\n### Nodes and edges\n\n<NodesAndEdgesFields />\n\n### Intersections\n\n<IntersectionFields />\n\n### Viewport\n\n<ViewportFields />"
    },
    "api-reference/types/react-flow-json-object": {
      "name": "api-reference/types/react-flow-json-object",
      "title": "react-flow-json-object",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# ReactFlowJsonObject\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L5)\n\nA JSON-compatible representation of your flow. You can use this to save the flow to a\ndatabase for example and load it back in later.\n\n## Fields\n\n<APIDocs typeName=\"ReactFlowJsonObject\" />"
    },
    "api-reference/types/rect": {
      "name": "api-reference/types/rect",
      "title": "rect",
      "description": "The Rect type defines a rectangle with dimensions and a position.",
      "category": "api-reference",
      "sections": [],
      "content": "# Rect\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/f0ce2c876d8688e13632bc86286cf857f86dead6/packages/system/src/types/utils.ts/#L39-L40)\n\nThe `Rect` type defines a rectangle in a two-dimensional space with dimensions and a\nposition.\n\n<APIDocs typeName=\"Rect\" />"
    },
    "api-reference/types/resize-params": {
      "name": "api-reference/types/resize-params",
      "title": "resize-params",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields"
      ],
      "content": "# ResizeParams\n\n[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/node-resizer/src/types.ts/#L4)\n\nThe `ResizeParams` type is used to type the various events that are emitted by the\n`<NodeResizer />` component. You'll sometimes see this type extended with an additional\ndirection field too.\n\n## Fields\n\n<APIDocs typeName=\"ResizeParams\" />"
    },
    "api-reference/types/selection-drag-handler": {
      "name": "api-reference/types/selection-drag-handler",
      "title": "selection-drag-handler",
      "description": "Handles drag events for selected nodes during interactive operations.",
      "category": "api-reference",
      "sections": [],
      "content": "# SelectionDragHandler\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L33)\n\nThe `SelectionDragHandler` type is a callback for handling drag events involving selected nodes. It receives the triggering mouse or touch event and an array of the affected nodes.\n\n```ts\ntype SelectionDragHandler<NodeType extends Node = Node> = (\n  event: ReactMouseEvent,\n  nodes: NodeType[],\n) => void;\n```\n\n<APIDocs typeName=\"SelectionDragHandler\" packageName=\"react\" />"
    },
    "api-reference/types/selection-mode": {
      "name": "api-reference/types/selection-mode",
      "title": "selection-mode",
      "description": "Controls how nodes are selected in the flow diagram, offering either full or partial selection behavior.",
      "category": "api-reference",
      "sections": [],
      "content": "# SelectionMode\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L223)\n\nThe `SelectionMode` enum provides two options for node selection behavior:\n\n- `Full`: A node is only selected when the selection rectangle fully contains it\n- `Partial`: A node is selected when the selection rectangle partially overlaps with it\n\n```ts\nenum SelectionMode {\n  Partial = 'partial',\n  Full = 'full',\n}\n```"
    },
    "api-reference/types/snap-grid": {
      "name": "api-reference/types/snap-grid",
      "title": "snap-grid",
      "description": "The SnapGrid type defines the grid size for snapping nodes on the pane.",
      "category": "api-reference",
      "sections": [],
      "content": "# SnapGrid\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L157)\n\nThe `SnapGrid` type defines the grid size for snapping nodes on the pane. It is used in conjunction with the `snapToGrid` prop to enable grid snapping functionality.\n\n```ts\ntype SnapGrid = [number, number];\n```"
    },
    "api-reference/types/viewport": {
      "name": "api-reference/types/viewport",
      "title": "viewport",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Fields",
        "Notes"
      ],
      "content": "# Viewport\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L149-L153)\n\nInternally, React Flow maintains a coordinate system that is independent of the rest of\nthe page. The `Viewport` type tells you where in that system your flow is currently being\ndisplay at and how zoomed in or out it is.\n\n## Fields\n\n<APIDocs typeName=\"Viewport\" />\n\n## Notes\n\n- A `Transform` has the same properties as the viewport, but they represent different\n  things. Make sure you don't get them muddled up or things will start to look weird!"
    },
    "api-reference/types/xy-position": {
      "name": "api-reference/types/xy-position",
      "title": "xy-position",
      "description": "All positions are stored in an object with x and y coordinates.",
      "category": "api-reference",
      "sections": [],
      "content": "# XYPosition\n\nAll positions are stored in an object with x and y coordinates.\n\n```ts\nexport type XYPosition = {\n  x: number;\n  y: number;\n};\n```"
    },
    "api-reference/types/z-index-mode": {
      "name": "api-reference/types/z-index-mode",
      "title": "z-index-mode",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "# ZIndexMode\n\nThe ZIndexMode type is used to define how z-indexing is calculated for nodes and edges.\n\n- `auto` mode will automatically manage z-indexing for selections and sub flows.\n- `basic` mode will only manage z-indexing for selections.\n- `manual` mode does not apply any automatic z-indexing.\n\n```ts\nexport type ZIndexMode = 'auto' | 'basic' | 'manual';\n```"
    },
    "api-reference/utils/add-edge": {
      "name": "api-reference/utils/add-edge",
      "title": "add-edge",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# addEdge()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/general.ts/#L100)\n\nThis util is a convenience function to add a new [`Edge`](/api-reference/types/edge) to an\narray of edges. It also performs some validation to make sure you don't add an\ninvalid edge or duplicate an existing one.\n\n```js\nimport { useCallback } from 'react';\nimport {\n  ReactFlow,\n  addEdge,\n  useNodesState,\n  useEdgesState,\n} from '@xyflow/react';\n\nexport default function Flow() {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const onConnect = useCallback(\n    (connection) => {\n      setEdges((oldEdges) => addEdge(connection, oldEdges));\n    },\n    [setEdges],\n  );\n\n  return <ReactFlow nodes={nodes} edges={edges} onConnect={onConnect} />;\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"addEdge\" />\n\n## Notes\n\n- If an edge with the same `target` and `source` already exists (and the same\n  `targetHandle` and `sourceHandle` if those are set), then this util won't add\n  a new edge even if the `id` property is different."
    },
    "api-reference/utils/apply-edge-changes": {
      "name": "api-reference/utils/apply-edge-changes",
      "title": "apply-edge-changes",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# applyEdgeChanges()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L167)\n\nVarious events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce an\n[`EdgeChange`](/api-reference/types/edge-change) that describes how to update the edges of your\nflow in some way. If you don't need any custom behavior, this util can be used to\ntake an array of these changes and apply them to your edges.\n\n```js\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n\nexport default function Flow() {\n  const [nodes, setNodes] = useState([]);\n  const [edges, setEdges] = useState([]);\n  const onEdgesChange = useCallback(\n    (changes) => {\n      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n    },\n    [setEdges],\n  );\n\n  return (\n    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"applyEdgeChanges\" />\n\n## Notes\n\n- If you don't need any custom behavior, the [`useEdgesState`](/api-reference/hooks/use-edges-state)\n  hook conveniently wraps this util and React's `useState` hook for you and might\n  be simpler to use."
    },
    "api-reference/utils/apply-node-changes": {
      "name": "api-reference/utils/apply-node-changes",
      "title": "apply-node-changes",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# applyNodeChanges()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L140)\n\nVarious events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce a\n[`NodeChange`](/api-reference/types/node-change) that describes how to update the nodes of your\nflow in some way. If you don't need any custom behavior, this util can be used to\ntake an array of these changes and apply them to your nodes.\n\n```js\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, applyNodeChanges } from '@xyflow/react';\n\nexport default function Flow() {\n  const [nodes, setNodes] = useState([]);\n  const [edges, setEdges] = useState([]);\n  const onNodesChange = useCallback(\n    (changes) => {\n      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n    },\n    [setNodes],\n  );\n\n  return (\n    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n  );\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"applyNodeChanges\" />\n\n## Notes\n\n- If you don't need any custom behavior, the [`useNodesState`](/api-reference/hooks/use-nodes-state)\n  hook conveniently wraps this util and React's `useState` hook for you and might\n  be simpler to use."
    },
    "api-reference/utils/get-bezier-path": {
      "name": "api-reference/utils/get-bezier-path",
      "title": "get-bezier-path",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# getBezierPath()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/bezier-edge.ts/#L95)\n\nThe `getBezierPath` util returns everything you need to render a bezier edge\nbetween two nodes.\n\n```js\nimport { Position, getBezierPath } from '@xyflow/react';\n\nconst source = { x: 0, y: 20 };\nconst target = { x: 150, y: 100 };\n\nconst [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n  sourceX: source.x,\n  sourceY: source.y,\n  sourcePosition: Position.Right,\n  targetX: target.x,\n  targetY: target.y,\n  targetPosition: Position.Left,\n});\n\nconsole.log(path); //=> \"M0,20 C75,20 75,100 150,100\"\nconsole.log(labelX, labelY); //=> 75, 60\nconsole.log(offsetX, offsetY); //=> 75, 40\n```\n\n## Signature\n\n<APIDocs functionName=\"getBezierPath\" />\n\n## Notes\n\n- This function returns a tuple (aka a fixed-size array) to make it easier to\n  work with multiple edge paths at once."
    },
    "api-reference/utils/get-connected-edges": {
      "name": "api-reference/utils/get-connected-edges",
      "title": "get-connected-edges",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# getConnectedEdges()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L224)\n\nThis utility filters an array of edges, keeping only those where either the source or target node is present in the given array of nodes.\n\n```js\nimport { getConnectedEdges } from '@xyflow/react';\n\nconst nodes = [\n  { id: 'a', position: { x: 0, y: 0 } },\n  { id: 'b', position: { x: 100, y: 0 } },\n];\nconst edges = [\n  { id: 'a->c', source: 'a', target: 'c' },\n  { id: 'c->d', source: 'c', target: 'd' },\n];\n\nconst connectedEdges = getConnectedEdges(nodes, edges);\n// => [{ id: 'a->c', source: 'a', target: 'c' }]\n```\n\n## Signature\n\n<APIDocs functionName=\"getConnectedEdges\" />"
    },
    "api-reference/utils/get-incomers": {
      "name": "api-reference/utils/get-incomers",
      "title": "get-incomers",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# getIncomers()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L91)\n\nThis util is used to tell you what nodes, if any, are connected to the given node\nas the _source_ of an edge.\n\n```ts\nimport { getIncomers } from '@xyflow/react';\n\nconst nodes = [];\nconst edges = [];\n\nconst incomers = getIncomers(\n  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n  nodes,\n  edges,\n);\n```\n\n## Signature\n\n<APIDocs functionName=\"getIncomers\" />"
    },
    "api-reference/utils/get-nodes-bounds": {
      "name": "api-reference/utils/get-nodes-bounds",
      "title": "get-nodes-bounds",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# getNodesBounds()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L133)\n\nReturns the bounding box that contains all the given nodes in an array. This can\nbe useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\nto calculate the correct transform to fit the given nodes in a viewport.\n\n> [!NOTE]\n>\n> This function was previously called `getRectOfNodes`\n\n```js\nimport { getNodesBounds } from '@xyflow/react';\n\nconst nodes = [\n  {\n    id: 'a',\n    position: { x: 0, y: 0 },\n    data: { label: 'a' },\n    width: 50,\n    height: 25,\n  },\n  {\n    id: 'b',\n    position: { x: 100, y: 100 },\n    data: { label: 'b' },\n    width: 50,\n    height: 25,\n  },\n];\n\nconst bounds = getNodesBounds(nodes);\n```\n\n## Signature\n\n<APIDocs functionName=\"getNodesBounds\" />"
    },
    "api-reference/utils/get-outgoers": {
      "name": "api-reference/utils/get-outgoers",
      "title": "get-outgoers",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# getOutgoers()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L64)\n\nThis util is used to tell you what nodes, if any, are connected to the given node\nas the _target_ of an edge.\n\n```ts\nimport { getOutgoers } from '@xyflow/react';\n\nconst nodes = [];\nconst edges = [];\n\nconst outgoers = getOutgoers(\n  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n  nodes,\n  edges,\n);\n```\n\n## Signature\n\n<APIDocs functionName=\"getOutgoers\" />"
    },
    "api-reference/utils/get-simple-bezier-path": {
      "name": "api-reference/utils/get-simple-bezier-path",
      "title": "get-simple-bezier-path",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# getSimpleBezierPath()\n\n[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/SimpleBezierEdge.tsx/#L32)\n\nThe `getSimpleBezierPath` util returns everything you need to render a simple\nbezier edge between two nodes.\n\n```js\nimport { Position, getSimpleBezierPath } from '@xyflow/react';\n\nconst source = { x: 0, y: 20 };\nconst target = { x: 150, y: 100 };\n\nconst [path, labelX, labelY, offsetX, offsetY] = getSimpleBezierPath({\n  sourceX: source.x,\n  sourceY: source.y,\n  sourcePosition: Position.Right,\n  targetX: target.x,\n  targetY: target.y,\n  targetPosition: Position.Left,\n});\n\nconsole.log(path); //=> \"M0,20 C75,20 75,100 150,100\"\nconsole.log(labelX, labelY); //=> 75, 60\nconsole.log(offsetX, offsetY); //=> 75, 40\n```\n\n## Signature\n\n<APIDocs functionName=\"getSimpleBezierPath\" />\n\n## Notes\n\n- This function returns a tuple (aka a fixed-size array) to make it easier to\n  work with multiple edge paths at once."
    },
    "api-reference/utils/get-smooth-step-path": {
      "name": "api-reference/utils/get-smooth-step-path",
      "title": "get-smooth-step-path",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# getSmoothStepPath()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/smoothstep-edge.ts/#L215)\n\nThe `getSmoothStepPath` util returns everything you need to render a stepped path\nbetween two nodes. The `borderRadius` property can be used to choose how rounded\nthe corners of those steps are.\n\n```js\nimport { Position, getSmoothStepPath } from '@xyflow/react';\n\nconst source = { x: 0, y: 20 };\nconst target = { x: 150, y: 100 };\n\nconst [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n  sourceX: source.x,\n  sourceY: source.y,\n  sourcePosition: Position.Right,\n  targetX: target.x,\n  targetY: target.y,\n  targetPosition: Position.Left,\n});\n\nconsole.log(path); //=> \"M0 20L20 20L 70,20Q 75,20 75,25L 75,95Q ...\"\nconsole.log(labelX, labelY); //=> 75, 60\nconsole.log(offsetX, offsetY); //=> 75, 40\n```\n\n## Signature\n\n<APIDocs functionName=\"getSmoothStepPath\" />\n\n## Notes\n\n- This function returns a tuple (aka a fixed-size array) to make it easier to\n  work with multiple edge paths at once.\n- You can set the `borderRadius` property to `0` to get a step edge path."
    },
    "api-reference/utils/get-straight-path": {
      "name": "api-reference/utils/get-straight-path",
      "title": "get-straight-path",
      "description": "Calculates the straight line path between two points.",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "# getStraightPath()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/straight-edge.ts/#L30)\n\nCalculates the straight line path between two points.\n\n```js\nimport { getStraightPath } from '@xyflow/react';\n\nconst source = { x: 0, y: 20 };\nconst target = { x: 150, y: 100 };\n\nconst [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n  sourceX: source.x,\n  sourceY: source.y,\n  targetX: target.x,\n  targetY: target.y,\n});\n\nconsole.log(path); //=> \"M 0,20L 150,100\"\nconsole.log(labelX, labelY); //=> 75, 60\nconsole.log(offsetX, offsetY); //=> 75, 40\n```\n\n## Signature\n\n<APIDocs functionName=\"getStraightPath\" />\n\n## Notes\n\n- This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once."
    },
    "api-reference/utils/get-viewport-for-bounds": {
      "name": "api-reference/utils/get-viewport-for-bounds",
      "title": "get-viewport-for-bounds",
      "description": "'This util returns the viewport for the given bounds.",
      "category": "api-reference",
      "sections": [
        "Signature",
        "Notes"
      ],
      "content": "import { Callout } from 'nextra/components';\n\n# getViewportForBounds()\n\n[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/general.ts/#L170)\n\nThis util returns the viewport for the given bounds.\nYou might use this to pre-calculate the viewport for a given set of nodes on the\nserver or calculate the viewport for the given bounds _without_ changing the\nviewport directly.\n\n> [!NOTE]\n>\n> This function was previously called `getTransformForBounds`\n\n```js\nimport { getViewportForBounds } from '@xyflow/react';\n\nconst { x, y, zoom } = getViewportForBounds(\n  {\n    x: 0,\n    y: 0,\n    width: 100,\n    height: 100,\n  },\n  1200,\n  800,\n  0.5,\n  2,\n);\n```\n\n## Signature\n\n<APIDocs functionName=\"getViewportForBounds\" />\n\n## Notes\n\n- This is quite a low-level utility. You might want to look at the\n  [`fitView`](/api-reference/types/react-flow-instance#fitview) or\n  [`fitBounds`](/api-reference/types/react-flow-instance#fitbounds) methods for a more practical\n  api."
    },
    "api-reference/utils": {
      "name": "api-reference/utils",
      "title": "index",
      "description": "",
      "category": "api-reference",
      "sections": [],
      "content": "import { ApiReferenceSummary } from 'xy-shared/server';\n\n# Utils\n\n<ApiReferenceSummary category=\"utils\" />"
    },
    "api-reference/utils/is-edge": {
      "name": "api-reference/utils/is-edge",
      "title": "is-edge",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# isEdge()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L39-L40)\n\nTest whether an object is usable as an [`Edge`](/api-reference/types/edge). In TypeScript\nthis is a type guard that will narrow the type of whatever you pass in to\n[`Edge`](/api-reference/types/edge) if it returns `true`.\n\n```js\nimport { isEdge } from '@xyflow/react';\n\nconst edge = {\n  id: 'edge-a',\n  source: 'a',\n  target: 'b',\n};\n\nif (isEdge(edge)) {\n  // ...\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"isEdge\" />"
    },
    "api-reference/utils/is-node": {
      "name": "api-reference/utils/is-node",
      "title": "is-node",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# isNode()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L49)\n\nTest whether an object is usable as a [`Node`](/api-reference/types/node). In TypeScript\nthis is a type guard that will narrow the type of whatever you pass in to\n[`Node`](/api-reference/types/node) if it returns `true`.\n\n```js\nimport { isNode } from '@xyflow/react';\n\nconst node = {\n  id: 'node-a',\n  data: {\n    label: 'node',\n  },\n  position: {\n    x: 0,\n    y: 0,\n  },\n};\n\nif (isNode(node)) {\n  // ..\n}\n```\n\n## Signature\n\n<APIDocs functionName=\"isNode\" />"
    },
    "api-reference/utils/reconnect-edge": {
      "name": "api-reference/utils/reconnect-edge",
      "title": "reconnect-edge",
      "description": "",
      "category": "api-reference",
      "sections": [
        "Signature"
      ],
      "content": "# reconnectEdge()\n\n[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/general.ts)\n\nA handy utility to update an existing [`Edge`](/api-reference/types/edge) with new\nproperties. This searches your edge array for an edge with a matching `id` and updates its\nproperties with the connection you provide.\n\n```js\nconst onReconnect = useCallback(\n  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),\n  []\n);\n```\n\n## Signature\n\n<APIDocs functionName=\"reconnectEdge\" />"
    },
    "learn": {
      "name": "learn",
      "title": "index",
      "description": "",
      "category": "learn",
      "sections": [
        "Installation",
        "Usage",
        "Result",
        "Next steps"
      ],
      "content": "import { Emoji } from '@xyflow/xy-ui';\nimport { Callout, Cards, Steps } from 'nextra/components';\nimport { LiteYouTubeEmbed } from 'xy-shared';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Quick Start\n\nThis page will take you from zero to a working React Flow app in a few minutes. If you\njust want to have a look around and get an impression of React Flow, check out our\ninteractive no-code [Playground](https://play.reactflow.dev/).\n\n## Installation\n\nFirst, spin up a new React project however you like -- we recommend using\n[Vite](https://vitejs.dev/)\n\n```bash copy npm2yarn\nnpm init vite my-react-flow-app -- --template react\n```\n\nNext `cd` into your new project folder and add\n[`@xyflow/react`](https://npmjs.com/package/@xyflow/react) as a dependency\n\n```bash copy npm2yarn\nnpm install @xyflow/react\n```\n\nLastly, spin up the dev server and you're good to go!\n\n## Usage\n\nWe will render the [`<ReactFlow />`](/api-reference/react-flow) component from the\n`@xyflow/react` package. That and defining a handful of [node](/api-reference/types/node)\nobjects, [edge](/api-reference/types/edge) objects and\n[event handlers](/api-reference/react-flow#event-handlers) are all we need to get\nsomething going! Get rid of everything inside `App.jsx` and add the following:\n\n```jsx \"import '@xyflow/react/dist/style.css';\" \"width: '100vw', height: '100vh'\"\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, applyNodeChanges, applyEdgeChanges, addEdge } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nconst initialNodes = [\n  { id: 'n1', position: { x: 0, y: 0 }, data: { label: 'Node 1' } },\n  { id: 'n2', position: { x: 0, y: 100 }, data: { label: 'Node 2' } },\n];\nconst initialEdges = [{ id: 'n1-n2', source: 'n1', target: 'n2' }];\n\nexport default function App() {\n  const [nodes, setNodes] = useState(initialNodes);\n  const [edges, setEdges] = useState(initialEdges);\n\n  const onNodesChange = useCallback(\n    (changes) => setNodes((nodesSnapshot) => applyNodeChanges(changes, nodesSnapshot)),\n    [],\n  );\n  const onEdgesChange = useCallback(\n    (changes) => setEdges((edgesSnapshot) => applyEdgeChanges(changes, edgesSnapshot)),\n    [],\n  );\n  const onConnect = useCallback(\n    (params) => setEdges((edgesSnapshot) => addEdge(params, edgesSnapshot)),\n    [],\n  );\n\n  return (\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n        fitView\n      />\n    </div>\n  );\n}\n```\n\nThere are two things to pay attention to here:\n\n- <Emoji content=\"🎨\" /> You must import the css stylesheet for React Flow to work.\n- <Emoji content=\"📐\" /> The `<ReactFlow />` component must have a parent element with a\n  width and height.\n\n## Result\n\nEt voila. You've already created your first interactive flow! <Emoji content=\"🎉\" />\n\n<RemoteCodeViewer route=\"learn/quickstart\" framework=\"react\" />\n\n## Next steps\n\n<Cards>\n  <Cards.Card title=\"Core Concepts\" href=\"/learn/concepts/terms-and-definitions\" />\n  <Cards.Card title=\"Customization\" href=\"/learn/customization/custom-nodes\" />\n  <Cards.Card title=\"Examples\" href=\"/examples\" />\n  <Cards.Card title=\"API Reference\" href=\"/api-reference\" />\n  <Cards.Card title=\"Discord\" href=\"https://discord.gg/RVmnytFmGW\" />\n  <Cards.Card\n    title=\"Template Projects\"\n    href=\"https://github.com/xyflow/react-flow-example-apps\"\n  />\n</Cards>"
    },
    "learn/advanced-use/accessibility": {
      "name": "learn/advanced-use/accessibility",
      "title": "accessibility",
      "description": "React Flow is designed to be both keyboard and screen reader accessible.",
      "category": "learn",
      "sections": [
        "Built-in features",
        "ARIA roles for nodes and edges",
        "DOM attributes",
        "Localizing accessibility messages",
        "WCAG 2.1 AA"
      ],
      "content": "import { Callout } from 'nextra/components';\n\n# Accessibility\n\n<Callout type=\"info\">\n\nIf you have suggestions for how we can improve the accessibility of React Flow, please feel free to [contact us](https://xyflow.com/contact).\n\n</Callout>\n\nReact Flow provides keyboard and screen-reader support to help meet accessibility standards. By default, all nodes and edges are keyboard-focusable and operable. You can enable or disable these features with props including: [nodesFocusable](/api-reference/react-flow#nodesfocusable), [edgesFocusable](/api-reference/react-flow#edgesfocusable), and [disableKeyboardA11y](/api-reference/react-flow#disablekeyboarda11y) which are passed through `<ReactFlow />` like this:\n\n```js\n<ReactFlow\n  nodesFocusable={true}\n  edgesFocusable={true}\n  disableKeyboardA11y={false}\n  nodes={nodes}\n  edges={edges}\n>\n  {/* ...other components like Controls, MiniMap... */}\n</ReactFlow>\n```\n\n## Built-in features\n\n- **Tab navigation:** Pressing `Tab` moves focus through all focusable nodes and edges. These elements receive `tabIndex={0}` and, by default, `role=\"group\"` to handle interactivity.\n- **Select/Deselect:** Press `Enter` or `Space` to select the focused node/edge, and `Escape` to clear the selection.\n- **Move nodes with arrow keys:** If `nodesDraggable` and `nodesFocusable` are both true (default), you can move the selected node with the arrow keys. You can hold `Shift` to increase movement speed. If you set `disableKeyboardA11y={true}`, arrow-key movement is disabled (but tab-focus and selection still work).\n- **Automatic panning:** When a node receives focus, React Flow automatically pans the canvas to bring that node into view. This ensures focused nodes are visible to the user. This behavior can be toggled via the [autoPanOnNodeFocus](/api-reference/react-flow#autopanonnodefocus) prop.\n- **ARIA descriptions:** React Flow automatically adds ARIA descriptions for keyboard guidance. These can be configured by using [ariaLabelConfig](/api-reference/react-flow#arialabelconfig).\n\n<Callout type=\"info\">\n  To enable full keyboard accessibility, ensure both `nodesFocusable` and `edgesFocusable`\n  are set to `true`. If either is false, corresponding elements will not be\n  keyboard-focusable.\n</Callout>\n## ARIA roles for nodes and edges\n\nBy default, React Flow uses semantic ARIA roles for interactive elements. You can override a node’s role using the `ariaRole` prop. For example:\n\n```js\nconst nodes = [\n  {\n    id: '1',\n    data: { label: 'Hello' },\n    ariaRole: 'button',\n  },\n];\n<ReactFlow nodes={nodes} edges={[]} />;\n```\n\nBy, default, if you don’t set a role, `role=\"group\"` is applied. Customizing `ariaRole` lets you match any relevant ARIA role (e.g. `\"listitem\"`, `\"region\"`, etc.), improving semantic information for assistive technology.\n\n**Note:** The `ariaRole` is applied to the node wrapper. If a custom node includes interactive elements, avoid setting `ariaRole: 'button'` on the node itself. Instead, apply the appropriate ARIA role directly to the interactive element.\n\n### DOM attributes\n\nTo pass custom ARIA attributes or other DOM-level attributes (e.g., `aria-roledescription`, `data-\\*`,`tabIndex`, etc.), you can use the `domAttributes` prop. This is available for both nodes and edges:\n\n```\n// Example for a node\n{\n  id: '2',\n  data: { label: 'Accessible Node' },\n  domAttributes: {\n    'aria-roledescription': 'collapsible node',\n    tabIndex: 0,\n    'data-test-id': 'node-2',\n  },\n}\n\n```\n\nThis gives you full control over accessibility-related attributes while maintaining React Flow’s built-in roles and behaviors.\n\n## Localizing accessibility messages\n\nReact Flow’s built-in accessibility text (such as keyboard instructions and live updates) can be customized or localized via the [ariaLabelConfig](/api-reference/react-flow#arialabelconfig) prop on`<ReactFlow>`. This prop takes an object mapping message keys to strings or functions. Keys include:\n\n| Key                                     | Default Value                                                                                                                                   |\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| `node.a11yDescription.default`          | Press enter or space to select a node. Press delete to remove it and escape to cancel.                                                          |\n| `node.a11yDescription.keyboardDisabled` | Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel. |\n| `node.a11yDescription.ariaLiveMessage`  | `Moved selected node {direction}. New position, x: {x}, y: {y}`                                                                                 |\n| `edge.a11yDescription.default`          | Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.                                             |\n| `controls.ariaLabel`                    | Control Panel                                                                                                                                   |\n| `controls.zoomIn.ariaLabel`             | Zoom In                                                                                                                                         |\n| `controls.zoomOut.ariaLabel`            | Zoom Out                                                                                                                                        |\n| `controls.fitView.ariaLabel`            | Fit View                                                                                                                                        |\n| `controls.interactive.ariaLabel`        | Toggle Interactivity                                                                                                                            |\n| `minimap.ariaLabel`                     | Mini Map                                                                                                                                        |\n| `handle.ariaLabel`                      | Handle                                                                                                                                          |\n\nFor example, to provide custom or localized text:\n\n```js\nconst ariaLabels = {\n  'node.a11yDescription.default': 'Press [Enter] to select this node',\n  'node.a11yDescription.keyboardDisabled': 'Keyboard navigation is disabled',\n};\n<ReactFlow nodes={nodes} edges={edges} ariaLabelConfig={ariaLabels}>\n  <MiniMap />\n  <Controls />\n</ReactFlow>;\n```\n\nThis tells React Flow to use your text instead of the defaults. By supplying localized strings via [ariaLabelConfig](/api-reference/react-flow#arialabelconfig), you ensure screen readers announce messages in the user’s language.\n\n## WCAG 2.1 AA\n\nReact Flow provides features that can help you meet key WCAG 2.1 AA criteria when properly implemented:\n\n- **Keyboard:** React Flow supports keyboard operability with `Tab` navigation to nodes and edges, interaction via `Enter`/`Space`, and arrow key movement for nodes. These features help satisfy requirements for keyboard accessibility.\n- **Screen Reader:** With semantic ARIA roles and labels (e.g. `role=\"group\"`, `aria-label`, and `aria-roledescription`), React Flow enables you to create meaningfully announced graphical nodes/edges. Edge components include a customizable `aria-label` and nodes can be given appropriate `aria-label` text.\n- **ARIA Live Regions:** Dynamic updates are announced through an `aria-live` region. The `A11yDescriptions` component includes an element with `aria-live=\"assertive\"` that notifies users of node movements, helping you meet requirements for status messages.\n- **Instructions and Focus Management:** React Flow provides contextual help with clear instructions like \"Press enter or space to select a node…\". The automatic focus management ensures nodes scroll into view when focused, helping satisfy requirements for input assistance.\n\nThis guide is helpful for learning about [ARIA best practices](https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/)."
    },
    "learn/advanced-use/computing-flows": {
      "name": "learn/advanced-use/computing-flows",
      "title": "computing-flows",
      "description": "Learn how to extend React Flow to compute data going through flow graphs.",
      "category": "learn",
      "sections": [
        "What are we going to build?",
        "Creating custom nodes",
        "Computing data",
        "Step 1: Writing values to the data object",
        "Step 2: Getting data from connected nodes",
        "Improving the code",
        "Getting more complex",
        "Continuing the flow",
        "Conditional branching",
        "Summary"
      ],
      "content": "# Computing Flows\n\nimport { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n<Callout type=\"info\">\n  For this guide we assume that you already know about the [core\n  concepts](/learn/concepts/core-concepts) of React Flow and how to implement\n  [custom nodes](/learn/customization/custom-nodes).\n</Callout>\n\nUsually with React Flow, developers handle their data outside of React Flow by sending it somewhere else, like on a server or a database. Instead, in this guide we'll show you how to compute data flows directly inside of React Flow. You can use this for updating a node based on connected data, or for building an app that runs entirely inside the browser.\n\n## What are we going to build?\n\nBy the end of this guide, you will build an interactive flow graph that generates a color out of three separate number input fields (red, green and blue), and determines whether white or black text would be more readable on that background color.\n\n<RemoteCodeViewer route=\"learn/computing-6\" framework=\"react\" />\n\n## Creating custom nodes\n\nLet's start by creating a custom input node (`NumberInput.js`) and add three instances of it. We will be using a controlled `<input type=\"number\" />` and limit it to integer numbers between 0 - 255 inside the `onChange` event handler.\n\n```jsx\nimport { useCallback, useState } from 'react';\nimport { Handle, Position } from '@xyflow/react';\n\nfunction NumberInput({ id, data }) {\n  const [number, setNumber] = useState(0);\n\n  const onChange = useCallback((evt) => {\n    const cappedNumber = Math.round(\n      Math.min(255, Math.max(0, evt.target.value)),\n    );\n    setNumber(cappedNumber);\n  }, []);\n\n  return (\n    <div className=\"number-input\">\n      <div>{data.label}</div>\n      <input\n        id={`number-${id}`}\n        name=\"number\"\n        type=\"number\"\n        min=\"0\"\n        max=\"255\"\n        onChange={onChange}\n        className=\"nodrag\"\n        value={number}\n      />\n      <Handle type=\"source\" position={Position.Right} />\n    </div>\n  );\n}\n\nexport default NumberInput;\n```\n\nNext, we'll add a new custom node (`ColorPreview.js`) with one target handle for each color channel and a background that displays the resulting color. We can use `mix-blend-mode: 'difference';` to make the text color always readable.\n\n<Callout type=\"info\">\n  Whenever you have multiple handles of the same kind on a single node, don't\n  forget to give each one a separate id!\n</Callout>\nLet's also add edges going from the input nodes to the color node to our\n`initialEdges` array while we are at it.\n\n<RemoteCodeViewer\n  route=\"learn/computing\"\n  framework=\"react\"\n  activeFile=\"ColorPreview.jsx\"\n/>\n\n## Computing data\n\nHow do we get the data from the input nodes to the color node? This is a two step process that involves two hooks created for this exact purpose:\n\n1. Store each number input value inside the node's `data` object with help of the [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.\n2. Find out which nodes are connected by using [`useNodeConnections`](/api-reference/hooks/use-node-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.\n\n### Step 1: Writing values to the data object\n\nFirst let's add some initial values for the input nodes inside the `data` object in our `initialNodes` array and use them as an initial state for the input nodes.\nThen we'll grab the function [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) from the [`useReactFlow`](/api-reference/hooks/use-react-flow) hook and use it to update the `data` object of the node with a new value whenever the input changes.\n\n<Callout type=\"info\">\nBy default, the data you pass to [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) will be merged with the old data object. This makes it easier to do partial updates and saves you in case you forget to add `{...data}`. You can pass `{ replace: true }` as an option to replace the object instead.\n</Callout>\n\n<RemoteCodeViewer\n  route=\"learn/computing-2\"\n  framework=\"react\"\n  activeFile=\"NumberInput.jsx\"\n/>\n\n<Callout type=\"warning\">\n  <b>\n    When dealing with input fields you don't want to use a nodes `data` object\n    as UI state directly.\n  </b>\n  There is a delay in updating the data object and the cursor might jump around\n  erratically and lead to unwanted inputs.\n</Callout>\n\n### Step 2: Getting data from connected nodes\n\nWe start by determining all connections for each node with the [`useNodeConnections`](/api-reference/hooks/use-node-connections) hook and then fetching the data for the first connected node with [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data).\n\n<Callout type=\"info\">\n  Note that each handle can have multiple nodes connected to it and you might\n  want to restrict the number of connections to a single handle inside your\n  application. Check out the [connection limit\n  example](/examples/nodes/connection-limit) to see how to do that.\n</Callout>\n\n<b>And there you go!</b> Try changing the input values and see the color change\nin real time.\n\n<RemoteCodeViewer\n  route=\"learn/computing-3\"\n  framework=\"react\"\n  activeFile=\"ColorPreview.jsx\"\n/>\n\n### Improving the code\n\nIt might seem awkward to get the connections first, and then the data separately for each handle. For nodes with multiple handles like these, you should consider creating a custom handle component that isolates connection states and node data binding. We can create one inline.\n\n```jsx filename=\"ColorPreview.js\"\n// {...}\nfunction CustomHandle({ id, label, onChange }) {\n  const connections = useNodeConnections({\n    handleType: 'target',\n    handleId: id,\n  });\n\n  const nodeData = useNodesData(connections?.[0].source);\n\n  useEffect(() => {\n    onChange(nodeData?.data ? nodeData.data.value : 0);\n  }, [nodeData]);\n\n  return (\n    <div>\n      <Handle\n        type=\"target\"\n        position={Position.Left}\n        id={id}\n        className=\"handle\"\n      />\n      <label htmlFor=\"red\" className=\"label\">\n        {label}\n      </label>\n    </div>\n  );\n}\n```\n\nWe can promote color to local state and declare each handle like this:\n\n```jsx filename=\"ColorPreview.js\"\n// {...}\nfunction ColorPreview() {\n  const [color, setColor] = useState({ r: 0, g: 0, b: 0 });\n\n  return (\n    <div\n      className=\"node\"\n      style={{\n        background: `rgb(${color.r}, ${color.g}, ${color.b})`,\n      }}\n    >\n      <CustomHandle\n        id=\"red\"\n        label=\"R\"\n        onChange={(value) => setColor((c) => ({ ...c, r: value }))}\n      />\n      <CustomHandle\n        id=\"green\"\n        label=\"G\"\n        onChange={(value) => setColor((c) => ({ ...c, g: value }))}\n      />\n      <CustomHandle\n        id=\"blue\"\n        label=\"B\"\n        onChange={(value) => setColor((c) => ({ ...c, b: value }))}\n      />\n    </div>\n  );\n}\n\nexport default ColorPreview;\n```\n\n## Getting more complex\n\nNow we have a simple example of how to pipe data through React Flow. What if we want to do something more complex, like transforming the data along the way? Or even take different paths? We can do that too!\n\n### Continuing the flow\n\nLet's extend our flow. Start by adding an output `<Handle type=\"source\" position={Position.Right} />` to the color node and remove the local component state.\n\n<Callout type=\"info\">\n  Because there are no inputs fields on this node, we don't need to keep a local\n  state at all. We can just read and update the node's `data` object directly.\n</Callout>\n\nNext, we add a new node (`Lightness.js`) that takes in a color object and determines if it is either a light or dark color. We can use the [relative luminance formula](https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_%22gamma_encoded%22_colorspaces)\n`luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b`\nto calculate the perceived brightness of a color (0 being the darkest and 255 being the brightest). We can assume everything >= 128 is a light color.\n\n<RemoteCodeViewer\n  route=\"learn/computing-4\"\n  framework=\"react\"\n  activeFile=\"Lightness.jsx\"\n/>\n\n### Conditional branching\n\nWhat if we would like to take a different path in our flow based on the perceived lightness? Let's give our lightness node two source handles `light` and `dark` and separate the node `data` object by source handle IDs. This is needed if you have multiple source handles to distinguish between each source handle's data.\n\nBut what does it mean to \"take a different route\"? One solution would be to assume that `null` or `undefined` data hooked up to a target handle is considered a \"stop\". In our case we can write the incoming color into `data.values.light` if it's a light color and into `data.values.dark` if it's a dark color and set the respective other value to `null`.\n\nDon't forget to add `flex-direction: column;` and `align-items: end;` to reposition the handle labels.\n\n<RemoteCodeViewer\n  route=\"learn/computing-5\"\n  framework=\"react\"\n  activeFile=\"Lightness.jsx\"\n/>\n\nCool! Now we only need a last node to see if it actually works... We can create a custom debugging node (`Log.js`) that displays the hooked up data, and we're done!\n\n<RemoteCodeViewer\n  route=\"learn/computing-6\"\n  framework=\"react\"\n  activeFile=\"Log.jsx\"\n/>\n\n## Summary\n\nYou have learned how to move data through the flow and transform it along the way.\nAll you need to do is\n\n1. store data inside the node's `data` object with help of [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.\n2. find out which nodes are connected by using [`useNodeConnections`](/api-reference/hooks/use-node-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.\n\nYou can implement branching for example by interpreting incoming data that is undefined as a \"stop\". As a side note, most flow graphs that also have a branching usually separate the triggering of nodes from the actual data hooked up to the nodes. Unreal Engines Blueprints are a good example for this.\n\n<Callout type=\"info\">\n  One last note before you go: you should find a consistent way of structuring\n  all your node data, instead of mixing ideas like we did just now. This means\n  for example, if you start working with splitting data by handle ID you should\n  do it for all nodes, regardless whether they have multiple handles or not.\n  Being able to make assumptions about the structure of your data throughout\n  your flow will make life a lot easier.\n</Callout>"
    },
    "learn/advanced-use/devtools-and-debugging": {
      "name": "learn/advanced-use/devtools-and-debugging",
      "title": "Devtools",
      "description": "Copy pastable devtools for React Flow",
      "category": "learn",
      "sections": [
        "Node Inspector",
        "Change Logger",
        "Viewport Logger",
        "Let us know what you think"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Devtools and Debugging\n\n<Callout type=\"info\">\n  This is an ongoing experiment on implementing our own React Flow devtools. While we are\n  working on the actual package, we'd love to hear about your feedback and ideas on\n  [Discord](https://discord.gg/Bqt6xrs) or via mail at info@xyflow.com.\n</Callout>\n\nReact Flow can often seem like a magic black box, but in reality you can reveal quite a\nlot about its internal state if you know where to look. In this guide we will show you\nthree different ways to reveal the internal state of your flow:\n\n- A `<ViewportLogger />` component that shows the current position and zoom level of the\n  viewport.\n- A `<NodeInspector />` component that reveals the state of each node.\n- A `<ChangeLogger />` that wraps your flow's `onNodesChange` handler and logs each change\n  as it is dispatched.\n\nWhile we find these tools useful for making sure React Flow is working properly, you might\nalso find them useful for debugging your applications as your flows and their interactions\nbecome more complex.\n\n<div className=\"nestedSandpack\">\n  <RemoteCodeViewer route=\"learn/devtools\" framework=\"react\" />\n</div>\n\nWe encourage you to copy any or all of the components from this example into your own\nprojects and modify them to suit your needs: each component works independently!\n\n## Node Inspector\n\nThe `<NodeInspector />` component makes use of our\n[`useNodes`](/api-reference/hooks/use-nodes) hook to access all the nodes in the flow.\nTypically we discourage using this hook because it will trigger a re-render any time _any_\nof your nodes change, but that's exactly what makes it so useful for debugging!\n\nThe `width` and `height` properties are added to each node by React Flow after it has\nmeasured the node's dimensions. We pass those dimensions, as well as other information\nlike the node's id and type, to a custom `<NodeInfo />` component.\n\nWe make use of the [`<ViewportPortal />`](/api-reference/components/viewport-portal)\ncomponent to let us render the inspector into React Flow's viewport. That means it's\ncontent will be positioned and transformed along with the rest of the flow as the user\npans and zooms.\n\n## Change Logger\n\nAny change to your nodes and edges that originates from React Flow itself is communicated\nto you through the `onNodesChange` and `onEdgesChange` callbacks. If you are working with\na controlled flow (that means you're managing the nodes and edges yourself), you need to\napply those changes to your state in order to keep everything in sync.\n\nThe `<ChangeLogger />` component wraps your user-provided `onNodesChange` handler with a\ncustom function that intercepts and logs each change as it is dispatched. We can do this\nby using the [`useStore`](/api-reference/hooks/use-store) and\n[`useStoreApi`](/api-reference/hooks/use-store-api) hooks to access the store and and then\nupdate React Flow's internal state accordingly. These two hooks give you powerful access\nto React Flow's internal state and methods.\n\nBeyond debugging, using the `<ChangeLogger />` can be a great way to learn more about how\nReact Flow works and get you thinking about the different functionality you can build on\ntop of each change.\n\nYou can find documentation on the [`NodeChange`](/api-reference/types/node-change) and\n[`EdgeChange`](/api-reference/types/edge-change) types in the API reference.\n\n## Viewport Logger\n\nThe `<ViewportLogger />` is the simplest example of what state you can pull out of React\nFlow's store if you know what to look for. The state of the viewport is stored internally\nunder the `transform` key (a name we inherited from\n[d3-zoom](https://d3js.org/d3-zoom#zoomTransform)). This component extracts the `x`, `y`,\nand `zoom` components of the transform and renders them into a\n[`<Panel />`](/api-reference/components/panel) component.\n\n## Let us know what you think\n\nAs mentioned above, if you have any feedback or ideas on how to improve the devtools,\nplease let us know on [Discord](https://discord.gg/Bqt6xrs) or via mail at\ninfo@xyflow.com. If you build your own devtools using these ideas, we'd love to hear about\nit!"
    },
    "learn/advanced-use/hooks-providers": {
      "name": "learn/advanced-use/hooks-providers",
      "title": "hooks-providers",
      "description": "Overview of Hooks and Providers in React Flow.",
      "category": "learn",
      "sections": [
        "ReactFlowProvider",
        "useReactFlow"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\n\n# Hooks and Providers\n\nReact Flow provides several [hooks](/api-reference/hooks) and a context provider\nfor you to enhance the functionality of your flow. These tools help you to\nmanage state, access internal methods, and create custom components more\neffectively.\n\n## ReactFlowProvider\n\nThe ReactFlowProvider is a context provider that allows you to access the\ninternal state of the flow, such as nodes, edges, and viewport, from anywhere in\nyour component tree even outside the [`ReactFlow`](/api-reference/react-flow)\ncomponent. It is typically used at the top level of your application.\n\nThere are several cases where you might need to use the\n[`ReactFlowProvider`](/api-reference/react-flow-provider) component:\n\n- Many of the [hooks](/api-reference/hooks) we provide rely on this component to\n  work.\n- You want to access the internal state of the flow outside of the `ReactFlow`\n  component.\n- You are working with multiple flows on a page.\n- You are using a client-side router.\n\n<RemoteCodeViewer route=\"examples/misc/provider\" framework=\"react\" />\n\n## useReactFlow\n\nThe [`useReactFlow`](/api-reference/hooks/use-react-flow) hook provides access\nto the [`ReactFlowInstance`](/api-reference/types/react-flow-instance) and its\nmethods. It allows you to manipulate nodes, edges, and the viewport\nprogrammatically.\n\nThis example illustrates how to use the `useReactFlow` hook.\n\n<RemoteCodeViewer route=\"examples/misc/use-react-flow-hook\" framework=\"react\" />"
    },
    "learn/advanced-use/performance": {
      "name": "learn/advanced-use/performance",
      "title": "performance",
      "description": "Strategies to optimize React Flow performance for large graphs.",
      "category": "learn",
      "sections": [
        "Use memoization",
        "Memoize components",
        "Memoize functions",
        "Avoid accessing nodes in components",
        "Inefficient example",
        "Optimized solution",
        "Collapse large node trees",
        "Simplify node and edge styles",
        "Additional resources"
      ],
      "content": "# Performance\n\nWhen dealing with a large number of nodes or complex components, managing performance can\nbe challenging. Here are a few effective strategies to optimize the performance of React\nFlow.\n\n## Use memoization\n\nOne of the main reasons for performance issues in React Flow is unnecessary re-renders.\nSince node movements trigger frequent state updates, this can lead to performance\nbottlenecks, especially in larger diagrams.\n\n### Memoize components\n\nComponents provided as props to the `<ReactFlow>` component, including custom node and\nedge components, should either be memoized using `React.memo` or declared outside the\nparent component. This ensures that React does not create a new reference for the\ncomponent on every render, which would otherwise trigger unnecessary re-renders.\n\n```tsx\nconst NodeComponent = memo(() => {\n  return <div>{data.label}</div>;\n});\n```\n\n### Memoize functions\n\nSimilarly, functions passed as props to `<ReactFlow>` should be memoized using\n`useCallback`. This prevents React from creating a new function reference on every render,\nwhich could also trigger unnecessary re-renders. Additionally, arrays and objects like\n`defaultEdgeOptions` or `snapGrid` should be memoized using `useMemo` to prevent\nunnecessary re-renders.\n\n```tsx\nimport React, { useCallback } from 'react';\n\nconst MyDiagram = () => {\n  const onNodeClick = useCallback((event, node) => {\n    console.log('Node clicked:', node);\n  }, []);\n\n  return <ReactFlow onNodeClick={onNodeClick} />;\n};\n\nexport default MyDiagram;\n```\n\n## Avoid accessing nodes in components\n\nOne of the most common performance pitfalls in React Flow is directly accessing\nthe `nodes` or `edges` in the components or the viewport. These objects change frequently\nduring operations like dragging, panning, or zooming, which can cause unnecessary\nre-renders of components that depend on them.\n\nFor example, if you fetch the entire `nodes` array from the store and filter it to display\nselected node IDs, this approach can lead to performance degradation. Every update to\nthe `nodes` array triggers a re-render of all dependent components, even if the change is\nunrelated to the selected nodes.\n\n### Inefficient example\n\n```tsx\nconst SelectedNodeIds = () => {\n  // ❌ This will cause unnecessary re-renders!\n\n  const nodes = useStore((state) => state.nodes);\n\n  const selectedNodeIds = nodes.filter((node) => node.selected).map((node) => node.id);\n\n  return (\n    <div>\n      {selectedNodeIds.map((id) => (\n        <div key={id}>{id}</div>\n      ))}\n    </div>\n  );\n};\n```\n\nIn this example, every update to the `nodes` array causes the `SelectedNodeIds` component\nto re-render, even if the selection hasn’t changed.\n\n### Optimized solution\n\nTo avoid unnecessary re-renders, store the selected nodes in a separate field in your\nstate (using Zustand, Redux, or any other state management solution). This ensures that\nthe component only re-renders when the selection changes.\n\n```tsx\nconst SelectedNodeIds = () => {\n  const selectedNodeIds = useStore((state) => state.selectedNodeIds);\n\n  return (\n    <div>\n      {selectedNodeIds.map((id) => (\n        <div key={id}>{id}</div>\n      ))}\n    </div>\n  );\n};\n```\n\nBy decoupling the selected nodes from the `nodes` array, you prevent unnecessary updates\nand improve performance. For more information, view our\n[State Management guide](/learn/advanced-use/state-management).\n\n## Collapse large node trees\n\nIf your node tree is deeply nested, rendering all nodes at once can be inefficient.\nInstead, show only a limited number of nodes and allow users to expand them as needed. You\ncan do this by modifying the node’s `hidden` property dynamically to toggle visibility.\n\n```tsx\nconst handleNodeClick = (targetNode) => {\n  if (targetNode.data.children) {\n    setNodes((prevNodes) =>\n      prevNodes.map((node) =>\n        targetNode.data.children.includes(node.id)\n          ? { ...node, hidden: !node.hidden }\n          : node,\n      ),\n    );\n  }\n};\n```\n\nBy hiding nodes initially and rendering them only when expanded, we optimize performance\nwhile maintaining usability.\n\n## Simplify node and edge styles\n\nIf you've optimized performance in every other way, and you are still finding performance\nissues with large numbers of nodes, complex CSS styles, particularly those involving\nanimations, shadows, or gradients, can significantly impact performance. Consider reducing\ncomplexity on your node styles in these cases.\n\n## Additional resources\n\nHere are a few helpful resources on performance in React Flow that you can check out:\n\n- [Guide to Optimize React Flow Project Performance](https://www.synergycodes.com/blog/guide-to-optimize-react-flow-project-performance)\n- [Tuning Edge Animations ReactFlow Optimal Performance](https://liambx.com/blog/tuning-edge-animations-reactflow-optimal-performance)\n- [5 Ways to Optimize React Flow in 10 minutes](https://www.youtube.com/watch?v=8M2qZ69iM20)"
    },
    "learn/advanced-use/ssr-ssg-configuration": {
      "name": "learn/advanced-use/ssr-ssg-configuration",
      "title": "Server Side Rendering",
      "description": "Step-by-step guide render React Flow apps on the server for displaying static flows, dynamically generating images from flows, or rendering graphs in non-javascript environments",
      "category": "learn",
      "sections": [
        "Node dimensions",
        "Handle positions",
        "Using `fitView` on the server",
        "Usage with the `<ReactFlowProvider>`",
        "Creating static HTML"
      ],
      "content": "# Server side rendering, server side generation\n\nimport { Callout } from 'nextra/components';\n\n<Callout type=\"info\">Server side rendering is supported since React Flow 12</Callout>\n\nThis is an advanced use case and assumes you are already familiar with React Flow. If you're new to React Flow, check out our [getting started guide](/learn/getting-started/installation-and-requirements).\n\nIn this guide you will learn how to configure React Flow to render a flow on the server, which will allow you to\n\n- Display static HTML diagrams in documentation\n- Render React Flow diagrams in non-js environments\n- Dynamically generate open graph images that appear as embeds when sharing a link to your flow\n\n(If you want to download an image of your flow, there's an easier way to do that on the client-side in our [download image example](/examples/misc/download-image).)\n\n### Node dimensions\n\nYou need to configure a few things to make React Flow work on the server, the most important being the node dimensions. React Flow only renders nodes if they have a width and height. Usually you pass nodes without a specific `width` and `height`, they are then measured and the dimensions get written to `measured.width` and `measured.height`. Since we can't measure the dimensions on the server, we need to pass them explicitly. This can be done with the `width` and `height` or the `initialWidth` and `initialHeight` node properties.\n\n```js\nconst nodes = [\n  {\n    id: '1',\n    type: 'default',\n    position: { x: 0, y: 0 },\n    data: { label: 'Node 1' },\n    width: 100,\n    height: 50,\n  },\n];\n```\n\nReact Flow now knows the dimensions of the node and can render it on the server. The `width` and `height` properties are used as an inline style for the node. If you expect nodes to have different dimensions on the client or if the dimensions should by dynamic based on the content, you can use the `initialWidth` and `initialHeight` properties. They are only used for the first render (on the server or on the client) as long as the nodes are not measured and `measured.width` and `measured.height` are not set.\n\n<Callout type=\"default\">\n  <strong>\n    There are two ways to specify node dimensions for server side rendering:\n  </strong>\n  <div>\n    1. `width` and `height` for static dimensions that are known in advance and don't\n    change.\n  </div>\n  <div>\n    2. `initialWidth` and `initialHeight` for dynamic dimensions that are not known in\n    advance or change.\n  </div>\n</Callout>\n\n### Handle positions\n\nYou probably also want to render the edges on the server. On the client, React Flow checks the positions of the handles and stores that information to draw the edges. Since we can't measure the handle positions on the server, we need to pass this information, too. This can be done with the `handles` property of a node.\n\n```js\nconst nodes: Node[] = [\n  {\n    id: '1',\n    type: 'default',\n    position: { x: 0, y: 0 },\n    data: { label: 'Node 1' },\n    width: 100,\n    height: 50,\n    handles: [\n      {\n        type: 'target',\n        position: Position.Top,\n        x: 100 / 2,\n        y: 0,\n      },\n      {\n        type: 'source',\n        position: Position.Bottom,\n        x: 100 / 2,\n        y: 50,\n      },\n    ],\n  },\n];\n```\n\nWith this additional information, React Flow knows enough about the handles to render the edges on the server. If you are fine with just rendering the nodes, you can skip this step.\n\n### Using `fitView` on the server\n\nIf you know the dimensions of the React Flow container itself, you can even use `fitView` on the server. For this, you need to pass the `width` and `height` of the container to the `ReactFlow` component.\n\n```js\n<ReactFlow nodes={nodes} edges={edges} fitView width={1000} height={500} />\n```\n\nThis will calculate the viewport and set the `transform` on the server in order to include all nodes in the viewport.\n\n### Usage with the `<ReactFlowProvider>`\n\nIf you are using the `ReactFlowProvider`, you can pass `initialNodes`, `initialEdges` and optional wrapper dimensions (`initialWidth` and `initialHeight`) and `fitView` to the provider.\n\n```js\n<ReactFlowProvider\n  initialNodes={nodes}\n  initialEdges={edges}\n  initialWidth={1000}\n  initialHeight={500}\n  fitView\n>\n  <App />\n</ReactFlowProvider>\n```\n\nThe `initial-` prefix means that these values are only used for the first render. After that, the provider will use the `nodes` and `edges` from the context.\n\n### Creating static HTML\n\nIf you want to create static HTML, you can use the `renderToStaticMarkup` function from React. This will render the React Flow component to a string of HTML. You can then use this string to create a static HTML file or send it as a response to an HTTP request.\n\n```js\nimport React from 'react';\nimport { renderToStaticMarkup } from 'react-dom/server';\nimport { ReactFlow, Background } from '@xyflow/react';\n\nfunction toHTML({ nodes, edges, width, height }) {\n  const html = renderToStaticMarkup(\n    React.createElement(\n      ReactFlow,\n      {\n        nodes,\n        edges,\n        width,\n        height,\n        minZoom: 0.2,\n        fitView: true,\n      },\n      React.createElement(Background, null),\n    ),\n  );\n\n  return html;\n}\n```"
    },
    "learn/advanced-use/state-management": {
      "name": "learn/advanced-use/state-management",
      "title": "State Management",
      "description": "Learn how to use React Flow with a state management library like Zustand, Redux, Recoil or Jotai.",
      "category": "learn",
      "sections": [
        "Install Zustand",
        "Create a store",
        "Implement a color change action",
        "Add a color chooser node"
      ],
      "content": "# Using a State Management Library\n\nimport { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n<Callout type=\"info\">\n  For this guide we assume that you already know about the [core\n  concepts](/learn/concepts/core-concepts) of React Flow and how to implement\n  [custom nodes](/learn/customization/custom-nodes). You should also be familiar\n  with the concepts of state management libraries and how to use them.\n</Callout>\n\nIn this guide, we explain how to use React Flow with the state management library [Zustand](https://github.com/pmndrs/zustand). We will build a small app where each node features a color chooser that updates its background color. We chose Zustand for this guide because React Flow already uses it internally, but you can easily use other state management libraries such as [Redux](https://redux.js.org/), [Recoil](https://recoiljs.org/) or [Jotai](https://jotai.org/)\n\nAs demonstrated in previous guides and examples, React Flow can easily be used with a local component state to manage nodes and edges in your diagram. However, as your application grows and you need to update the state from within individual nodes, managing this state can become more complex. Instead of passing functions through the node's data field, you can use a [React context](https://reactjs.org/docs/context.html) or integrate a state management library like Zustand, as outlined in this guide.\n\n## Install Zustand\n\nAs mentioned above we are using Zustand in this example. Zustand is a bit like Redux: you have a central store with actions to alter your state and hooks to access your state. You can install Zustand via:\n\n```bash copy npm2yarn\nnpm install --save zustand\n```\n\n## Create a store\n\nZustand lets you create a hook for accessing the values and functions of your store. We put the `nodes` and `edges` and the `onNodesChange`, `onEdgesChange`, `onConnect`, `setNodes` and `setEdges` functions in the store to get the basic interactivity for our graph:\n\n<RemoteCodeViewer route=\"learn/state-management\" framework=\"react\" />\n\nThat's the basic setup. We now have a store with nodes and edges that can handle the changes (dragging, selecting or removing a node or edge) triggered by React Flow. When you take a look at the `App.tsx` file, you can see that it's kept nice and clean. All the data and actions are now part of the store and can be accessed with the `useStore` hook.\n\n## Implement a color change action\n\nWe add a new `updateNodeColor` action to update the `data.color` field of a specific node. For this we pass the node id and the new color to the action, iterate over the nodes and update the matching one with the new color:\n\n```ts\nupdateNodeColor: (nodeId: string, color: string) => {\n  set({\n    nodes: get().nodes.map((node) => {\n      if (node.id === nodeId) {\n        // it's important to create a new object here, to inform React Flow about the changes\n        return { ...node, data: { ...node.data, color } };\n      }\n\n      return node;\n    }),\n  });\n};\n```\n\nThis new action can now be used in a React component like this:\n\n```tsx\nconst updateNodeColor = useStore((s) => s.updateNodeColor);\n...\n<button onClick={() => updateNodeColor(nodeId, color)} />;\n```\n\n## Add a color chooser node\n\nIn this step we implement the `ColorChooserNode` component and call the `updateNodeColor` when the user changes the color. The custom part of the color chooser node is the color input.\n\n```jsx\n<input\n  type=\"color\"\n  defaultValue={data.color}\n  onChange={(evt) => updateNodeColor(id, evt.target.value)}\n  className=\"nodrag\"\n/>\n```\n\nWe add the `nodrag` class name so that the user doesn't drag the node by mistake when changing the color and call the `updateNodeColor` in the `onChange` event handler.\n\n<RemoteCodeViewer\n  route=\"learn/state-management-2\"\n  framework=\"react\"\n  activeFile=\"ColorChooserNode.tsx\"\n/>\n\nYou can now click on a color chooser and change the background of a node."
    },
    "learn/advanced-use/testing": {
      "name": "learn/advanced-use/testing",
      "title": "testing",
      "description": "How to test React Flow applications with Cypress, Playwright or Jest.",
      "category": "learn",
      "sections": [
        "Using Cypress or Playwright",
        "Using Jest"
      ],
      "content": "# Testing\n\nThere are plenty of options to test a React application. If you want to test a React Flow application, we recommend to use [Cypress](https://www.cypress.io/) or [Playwright](https://playwright.dev/). React Flow needs to measure nodes in order to render edges and for that relies on rendering DOM elements.\n\n## Using Cypress or Playwright\n\nIf you are using Cypress or Playwright no additional setup is needed. You can refer to the getting started guide for [Cypress here](https://docs.cypress.io/guides/getting-started/installing-cypress) and for [Playwright here](https://playwright.dev/docs/intro).\n\n## Using Jest\n\nIf you are using [Jest](https://jestjs.io/), you need to mock some features in order to be able to run your tests. You can do that by adding this file to your project. Calling `mockReactFlow()` in a `setupTests` file (or inside a `beforeEach`) will trigger the necessary overrides.\n\n```ts\n// To make sure that the tests are working, it's important that you are using\n// this implementation of ResizeObserver and DOMMatrixReadOnly\nclass ResizeObserver {\n  callback: globalThis.ResizeObserverCallback;\n\n  constructor(callback: globalThis.ResizeObserverCallback) {\n    this.callback = callback;\n  }\n\n  observe(target: Element) {\n    this.callback([{ target } as globalThis.ResizeObserverEntry], this);\n  }\n\n  unobserve() {}\n\n  disconnect() {}\n}\n\nclass DOMMatrixReadOnly {\n  m22: number;\n  constructor(transform: string) {\n    const scale = transform?.match(/scale\\(([1-9.])\\)/)?.[1];\n    this.m22 = scale !== undefined ? +scale : 1;\n  }\n}\n\n// Only run the shim once when requested\nlet init = false;\n\nexport const mockReactFlow = () => {\n  if (init) return;\n  init = true;\n\n  global.ResizeObserver = ResizeObserver;\n\n  // @ts-ignore\n  global.DOMMatrixReadOnly = DOMMatrixReadOnly;\n\n  Object.defineProperties(global.HTMLElement.prototype, {\n    offsetHeight: {\n      get() {\n        return parseFloat(this.style.height) || 1;\n      },\n    },\n    offsetWidth: {\n      get() {\n        return parseFloat(this.style.width) || 1;\n      },\n    },\n  });\n\n  (global.SVGElement as any).prototype.getBBox = () => ({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  });\n};\n```\n\nIf you want to test mouse events with jest (for example inside your custom nodes), you need to disable `d3-drag` as it does not work outside of the browser:\n\n```js\n<ReactFlow nodesDraggable={false} panOnDrag={false} {...rest} />\n```"
    },
    "learn/advanced-use/typescript": {
      "name": "learn/advanced-use/typescript",
      "title": "TypeScript",
      "description": "In this guide we explain how to work with React Flow and TypeScript.",
      "category": "learn",
      "sections": [
        "Basic usage",
        "Custom nodes",
        "Custom edges",
        "Advanced usage",
        "`Node` and `Edge` type unions",
        "Functions passed to `<ReactFlow />`",
        "Hooks",
        "Type guards"
      ],
      "content": "import { Callout } from 'nextra/components';\n\n# Usage with TypeScript\n\nReact Flow is written in TypeScript because we value the additional safety barrier it provides.\nWe export all the types you need for correctly typing data structures and functions you pass to the React Flow component. We also provide a way to extend the types of nodes and edges.\n\n## Basic usage\n\nLet's start with the most basic types you need for a simple starting point. Typescript might already infer some of these types, but we will define them explicitly nonetheless.\n\n```tsx\nimport { useState, useCallback } from 'react';\nimport {\n  ReactFlow,\n  addEdge,\n  applyNodeChanges,\n  applyEdgeChanges,\n  type Node,\n  type Edge,\n  type FitViewOptions,\n  type OnConnect,\n  type OnNodesChange,\n  type OnEdgesChange,\n  type OnNodeDrag,\n  type DefaultEdgeOptions,\n} from '@xyflow/react';\n\nconst initialNodes: Node[] = [\n  { id: '1', data: { label: 'Node 1' }, position: { x: 5, y: 5 } },\n  { id: '2', data: { label: 'Node 2' }, position: { x: 5, y: 100 } },\n];\n\nconst initialEdges: Edge[] = [{ id: 'e1-2', source: '1', target: '2' }];\n\nconst fitViewOptions: FitViewOptions = {\n  padding: 0.2,\n};\n\nconst defaultEdgeOptions: DefaultEdgeOptions = {\n  animated: true,\n};\n\nconst onNodeDrag: OnNodeDrag = (_, node) => {\n  console.log('drag event', node.data);\n};\n\nfunction Flow() {\n  const [nodes, setNodes] = useState<Node[]>(initialNodes);\n  const [edges, setEdges] = useState<Edge[]>(initialEdges);\n\n  const onNodesChange: OnNodesChange = useCallback(\n    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),\n    [setNodes],\n  );\n  const onEdgesChange: OnEdgesChange = useCallback(\n    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),\n    [setEdges],\n  );\n  const onConnect: OnConnect = useCallback(\n    (connection) => setEdges((eds) => addEdge(connection, eds)),\n    [setEdges],\n  );\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      onConnect={onConnect}\n      onNodeDrag={onNodeDrag}\n      fitView\n      fitViewOptions={fitViewOptions}\n      defaultEdgeOptions={defaultEdgeOptions}\n    />\n  );\n}\n```\n\n### Custom nodes\n\nWhen working with [custom nodes](/learn/customization/custom-nodes) you have the possibility to pass a custom `Node` type (or your `Node` union) to the `NodeProps` type. There are basically two ways to work with custom nodes:\n\n1. If you have **multiple custom nodes**, you want to pass a specific `Node` type as a generic to the `NodeProps` type:\n\n```tsx filename=\"NumberNode.tsx\"\nimport type { Node, NodeProps } from '@xyflow/react';\n\ntype NumberNode = Node<{ number: number }, 'number'>;\n\nexport default function NumberNode({ data }: NodeProps<NumberNode>) {\n  return <div>A special number: {data.number}</div>;\n}\n```\n\n⚠️ If you specify the node data separately, you need to use `type` (an `interface` would not work here):\n\n```ts\ntype NumberNodeData = { number: number };\ntype NumberNode = Node<NumberNodeData, 'number'>;\n```\n\n2. If you have **one custom node** that renders different content based on the node type, you want to pass your `Node` union type as a generic to `NodeProps`:\n\n```tsx filename=\"CustomNode.tsx\"\nimport type { Node, NodeProps } from '@xyflow/react';\n\ntype NumberNode = Node<{ number: number }, 'number'>;\ntype TextNode = Node<{ text: string }, 'text'>;\n\ntype AppNode = NumberNode | TextNode;\n\nexport default function CustomNode({ data }: NodeProps<AppNode>) {\n  if (data.type === 'number') {\n    return <div>A special number: {data.number}</div>;\n  }\n\n  return <div>A special text: {data.text}</div>;\n}\n```\n\n### Custom edges\n\nFor [custom edges](/learn/customization/custom-nodes) you have the same possibility as for custom nodes.\n\n```tsx filename=\"CustomEdge.tsx\"\nimport { getStraightPath, BaseEdge, type EdgeProps, type Edge } from '@xyflow/react';\n\ntype CustomEdge = Edge<{ value: number }, 'custom'>;\n\nexport default function CustomEdge({\n  id,\n  sourceX,\n  sourceY,\n  targetX,\n  targetY,\n}: EdgeProps<CustomEdge>) {\n  const [edgePath] = getStraightPath({ sourceX, sourceY, targetX, targetY });\n\n  return <BaseEdge id={id} path={edgePath} />;\n}\n```\n\n## Advanced usage\n\nWhen creating complex applications with React Flow, you will have a number of custom nodes & edges, each with different kinds of data attached to them.\nWhen we operate on these nodes & edges through built in functions and hooks, we have to make sure that we [narrow down](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)\nthe types of nodes & edges to prevent runtime errors.\n\n### `Node` and `Edge` type unions\n\nYou will see many functions, callbacks and hooks (even the ReactFlow component itself) that expect a `NodeType` or `EdgeType` generic. These generics are simply\n[unions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) of all the different types of nodes & edges you have in your application.\nAs long as you have typed the data objects correctly (see previous section), you can use their exported type.\n\n<Callout type=\"info\">\n  If you use any of the built-in nodes ('input', 'output', 'default') or edges\n  ('straight', 'step', 'smoothstep', 'bezier'), you can add the `BuiltInNode` and\n  `BuiltInEdge` types exported from `@xyflow/react` to your union type.\n</Callout>\n\n```tsx\nimport type { BuiltInNode, BuiltInEdge } from '@xyflow/react';\n\n// Custom nodes\nimport NumberNode from './NumberNode';\nimport TextNode from './TextNode';\n\n// Custom edge\nimport EditableEdge from './EditableEdge';\n\nexport type CustomNodeType = BuiltInNode | NumberNode | TextNode;\nexport type CustomEdgeType = BuiltInEdge | EditableEdge;\n```\n\n### Functions passed to `<ReactFlow />`\n\nTo receive correct types for callback functions, you can pass your union types to the `ReactFlow` component.\nBy doing that you will have to type your callback functions explicitly.\n\n```tsx\nimport { type OnNodeDrag } from '@xyflow/react';\n\n// ...\n\n// Pass your union type here ...\nconst onNodeDrag: OnNodeDrag<CustomNodeType> = useCallback((_, node) => {\n  if (node.type === 'number') {\n    // From here on, Typescript knows that node.data\n    // is of type { num: number }\n    console.log('drag event', node.data.number);\n  }\n}, []);\n\nconst onNodesChange: OnNodesChange<CustomNodeType> = useCallback(\n  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),\n  [setNodes],\n);\n```\n\n### Hooks\n\nThe type unions can also be used to type the return values of many hooks.\n\n```tsx filename=\"FlowComponent.tsx\"\nimport { useReactFlow, useNodeConnections, useNodesData, useStore } from '@xyflow/react';\n\nexport default function FlowComponent() {\n  // returned nodes and edges are correctly typed now\n  const { getNodes, getEdges } = useReactFlow<CustomNodeType, CustomEdgeType>();\n\n  // You can type useStore by typing the selector function\n  const nodes = useStore((s: ReactFlowState<CustomNodeType>) => s.nodes);\n\n  const connections = useNodeConnections({\n    handleType: 'target',\n  });\n\n  const nodesData = useNodesData<CustomNodeType>(connections?.[0].source);\n\n  nodeData.forEach(({ type, data }) => {\n    if (type === 'number') {\n      // This is type safe because we have narrowed down the type\n      console.log(data.number);\n    }\n  });\n  // ...\n}\n```\n\n### Type guards\n\nThere are multiple ways you can define [type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards) in Typescript.\nOne way is to define type guard functions like `isNumberNode` or `isTextNode` to filter out specific nodes from a list of nodes.\n\n```tsx\nfunction isNumberNode(node: CustomNodeType): node is NumberNode {\n  return node.type === 'number';\n}\n\n// numberNodes is of type NumberNode[]\nconst numberNodes = nodes.filter(isNumberNode);\n```"
    },
    "learn/advanced-use/uncontrolled-flow": {
      "name": "learn/advanced-use/uncontrolled-flow",
      "title": "uncontrolled-flow",
      "description": "Uncontrolled inputs in React manage their own state internally. This guide shows you how to set up and use an uncontrolled flow.",
      "category": "learn",
      "sections": [
        "Updating nodes and edges"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Uncontrolled Flow\n\nThere are two ways to use React Flow - controlled or uncontrolled. Controlled means, that you are in control of the state of the nodes and edges. In an uncontrolled flow the state of the nodes and edges is handled by React Flow internally. In this part we will show you how to work with an uncontrolled flow.\n\nAn implementation of an uncontrolled flow is simpler, because you don't need to pass any handlers:\n\n<RemoteCodeViewer route=\"learn/uncontrolled\" framework=\"react\" />\n\nAs you can see, we are passing `defaultEdgeOptions` to define that edges are animated. This is helpful, because you can't use the `onConnect` handler anymore to pass custom options to a newly created edge. Try to connect \"Node B\" with \"Node C\" and you see that the new edge is animated.\n\n## Updating nodes and edges\n\nSince you don't have nodes and edges in your local state, you can't update them directly. To do so, you need to use the [React Flow instance](/api-reference/types/react-flow-instance) that comes with functions for updating the internal state. You can receive the instance via the `onInit` callback or better by using the [`useReactFlow` hook](/api-reference/hooks/use-react-flow). Let's create a button that adds a new node at a random position. For this, we are wrapping our flow with the [`ReactFlowProvider`](/api-reference/react-flow-provider) and use the [`addNodes` function](/api-reference/types/react-flow-instance#nodes-and-edges).\n\n<Callout>\n  The `Flow` component in this example is wrapped with the `ReactFlowProvider`\n  to use the `useReactFlow` hook.\n</Callout>\n\n<RemoteCodeViewer route=\"learn/uncontrolled-2\" framework=\"react\" />"
    },
    "learn/advanced-use/whiteboard": {
      "name": "learn/advanced-use/whiteboard",
      "title": "whiteboard",
      "description": "",
      "category": "learn",
      "sections": [
        "Examples",
        "✏️ Freehand draw (Pro)",
        "🎯 Lasso selection",
        "🧹 Eraser",
        "📐 Rectangle draw",
        "Whiteboard libraries"
      ],
      "content": "import ProExampleViewer from '@/components/pro-example-viewer';\nimport { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Whiteboard Features\n\nReact Flow is designed for building node-based UIs like workflow editors, flowcharts and\ndiagrams. Even if React Flow is not made for creating whiteboard applications, you might\nwant to integrate common whiteboard features. These examples show how to add drawing\ncapabilities to your applications when you need to annotate or sketch alongside your nodes\nand edges.\n\n## Examples\n\n### ✏️ Freehand draw (Pro)\n\nDraw smooth curves on your React Flow pane. Useful for annotations or sketching around\nexisting nodes.\n\n**Features:**\n\n- Mouse/touch drawing\n- Adjustable brush size and color\n- converts drawn paths into custom nodes\n\n**Common uses:**\n\n- Annotating flowcharts\n- Adding notes to diagrams\n- Sketching ideas around nodes\n\n<ProExampleViewer slug=\"freehand-draw\" innerClassName=\"flex flex-col-reverse\" />\n\n### 🎯 Lasso selection\n\nSelect multiple elements by drawing a freeform selection area with an option to include\npartially selected elements.\n\n**Features:**\n\n- Freeform selection shapes\n- partial selection of elements\n\n**Common uses:**\n\n- Selecting nodes and annotations together\n- Complex selections in mixed content\n\n<RemoteCodeViewer\n  route=\"examples/whiteboard/lasso-selection\"\n  framework=\"react\"\n/>\n\n### 🧹 Eraser\n\nRemove items by \"erasing\" over them. Uses collision detection to determine what to delete.\n\n**Features:**\n\n- Collision-based erasing\n- Visual eraser cursor\n\n**Common uses:**\n\n- Removing parts of a flow\n\n<RemoteCodeViewer\n  route=\"examples/whiteboard/eraser\"\n  framework=\"react\"\n/>\n\n### 📐 Rectangle draw\n\nCreate rectangular shapes by clicking and dragging. Good for highlighting areas or\ncreating backgrounds for node groups.\n\n**Features:**\n\n- Click-and-drag rectangle creation\n- Customizable colors\n\n**Common uses:**\n\n- Creating background containers\n- Grouping related nodes visually\n- Highlighting sections of diagrams\n\n<RemoteCodeViewer\n  route=\"examples/whiteboard/rectangle\"\n  framework=\"react\"\n/>\n\n## Whiteboard libraries\n\nIf you are looking for a more complete whiteboard solution, consider using libraries that\nare specifically designed for whiteboard applications like [tldraw](https://tldraw.dev/)\nor [Excalidraw](https://docs.excalidraw.com/). These libraries provide a full set of\nfeatures for collaborative drawing, shapes, text, and more."
    },
    "learn/concepts/adding-interactivity": {
      "name": "learn/concepts/adding-interactivity",
      "title": "adding-interactivity",
      "description": "This guide will show you how to add basic interactivity to your flow.",
      "category": "learn",
      "sections": [
        "Handling change events",
        "Define nodes and edges",
        "Initialize state",
        "Add event handlers",
        "Pass them to ReactFlow",
        "Interactive flow",
        "Handling connections",
        "Create `onConnect` handler",
        "Pass it to ReactFlow",
        "Connectable flow",
        "Full code example 🏁"
      ],
      "content": "import { Callout, Steps } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Adding Interactivity\n\nNow that we've built our [first flow](/learn/concepts/building-a-flow), let's add\n\\*interactivity so you can select, drag, and remove nodes and edges.\n\n## Handling change events\n\nBy default React Flow doesn't manage any internal state updates besides handling the\nviewport. As you would with an HTML `<input />` element you need to pass\n[event handlers](/api-reference/react-flow#event-handlers) to React Flow in order to apply\ntriggered changes to your nodes and edges.\n\n <Steps>\n ### Add imports\n\nTo manage changes, we'll be using `useState` with two helper functions from React Flow:\n[`applyNodeChanges`](/api-reference/utils/apply-node-changes) and\n[`applyEdgeChanges`](/api-reference/utils/apply-edge-changes). So let's import these\nfunctions:\n\n```jsx\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, applyEdgeChanges, applyNodeChanges } from '@xyflow/react';\n```\n\n### Define nodes and edges\n\nWe need to define initial nodes and edges. These will be the starting point for our flow.\n\n```jsx\nconst initialNodes = [\n  {\n    id: 'n1',\n    position: { x: 0, y: 0 },\n    data: { label: 'Node 1' },\n    type: 'input',\n  },\n  {\n    id: 'n2',\n    position: { x: 100, y: 100 },\n    data: { label: 'Node 2' },\n  },\n];\n\nconst initialEdges = [\n  {\n    id: 'n1-n2',\n    source: 'n1',\n    target: 'n2',\n  },\n];\n```\n\n### Initialize state\n\nIn our component, we'll call the `useState` hook to manage the state of our nodes and\nedges:\n\n```jsx {2-3}\nexport default function App() {\n  const [nodes, setNodes] = useState(initialNodes);\n  const [edges, setEdges] = useState(initialEdges);\n\n  return (\n    <div style={{ height: '100%', width: '100%' }}>\n      <ReactFlow>\n        <Background />\n        <Controls />\n      </ReactFlow>\n    </div>\n  );\n}\n```\n\n### Add event handlers\n\nWe need to create two event handlers:\n[`onNodesChange`](/api-reference/react-flow#onnodeschange) and\n[`onEdgesChange`](/api-reference/react-flow#onedgeschange). They will be used to update\nthe state of our nodes and edges when changes occur, such as dragging or deleting an\nelement. Go ahead and add these handlers to your component:\n\n```jsx\nconst onNodesChange = useCallback(\n  (changes) => setNodes((nodesSnapshot) => applyNodeChanges(changes, nodesSnapshot)),\n  [],\n);\nconst onEdgesChange = useCallback(\n  (changes) => setEdges((edgesSnapshot) => applyEdgeChanges(changes, edgesSnapshot)),\n  [],\n);\n```\n\n### Pass them to ReactFlow\n\nNow we can pass our nodes, edges, and event handlers to the `<ReactFlow />` component:\n\n```jsx {2-5}\n<ReactFlow\n  nodes={nodes}\n  edges={edges}\n  onNodesChange={onNodesChange}\n  onEdgesChange={onEdgesChange}\n  fitView\n>\n  <Background />\n  <Controls />\n</ReactFlow>\n```\n\n### Interactive flow\n\nAnd that's it! You now have a basic interactive flow 🎉\n\nWhen you drag or select a node, the `onNodesChange` handler is triggered. The\n`applyNodeChanges` function then uses these change events to update the current state of\nyour nodes. Here's how it all comes together. Try clicking and dragging a node to move it\naround and watch the UI update in real time.\n\n<RemoteCodeViewer route=\"learn/make-it-interactive-1\" framework=\"react\" aspectRatio=\"4\" />\n\n</Steps>\n\n## Handling connections\n\nOne last piece is missing: connecting nodes interactively. For this, we need to implement\nan [`onConnect`](/api-reference/react-flow#onconnect) handler.\n\n<Steps>\n### Create `onConnect` handler\n\nThe `onConnect` handler is called whenever a new connection is made between two nodes. We\ncan use the [`addEdge`](/api-reference/utils/add-edge) utility function to create a new\nedge and update the edge Array.\n\n```jsx\nconst onConnect = useCallback(\n  (params) => setEdges((edgesSnapshot) => addEdge(params, edgesSnapshot)),\n  [],\n);\n```\n\n### Pass it to ReactFlow\n\nNow we can pass the `onConnect` handler to the `<ReactFlow />` component:\n\n```jsx {6}\n<ReactFlow\n  nodes={nodes}\n  edges={edges}\n  onNodesChange={onNodesChange}\n  onEdgesChange={onEdgesChange}\n  onConnect={onConnect}\n  fitView\n>\n  <Background />\n  <Controls />\n</ReactFlow>\n```\n\n### Connectable flow\n\nTry to connect the two nodes by dragging from on handle to another one. The `onConnect`\nhandler will be triggered, and the new edge will be added to the flow. 🥳\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/make-it-interactive-2\" framework=\"react\" />\n\n</Steps>\n\n## Full code example 🏁\n\n<RemoteCodeViewer route=\"learn/make-it-interactive-2\" framework=\"react\" />\n\nWhat is happening here? Whenever React Flow triggers a change (node init, node drag, edge\nselect, etc.), the `onNodesChange` handler gets called. We export an `applyNodeChanges`\nhandler so that you don't need to handle the changes by yourself. The `applyNodeChanges`\nhandler returns an updated array of nodes that is your new nodes array. You now have an\ninteractive flow with the following capabilities:\n\n- selectable nodes and edges\n- draggable nodes\n- connectable nodes by dragging from one node handle to another\n- multi-selection area by pressing `shift` -- the default\n  [`selectionKeyCode`](/api-reference/react-flow#selectionkeycode)\n- multi-selection by pressing `cmd` -- the default\n  [`multiSelectionKeyCode`](/api-reference/react-flow#multiselectionkeycode)\n- removing selected elements by pressing `backspace` -- the default\n  [`deleteKeyCode`](/api-reference/react-flow#deletekeycode)\n\nIf you want to jump straight into creating your own application, we recommend checking out\nthe Customization section. Otherwise keep reading to learn more about React Flows\ncapabilities."
    },
    "learn/concepts/building-a-flow": {
      "name": "learn/concepts/building-a-flow",
      "title": "building-a-flow",
      "description": "Learn how to build your first static flow with React Flow.",
      "category": "learn",
      "sections": [
        "Creating the flow",
        "Add imports",
        "Render ReactFlow",
        "Empty flow",
        "Adding nodes",
        "Create node objects",
        "Add nodes to the flow",
        "Flow with nodes",
        "Adding edges",
        "Create an edge",
        "Label the edge",
        "Add edges to the flow",
        "Basic flow",
        "Full code example 🏁"
      ],
      "content": "import { Callout, Steps } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Building a Flow\n\nIn the following pages we will introduce you to the core concepts of React Flow and\nexplain how to create a basic interactive flow. A flow consists of\n[nodes](/api-reference/types/node), [edges](/api-reference/types/edge) and the viewport.\n\nTo follow along with this guide you will need to have a React project set up and install\nthe `@xyflow/react` package:\n\n```bash copy npm2yarn\nnpm install @xyflow/react\n```\n\n## Creating the flow\n\nLet's start by creating an empty flow with viewport\n[`<Controls />`](/api-reference/components/controls) and a dotted\n[`<Background />`](/api-reference/components/background).\n\n<Steps>\n### Add imports\nFirst, we need to import some basic components from the `@xyflow/react` package \nand the **css stylesheet**, which is **required** for React Flow to work:\n\n```jsx \"import '@xyflow/react/dist/style.css';\"\nimport { ReactFlow, Background, Controls } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n```\n\n### Render ReactFlow\n\nNow we create a React component, that renders our flow. The **width and height** on the\nparent container are **required** because React Flow uses these dimensions.\n\n```jsx \"height: '100%', width: '100%'\"\nexport default function App() {\n  return (\n    <div style={{ height: '100%', width: '100%' }}>\n      <ReactFlow>\n        <Background />\n        <Controls />\n      </ReactFlow>\n    </div>\n  );\n}\n```\n\n### Empty flow\n\nThat's it! You have created your first empty flow 🎉\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/building-a-flow-1\" framework=\"react\" />\n\n</Steps>\n\n## Adding nodes\n\nNow that the flow is set up, it's time to add nodes — each node represents an element in\nyour diagram with a specific position and content.\n\n<Steps> \n### Create node objects\n\nOutside of your React component, create an array of [node](/api-reference/types/node)\nobjects. Each node object needs a unique `id` and a `position`. Let's also add a label to\nthem:\n\n```jsx\nconst initialNodes = [\n  {\n    id: 'n1',\n    position: { x: 0, y: 0 },\n    data: { label: 'Node 1' },\n    type: 'input',\n  },\n  {\n    id: 'n2',\n    position: { x: 100, y: 100 },\n    data: { label: 'Node 2' },\n  },\n];\n```\n\n### Add nodes to the flow\n\nNow we can pass our `initialNodes` array to the `<ReactFlow />` component using the\n`nodes` prop:\n\n```jsx \"nodes={initialNodes}\"\n<ReactFlow nodes={initialNodes}>\n  <Background />\n  <Controls />\n</ReactFlow>\n```\n\n### Flow with nodes\n\nThis gives us a flow with two labeled nodes 🎉\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/building-a-flow-2\" framework=\"react\" />\n\n</Steps>\n\nWe have several built-in nodes that you can explore in the\n[node](/api-reference/types/node) reference. However, once you start building your own\napplication, you will want to use [custom nodes](/learn/customization/custom-nodes).\n\n## Adding edges\n\nNow that we have two nodes, let's connect them with an edge.\n\n<Steps>\n### Create an edge\n\nTo create an edge, we define an array of [edge](/api-reference/types/edge) objects. Each\nedge object needs to have an `id`, a `source` (where the edge begins), and a `target`\n(where it ends). In this example, we use the `id` values of the two nodes we created so\nfar (`n1` and `n2`) to define the edge:\n\n```js\nconst initialEdges = [\n  {\n    id: 'n1-n2',\n    source: 'n1',\n    target: 'n2',\n  },\n];\n```\n\nThis edge connects the node with `id: 'n1'` (the source) to the node with `id: 'n2'` (the\ntarget).\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/building-a-flow-3\" framework=\"react\" />\n\n### Label the edge\n\nLet's give this edge two properties that are built into React Flow, a `label` and a\n`type: \"step\"`.\n\n```jsx {6-7}\nconst initialEdges = [\n  {\n    id: 'n1-n2',\n    source: 'n1',\n    target: 'n2',\n    type: 'step',\n    label: 'connects with',\n  },\n];\n```\n\n### Add edges to the flow\n\nNow we can pass our `initialEdges` array to the `<ReactFlow />` component using the\n`edges` prop:\n\n```jsx \"edges={initialEdges}\"\n<ReactFlow nodes={initialNodes} edges={initialEdges}>\n  <Background />\n  <Controls />\n</ReactFlow>\n```\n\n### Basic flow\n\nCongratulations! You have completed a basic flow with nodes and edges! 🎉\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/building-a-flow-4\" framework=\"react\" />\n\n</Steps>\n\n## Full code example 🏁\n\n<RemoteCodeViewer route=\"learn/building-a-flow-4\" framework=\"react\" />\n\nYou took your first steps in React Flow! You might have realized that you can't drag or\notherwise interact with nodes. On the next page you'll learn how to make the flow\ninteractive."
    },
    "learn/concepts/built-in-components": {
      "name": "learn/concepts/built-in-components",
      "title": "built-in-components",
      "description": "React Flow comes with several built-in components. Here's an overview of the minimap, controls, background, and panel components.",
      "category": "learn",
      "sections": [
        "MiniMap",
        "Controls",
        "Background",
        "Panel",
        "Advanced"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\n\n# Built-In Components\n\nReact Flow comes with several built-in components that can be passed as children to the [`<ReactFlow />`](/api-reference/react-flow) component.\n\n## MiniMap\n\nThe [`MiniMap`](/api-reference/components/minimap) provides a bird’s-eye view of your flowgraph, making navigation easier, especially for larger flows. You can customize the appearance of nodes in the minimap by providing a nodeColor function.\n\n<RemoteCodeViewer aspectRatio=\"2\" route=\"learn/mini-map\" framework=\"react\" />\n\n## Controls\n\nReact Flow comes with a set of customizable [`Controls`](/api-reference/components/controls) for the viewport. You can zoom in and out, fit the viewport and toggle if the user can move, select and edit the nodes.\n\n<RemoteCodeViewer aspectRatio=\"2\" route=\"learn/controls\" framework=\"react\" />\n\n## Background\n\nThe [`Background`](/api-reference/components/background) component adds a visual grid pattern to your flowgraph, helping users maintain orientation. You can choose from different pattern variants, or if you need more advanced customization, you can explore the [source](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx) code to implement your own pattern.\n\n<RemoteCodeViewer aspectRatio=\"2\" route=\"learn/background\" framework=\"react\" />\n\n## Panel\n\nThe [`Panel`](/api-reference/components/panel) component allows you to add fixed overlays to your flowgraph, perfect for titles, controls, or any other UI elements that should remain stationary.\n\n<RemoteCodeViewer aspectRatio=\"2\" route=\"learn/panel\" framework=\"react\" />\n\n## Advanced\n\nFor more advanced use cases and customization, we have even more built-in components you can check out in the [API components overview](/api-reference/components)"
    },
    "learn/concepts/terms-and-definitions": {
      "name": "learn/concepts/terms-and-definitions",
      "title": "terms-and-definitions",
      "description": "Learn about the basic terms and definitions of React Flow",
      "category": "learn",
      "sections": [
        "Nodes",
        "Handles",
        "Edges",
        "Selection",
        "Connection line",
        "Viewport"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\n\n# Overview\n\nAt its core, React Flow is about creating interactive flowgraphs -- a collection of nodes\nconnected by edges. To help you understand the terminology we use throughout the\ndocumentation, let's take a look at the example flow below.\n\n<RemoteCodeViewer route=\"learn/basic-terms\" framework=\"react\" />\n\n### Nodes\n\nReact Flow has a few default node types out of the box, but customization is where the\nmagic of React Flow truly happens. You can design your nodes to work exactly the way you\nneed them to—whether that’s embedding interactive form elements, displaying dynamic data\nvisualizations, or even incorporating multiple connection handles. React Flow lays the\nfoundation, and your imagination does the rest.\n\nWe have a guide on creating your own [Custom Nodes](/learn/customization/custom-nodes) and\nyou can find all the options for customizing your nodes in the\n[Node](/api-reference/types/node) reference.\n\n### Handles\n\nA handle (also known as a “port” in other libraries) is the attachment point where an edge\nconnects to a node. By default, they appear as grey circles on the top, bottom, left, or\nright sides of a node. But they are just `div` elements, and can be positioned and styled\nany way you’d like. When creating a custom node, you can include as many handles as\nneeded. For more information, refer to the [Handle](/learn/customization/handles) page.\n\n### Edges\n\nEdges connect nodes. Every edge needs a target and a source node. React Flow comes with\nfour built-in [edge types](/examples/edges/edge-types): `default` (bezier), `smoothstep`,\n`step`, and `straight`. An edge is a SVG path that can be styled with CSS and is\ncompletely customizable. If you are using multiple handles, you can reference them\nindividually to create multiple connections for a node.\n\nLike custom nodes, you can also customize edges. Things that people do with custom edges\ninclude:\n\n- Adding buttons to remove edges\n- Custom routing behavior\n- Complex styling or interactions that cannot be solved with just one SVG path\n\nFor more information, refer to the [Edges](/learn/customization/custom-edges) page.\n\n### Selection\n\nYou can select an edge or a node by clicking on it. If you want to select multiple\nnodes/edges via clicking, you can hold the `Meta/Control` key and click on multiple\nelements to select them. If you want to change the keyboard key for multiselection to\nsomething else, you can use the\n[`multiSelectionKeyCode`](/api-reference/react-flow#multiselectionkeycode) prop.\n\nYou can also select multiple edges/nodes by holding down `Shift` and dragging the mouse to\nmake a selection box. When you release the mouse, any node or edge that falls within the\nselection box is selected. If you want to change the keyboard key for this behavior, you\ncan use the [`selectionKeyCode`](/api-reference/react-flow#selectionkeycode) prop.\n\nSelected nodes and edges are elevated (assigned a higher `zIndex` than other elements), so\nthat they are shown on top of all the other elements.\n\nFor default edges and nodes, selection is shown by a darker stroke/border than usual. If\nyou are using a custom node/edge, you can use the `selected` prop to customize selection\nappearance inside your custom component.\n\n### Connection line\n\nReact Flow has built-in functionality that allows you to click and drag from one handle to\nanother to create a new edge. While dragging, the placeholder edge is referred to as a\nconnection line. The connection line comes with the same four built-in types as edges and\nis customizable. You can find the props for configuring the connection line in the\n[connection props](/api-reference/react-flow#connection-line-props) reference.\n\n### Viewport\n\nAll of React Flow is contained within the viewport. Each node has an x- and y-coordinate,\nwhich indicates its position within the viewport. The viewport has x, y, and zoom values.\nWhen you drag the pane, you change the x and y coordinates. When you zoom in or out, you\nalter the zoom level."
    },
    "learn/concepts/the-viewport": {
      "name": "learn/concepts/the-viewport",
      "title": "The Viewport",
      "description": "Learn how to customize the panning and zooming behavior of React Flow.",
      "category": "learn",
      "sections": [
        "Viewport configurations",
        "Default viewport controls",
        "Design tool viewport controls"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\n\n# Panning and Zooming\n\nThe default pan and zoom behavior of React Flow is inspired by\n[slippy maps](https://wiki.openstreetmap.org/wiki/Slippy_map). You pan by dragging your\npointer and zoom by scrolling. You can customize this behavior easily with the\n[interaction](/api-reference/react-flow#interaction-props) and\n[keyboard](/api-reference/react-flow#keyboard-props) props on the `<ReactFlow />`\ncomponent.\n\n## Viewport configurations\n\nHere we will list and explain some configurations that other tools use.\n\n### Default viewport controls\n\nAs mentioned above, the ReactFlow default controls are as follows:\n\n- `pan:` pointer drag\n- `zoom:` pinch or scroll\n- `select:` shift + pointer drag\n\n<RemoteCodeViewer aspectRatio='3' route=\"learn/zoom-pan\" framework=\"react\" />\n\n### Design tool viewport controls\n\nIf you prefer figma/sketch/design tool controls you can set\n[`panOnScroll`](/api-reference/react-flow#panonscroll) and\n[`selectionOnDrag`](/api-reference/react-flow#selectionondrag) to `true` and\n[`panOnDrag`](/api-reference/react-flow#panondrag) to `false`:\n\n- `pan:` scroll, middle / right mouse drag, space + pointer drag\n- `zoom:` pinch or cmd + scroll\n- `select:` pointer drag\n\n<RemoteCodeViewer aspectRatio='3' route=\"learn/zoom-pan-2\" framework=\"react\" />\n\nIn this example we also set `selectionMode=\"partial\"` to be able to add nodes to a\nselection that are only partially selected."
    },
    "learn/customization/custom-edges": {
      "name": "learn/customization/custom-edges",
      "title": "Edges",
      "description": "",
      "category": "learn",
      "sections": [
        "A basic custom edge",
        "Create the component",
        "Create `edgeTypes`",
        "Pass the `edgeTypes` prop",
        "Use the new edge type",
        "Flow with a custom edge",
        "Custom SVG edge paths"
      ],
      "content": "import { Callout, Steps } from 'nextra/components';\nimport { Image } from 'xy-shared';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Custom Edges\n\nLike [custom nodes](/learn/customization/custom-nodes), parts of a custom edge\nin React Flow are just React components. That means you can render anything you\nwant along an edge! This guide shows you how to implement a custom edge with\nsome additional controls. For a comprehensive reference of props available for\ncustom edges, see the [Edge](/api-reference/types/edge-props) reference.\n\n## A basic custom edge\n\nAn edge isn't much use to us if it doesn't render a path between two connected\nnodes. These paths are always SVG-based and are typically rendered using the\n[`<BaseEdge />`](/api-reference/components/base-edge) component. To calculate\nthe actual SVG path to render, React Flow comes with some handy utility functions:\n\n- [`getBezierPath`](/api-reference/utils/get-bezier-path)\n- [`getSimpleBezierPath`](/api-reference/utils/get-simple-bezier-path)\n- [`getSmoothStepPath`](/api-reference/utils/get-smooth-step-path)\n- [`getStraightPath`](/api-reference/utils/get-straight-path)\n\nTo kickstart our custom edge, we'll just render a straight path between the\nsource and target.\n\n<Steps>\n\n### Create the component\n\nWe start by creating a new React component called `CustomEdge`. Then we render\nthe [`<BaseEdge />`](/api-reference/components/base-edge) component with the\ncalculated path. This gives us a straight edge that behaves the same as the\nbuilt-in default [edge version](/api-reference/types/edge#default-edge-types)\n`\"straight\"`.\n\n```jsx\nimport { BaseEdge, getStraightPath } from '@xyflow/react';\n\nexport function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {\n  const [edgePath] = getStraightPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n  });\n\n  return (\n    <>\n      <BaseEdge id={id} path={edgePath} />\n    </>\n  );\n}\n```\n\n### Create `edgeTypes`\n\nOutside of our component, we define an `edgeTypes` object.\nWe name our new edge type `\"custom-edge\"` and assign the `CustomEdge` component\nwe just created to it.\n\n```jsx\nconst edgeTypes = {\n  'custom-edge': CustomEdge,\n};\n```\n\n### Pass the `edgeTypes` prop\n\nTo use it, we also need to update the\n[`edgeTypes`](/api-reference/react-flow#edge-types) prop on the\n`<ReactFlow />` component.\n\n```jsx \"edgeTypes={edgeTypes}\"\nexport function Flow() {\n  return <ReactFlow edgeTypes={edgeTypes} />;\n}\n```\n\n### Use the new edge type\n\nAfter defining the `edgeTypes` object, we can use our new custom edge by setting\nthe `type` field of an edge to `\"custom-edge\"`.\n\n```jsx {6}\nconst initialEdges = [\n  {\n    id: 'e1',\n    source: 'n1',\n    target: 'n2',\n    type: 'custom-edge',\n  },\n];\n```\n\n### Flow with a custom edge\n\n<RemoteCodeViewer route=\"learn/custom-edge\" framework=\"react\" />\n\n</Steps>\n\n## Custom SVG edge paths\n\nAs discussed previously, if you want to make a custom edge in React Flow, you\nhave to use either of the four path creation functions discussed above\n(e.g [`getBezierPath`](/api-reference/utils/get-bezier-path)). However if you\nwant to make some other path shape like a Sinusoidal edge or some other edge\ntype then you will have to make the edge path yourself.\n\nThe edge path we get from functions like\n[`getBezierPath`](/api-reference/utils/get-bezier-path) is just a path string\nwhich we pass into the `path` prop of the `<BaseEdge />` component. It contains\nthe necessary information needed in order to draw that path, like where it\nshould start from, where it should curve, where it should end, etc. A simple\nstraight path string between two points `(x1, y1)` to `(x2, y2)` would look like:\n\n```jsx\nM x1 y1 L x2 y2\n```\n\nAn SVG path is a concatenated list of commands like `M`, `L`, `Q`, etc, along\nwith their values. Some of these commands are listed below, along with their\nsupported values.\n\n- `M x1 y1` is the Move To command which moves the current point to the x1, y1\n  coordinate.\n- `L x1 y1` is the Line To command which draws a line from the current point to\n  x1, y1 coordinate.\n- `Q x1 y1 x2 y2` is the Quadratic Bezier Curve command which draws a bezier\n  curve from the current point to the x2, y2 coordinate. x1, y1 is the control\n  point of the curve which determines the curviness of the curve.\n\nWhenever we want to start a path for our custom edge, we use the `M` command to\nmove our current point to `sourceX, sourceY` which we get as props in the custom\nedge component. Then based on the shape we want, we will use other commands like\n`L`(to make lines), `Q`(to make curves) and then finally end our path at\n`targetX, targetY` which we get as props in the custom edge component.\n\nIf you want to learn more about SVG paths, you can check out\n[SVG-Path-Editor](https://yqnn.github.io/svg-path-editor/). You can paste any\nSVG path there and analyze individual path commands via an intuitive UI.\n\nHere is an example with two types of custom edge paths, a Step edge and a\nSinusoidal edge. You should look at the Step edge first to get your hands dirty\nwith custom SVG paths since it's simple, and then look at how the Sinusoidal\nedge is made. After going through this example, you will have the necessary\nknowledge to make custom SVG paths for your custom edges.\n\n<RemoteCodeViewer route=\"learn/custom-edge-path\" framework=\"react\" />"
    },
    "learn/customization/custom-nodes": {
      "name": "learn/customization/custom-nodes",
      "title": "Nodes",
      "description": "",
      "category": "learn",
      "sections": [
        "Implementing a custom node",
        "Create the component",
        "Initialize nodeTypes",
        "Pass nodeTypes to React Flow",
        "Update node definitions",
        "Flow with custom node",
        "Full code example 🏁"
      ],
      "content": "import { Callout, Steps } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Custom Nodes\n\nA powerful feature of React Flow is the ability to create custom nodes. This gives you the\nflexibility to render anything you want within your nodes. We generally recommend creating\nyour own custom nodes rather than relying on built-in ones. With custom nodes, you can add\nas many source and target [handles](/learn/customization/handles) as you like—or even\nembed form inputs, charts, and other interactive elements.\n\nIn this section, we'll walk through creating a custom node featuring an input field that\nupdates text elsewhere in your application. For further examples, we recommend checking\nout our [Custom Node Example](/examples/nodes/custom-node).\n\n## Implementing a custom node\n\nTo create a custom node, all you need to do is create a React component. React Flow will\nautomatically wrap it in an interactive container that injects essential props like the\nnode's id, position, and data, and provides functionality for selection, dragging, and\nconnecting handles. For a full overview on all available node props, see the\n[Node](/api-reference/types/node-props) reference.\n\n<Steps>\n### Create the component\n\nLet's dive into an example by creating a custom node called `TextUpdaterNode`. For this,\nwe've added a simple input field with a change handler.\n\n```jsx\nexport function TextUpdaterNode(props) {\n  const onChange = useCallback((evt) => {\n    console.log(evt.target.value);\n  }, []);\n\n  return (\n    <div className=\"text-updater-node\">\n      <div>\n        <label htmlFor=\"text\">Text:</label>\n        <input id=\"text\" name=\"text\" onChange={onChange} className=\"nodrag\" />\n      </div>\n    </div>\n  );\n}\n```\n\n### Initialize nodeTypes\n\nYou can add a new node type to React Flow by adding it to the `nodeTypes` prop like below.\nWe define the `nodeTypes` outside of the component to prevent re-renderings.\n\n```jsx\nconst nodeTypes = {\n  textUpdater: TextUpdaterNode,\n};\n```\n\n### Pass nodeTypes to React Flow\n\n```jsx {4}\n<ReactFlow\n  nodes={nodes}\n  edges={edges}\n  nodeTypes={nodeTypes}\n  onNodesChange={onNodesChange}\n  onEdgesChange={onEdgesChange}\n  fitView\n/>\n```\n\n### Update node definitions\n\nAfter defining your new node type, you can use it by specifying the `type` property on\nyour node definition:\n\n```jsx {4}\nconst nodes = [\n  {\n    id: 'node-1',\n    type: 'textUpdater',\n    position: { x: 0, y: 0 },\n    data: { value: 123 },\n  },\n];\n```\n\n### Flow with custom node\n\nAfter putting all together and adding some basic styles we get a custom node that prints\ntext to the console:\n\n<RemoteCodeViewer aspectRatio=\"4\" route=\"learn/custom-node\" framework=\"react\" />\n\n</Steps>\n\n## Full code example 🏁\n\n<RemoteCodeViewer route=\"learn/custom-node\" framework=\"react\" />\n\nTo enable your custom node to connect with other nodes, check out the\n[Handles](/learn/customization/handles) page to learn how to add source and target\nhandles."
    },
    "learn/customization/edge-labels": {
      "name": "learn/customization/edge-labels",
      "title": "edge-labels",
      "description": "This guide shows you how to render custom edge labels onto custom edges in React Flow.",
      "category": "learn",
      "sections": [
        "Adding an edge label"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\nimport { Callout } from 'nextra/components';\nimport { Image } from 'xy-shared';\n\n# Edge Labels\n\nOne of the more common uses for [custom edges](/learn/customization/custom-edges) is rendering some controls or info\nalong an edge's path. In React Flow we call that a _custom edge label_ and unlike the\nedge path, edge labels can be any React component!\n\n## Adding an edge label\n\nTo render a custom edge label we must wrap it in the\n[`<EdgeLabelRenderer />`](/api-reference/components/edge-label-renderer) component.\nThis allows us to render the labels outside of the SVG world where the edges life.\nThe edge label renderer is a portal to a single container that _all_ edge labels are rendered into.\n\nLet's add a button to our custom edge that can be used to delete the edge it's\nattached to:\n\n```jsx\nimport {\n  BaseEdge,\n  EdgeLabelRenderer,\n  getStraightPath,\n  useReactFlow,\n} from '@xyflow/react';\n\nexport default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {\n  const { deleteElements } = useReactFlow();\n  const [edgePath] = getStraightPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n  });\n\n  return (\n    <>\n      <BaseEdge id={id} path={edgePath} />\n      <EdgeLabelRenderer>\n        <button onClick={() => deleteElements({ edges: [{ id }] })}>delete</button>\n      </EdgeLabelRenderer>\n    </>\n  );\n}\n```\n\nIf we try to use this edge now, we'll see that the button is rendered in the\ncentre of the flow (it might be hidden behind \"Node A\"). Because of the edge\nlabel portal, we'll need to do some extra work to position the button ourselves.\n\n<Image\n  src=\"/img/learn/edge-label-renderer-position.png\"\n  alt=\"A screen shot of a simple flow. The edge label renderer is highlighted in\n  the DOM inspector and the button is rendered in the centre of the flow.\"\n/>\n\nFortunately, the path utils we've already seen can help us with this! Along with\nthe SVG path to render, these functions also return the `x` and `y` coordinates\nof the path's midpoint. We can then use these coordinates to translate our custom\nedge label's into the right position!\n\n```jsx\nexport default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {\n  const { deleteElements } = useReactFlow();\n  const [edgePath, labelX, labelY] = getStraightPath({ ... });\n\n  return (\n    ...\n        <button\n          style={{\n            position: 'absolute',\n            transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,\n            pointerEvents: 'all',\n          }}\n          className=\"nodrag nopan\"\n          onClick={() => deleteElements({ edges: [{ id }] })}\n        >\n    ...\n  );\n}\n```\n\n<Callout type=\"info\">\n  To make sure our edge labels are interactive and not just for presentation, it\n  is important to add `pointer-events: all` to the label's style. This will ensure\n  that the label is clickable.\n\nAnd just like with interactive controls in custom nodes, we need to remember\nto add the `nodrag` and `nopan` classes to the label to stop mouse events from\ncontrolling the canvas.\n\n</Callout>\n\nHere's an interactive example with our updated custom edge. Clicking the delete\nbutton will remove that edge from the flow. Creating a new edge will use the\ncustom node.\n\n<RemoteCodeViewer route=\"learn/custom-edge-2\" framework=\"react\" />"
    },
    "learn/customization/handles": {
      "name": "learn/customization/handles",
      "title": "handles",
      "description": "This guide shows you how to add handles to custom nodes in React Flow.",
      "category": "learn",
      "sections": [
        "Creating a node with handles",
        "Using multiple handles",
        "Custom handles",
        "Typeless handles",
        "Dynamic handles",
        "Custom handle styles",
        "Styling handles when connecting",
        "Hiding handles"
      ],
      "content": "import { RemoteCodeViewer } from 'xy-shared/server';\nimport { Callout } from 'nextra/components';\n\n# Handles\n\nHandles are the connection points on [nodes](/learn/concepts/terms-and-definitions#nodes)\nin React Flow. Our built-in nodes include one source and one target handle, but you can\ncustomize your nodes with as many different handles as you need.\n\n## Creating a node with handles\n\nTo create a [custom node](/learn/customization/custom-nodes) with handles, you can use the\n[`<Handle />`](/api-reference/components/handle) component provided by React Flow. This\ncomponent allows you to define source and target handles for your custom nodes. Here's an\nexample of how to implement a custom node with two handles:\n\n```jsx {7-8}\nimport { Position, Handle } from '@xyflow/react';\n\nexport function CustomNode() {\n  return (\n    <div className=\"custom-node\">\n      <div>Custom Node Content</div>\n      <Handle type=\"source\" position={Position.Top} />\n      <Handle type=\"target\" position={Position.Bottom} />\n    </div>\n  );\n}\n```\n\n## Using multiple handles\n\nIf you want to use multiple source or target handles in your custom node, you need to\nspecify each handle with a unique `id`. This allows React Flow to differentiate between\nthe handles when connecting edges.\n\n```jsx /id=\"a\"/ /id=\"b\"/\n  <Handle type=\"target\" position={Position.Top} />\n  <Handle type=\"source\" position={Position.Right} id=\"a\" />\n  <Handle type=\"source\" position={Position.Bottom} id=\"b\" />\n```\n\nTo connect an edge to a specific handle of a node, use the properties `sourceHandle` (for\nthe edge's starting point) and `targetHandle` (for the edge's ending point). By defining\n`sourceHandle` or `targetHandle` with the appropriate handle `id`, you instruct React Flow\nto attach the edge to that specific handle, ensuring that connections are made where you\nintend.\n\n```js \"sourceHandle: 'a'\" \"sourceHandle: 'b'\"\nconst initialEdges = [\n  { id: 'n1-n2', source: 'n1', sourceHandle: 'a', target: 'n2' },\n  { id: 'n1-n3', source: 'n1', sourceHandle: 'b', target: 'n3' },\n];\n```\n\nIn this case, the source node is `n1` for both handles but the handle `id`s are different.\nOne comes from handle id `a` and the other one from `b`. Both edges also have different\ntarget nodes:\n\n<RemoteCodeViewer route=\"learn/custom-node-2\" framework=\"react\" />\n\nBy default React Flow positions a handle in the center of the specified side. If you want\nto display multiple handles on a side, you can adjust the position via inline styles or\noverwrite the default CSS and position it on your own.\n\n## Custom handles\n\nYou can use any custom component as a Handle by wrapping it with the\n[`<Handle />`](/api-reference/components/handle) component. Follow these steps to\nintegrate your custom component:\n\n1. Wrap your custom component with [`<Handle />`](/api-reference/components/handle)\n   component.\n2. Hide the built-in [`<Handle />`](/api-reference/components/handle) appearance by\n   setting `border` and `background` to `none`.\n3. Set the `width`and `height` of [`<Handle />`](/api-reference/components/handle) to\n   match your custom component.\n4. Style the child component with `pointer-events: none`.\n5. Then, reposition the child custom component using CSS position properties like\n   `top, left` if necessary to position it perfectly inside the\n   [`<Handle />`](/api-reference/components/handle) component.\n\nThis example shows a Material UI icon `ArrowCircleRightIcon` used as a Handle.\n\n```jsx\nimport { Handle, Position } from '@xyflow/react';\nimport ArrowCircleRightIcon from '@mui/icons-material/ArrowCircleRight';\n\nexport function CustomNode() {\n  return (\n    <div className=\"react-flow__node-default\">\n      <Handle\n        position={Position.Right}\n        type=\"source\"\n        style={{\n          background: 'none',\n          border: 'none',\n          width: '1em',\n          height: '1em',\n        }}\n      >\n        <ArrowCircleRightIcon\n          style={{\n            pointerEvents: 'none',\n            fontSize: '1em',\n            left: 0,\n            position: 'absolute',\n          }}\n        />\n      </Handle>\n      Custom Node\n    </div>\n  );\n}\n```\n\n## Typeless handles\n\nIf you want to create a handle that does not have a specific type (source or target), you\ncan set [connectionMode](/api-reference/react-flow#connectionmode) to `Loose` in the\n`<ReactFlow />` component. This allows the handle to be used for both incoming and\noutgoing connections.\n\n## Dynamic handles\n\nIf you are programmatically changing the position or number of handles in your custom\nnode, you need to update the node internals with the\n[`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook.\n\n## Custom handle styles\n\nSince the handle is a div, you can use CSS to style it or pass a style prop to customize a\nHandle. You can see this in the\n[Add Node On Edge Drop](/examples/nodes/add-node-on-edge-drop) and\n[Simple Floating Edges](/examples/edges/simple-floating-edges) examples.\n\n### Styling handles when connecting\n\nThe handle receives the additional class names `connecting` when the connection line is\nabove the handle and `valid` if the connection is valid. You can find an example which\nuses these classes [here](/examples/interaction/validation).\n\n### Hiding handles\n\nIf you need to hide a handle for some reason, you must use `visibility: hidden` or\n`opacity: 0` instead of `display: none`. This is important because React Flow needs to\ncalculate the dimensions of the handle to work properly and using `display: none` will\nreport a width and height of `0`!"
    },
    "learn/customization/theming": {
      "name": "learn/customization/theming",
      "title": "theming",
      "description": "React Flow comes with a minimal default theme. It's common to overwrite the default styles with your own CSS or use third-party libraries like TailwindCSS.",
      "category": "learn",
      "sections": [
        "Default styles",
        "Built in dark and light mode",
        "Customizing with `style` props",
        "CSS variables",
        "Overriding built-in classes",
        "Third-party solutions",
        "TailwindCSS"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Theming\n\nReact Flow has been built with deep customization in mind. Many of our users\nfully transform the look and feel of React Flow to match their own brand or design\nsystem. This guide will introduce you to the different ways you can customize\nReact Flow's appearance.\n\n## Default styles\n\nReact Flow's default styles are enough to get going with the built-in nodes. They\nprovide some sensible defaults for styles like padding, border radius, and animated\nedges. You can see what they look like below:\n\n<RemoteCodeViewer\n  route=\"examples/styling/default-style\"\n  framework=\"react\"\n/>\n\nYou'll typically load these default styles by importing them in you `App.jsx`\nfile or other entry point:\n\n```js\nimport '@xyflow/react/dist/style.css';\n```\n\nWithout dipping into [custom nodes](/examples/nodes/custom-node) and\n[edges](/examples/edges/custom-edges), there are three ways you can style\nReact Flow's basic look:\n\n- Passing inline styles through `style` props\n- Overriding the built-in classes with custom CSS\n- Overriding the CSS variables React Flow uses\n\n### Built in dark and light mode\n\nYou can choose one of the built-in color modes by using the `colorMode` prop ('dark', 'light' or 'system') as seen in the [dark mode example](/examples/styling/dark-mode).\n\n```jsx\nimport ReactFlow from '@xyflow/react';\n\nexport default function Flow() {\n  return <ReactFlow colorMode=\"dark\" nodes={[...]} edges={[...]} />\n}\n```\n\nWhen you use the `colorMode` prop, React Flow adds a class to the root element (`.react-flow`) that you can use to style your flow based on the color mode:\n\n```css\n.dark .react-flow__node {\n  background: #777;\n  color: white;\n}\n\n.light .react-flow__node {\n  background: white;\n  color: #111;\n}\n```\n\n### Customizing with `style` props\n\nThe easiest way to start customizing the look and feel of your flows is to use\nthe `style` prop found on many of React Flow's components to inline your own\nCSS.\n\n```jsx\nimport ReactFlow from '@xyflow/react'\n\nconst styles = {\n  background: 'red',\n  width: '100%',\n  height: 300,\n};\n\nexport default function Flow() {\n  return <ReactFlow style={styles} nodes={[...]} edges={[...]} />\n}\n```\n\n### CSS variables\n\nIf you don't want to replace the default styles entirely but just want to tweak\nthe overall look and feel, you can override some of the CSS variables we use\nthroughout the library. For an example of how to use these CSS variables, check out our [Feature Overview](/examples/overview) example.\n\nThese variables are mostly self-explanatory. Below is a table of all the variables\nyou might want to tweak and their default values for reference:\n\n| Variable name                                         | Default                             |\n| :---------------------------------------------------- | :---------------------------------- |\n| `--xy-edge-stroke-default`                            | `#b1b1b7`                           |\n| `--xy-edge-stroke-width-default`                      | `1`                                 |\n| `--xy-edge-stroke-selected-default`                   | `#555`                              |\n| `--xy-connectionline-stroke-default`                  | `#b1b1b7`                           |\n| `--xy-connectionline-stroke-width-default`            | `1`                                 |\n| `--xy-attribution-background-color-default`           | `rgba(255, 255, 255, 0.5)`          |\n| `--xy-minimap-background-color-default`               | `#fff`                              |\n| `--xy-background-pattern-dots-color-default`          | `#91919a`                           |\n| `--xy-background-pattern-line-color-default`          | `#eee`                              |\n| `--xy-background-pattern-cross-color-default`         | `#e2e2e2`                           |\n| `--xy-node-color-default`                             | `inherit`                           |\n| `--xy-node-border-default`                            | `1px solid #1a192b`                 |\n| `--xy-node-background-color-default`                  | `#fff`                              |\n| `--xy-node-group-background-color-default`            | `rgba(240, 240, 240, 0.25)`         |\n| `--xy-node-boxshadow-hover-default`                   | `0 1px 4px 1px rgba(0, 0, 0, 0.08)` |\n| `--xy-node-boxshadow-selected-default`                | `0 0 0 0.5px #1a192b`               |\n| `--xy-handle-background-color-default`                | `#1a192b`                           |\n| `--xy-handle-border-color-default`                    | `#fff`                              |\n| `--xy-selection-background-color-default`             | `rgba(0, 89, 220, 0.08)`            |\n| `--xy-selection-border-default`                       | `1px dotted rgba(0, 89, 220, 0.8)`  |\n| `--xy-controls-button-background-color-default`       | `#fefefe`                           |\n| `--xy-controls-button-background-color-hover-default` | `#f4f4f4`                           |\n| `--xy-controls-button-color-default`                  | `inherit`                           |\n| `--xy-controls-button-color-hover-default`            | `inherit`                           |\n| `--xy-controls-button-border-color-default`           | `#eee`                              |\n| `--xy-controls-box-shadow-default`                    | `0 0 2px 1px rgba(0, 0, 0, 0.08)`   |\n| `--xy-resize-background-color-default`                | `#3367d9`                           |\n\nThese variables are used to define the _defaults_ for the various elements of\nReact Flow. This means they can still be overridden by inline styles or custom\nclasses on a per-element basis. If you want to override these variables, you can do so\nby adding:\n\n```css\n.react-flow {\n  --xy-node-background-color-default: #ff5050;\n}\n```\n\n<Callout type=\"warning\">\n  Be aware that these variables are defined under `.react-flow` and under\n  `:root`.\n</Callout>\n\n### Overriding built-in classes\n\nSome consider heavy use of inline styles to be an anti-pattern. In that case,\nyou can override the built-in classes that React Flow uses with your own CSS.\nThere are many classes attached to all sorts of elements in React Flow, but the\nones you'll likely want to override are listed below:\n\n| Class name                         | Description                                                                              |\n| :--------------------------------- | :--------------------------------------------------------------------------------------- |\n| `.react-flow`                      | The outermost container                                                                  |\n| `.react-flow__renderer`            | The inner container                                                                      |\n| `.react-flow__zoompane`            | Zoom & pan pane                                                                          |\n| `.react-flow__selectionpane`       | Selection pane                                                                           |\n| `.react-flow__selection`           | User selection                                                                           |\n| `.react-flow__edges`               | The element containing all edges in the flow                                             |\n| `.react-flow__edge`                | Applied to each [`Edge`](/api-reference/types/edge) in the flow                          |\n| `.react-flow__edge.selected`       | Added to an [`Edge`](/api-reference/types/edge) when selected                            |\n| `.react-flow__edge.animated`       | Added to an [`Edge`](/api-reference/types/edge) when its `animated` prop is `true`       |\n| `.react-flow__edge.updating`       | Added to an [`Edge`](/api-reference/types/edge) while it gets updated via `onReconnect`  |\n| `.react-flow__edge-path`           | The SVG `<path />` element of an [`Edge`](/api-reference/types/edge)                     |\n| `.react-flow__edge-text`           | The SVG `<text />` element of an [`Edge`](/api-reference/types/edge) label               |\n| `.react-flow__edge-textbg`         | The SVG `<text />` element behind an [`Edge`](/api-reference/types/edge) label           |\n| `.react-flow__connection`          | Applied to the current connection line                                                   |\n| `.react-flow__connection-path`     | The SVG `<path />` of a connection line                                                  |\n| `.react-flow__nodes`               | The element containing all nodes in the flow                                             |\n| `.react-flow__node`                | Applied to each [`Node`](/api-reference/types/node) in the flow                          |\n| `.react-flow__node.selected`       | Added to a [`Node`](/api-reference/types/node) when selected.                            |\n| `.react-flow__node-default`        | Added when [`Node`](/api-reference/types/node) type is `\"default\"`                       |\n| `.react-flow__node-input`          | Added when [`Node`](/api-reference/types/node) type is `\"input\"`                         |\n| `.react-flow__node-output`         | Added when [`Node`](/api-reference/types/node) type is `\"output\"`                        |\n| `.react-flow__nodesselection`      | Nodes selection                                                                          |\n| `.react-flow__nodesselection-rect` | Nodes selection rect                                                                     |\n| `.react-flow__handle`              | Applied to each [`<Handle />`](/api-reference/components/handle) component               |\n| `.react-flow__handle-top`          | Applied when a handle's [`Position`](/api-reference/types/position) is set to `\"top\"`    |\n| `.react-flow__handle-right`        | Applied when a handle's [`Position`](/api-reference/types/position) is set to `\"right\"`  |\n| `.react-flow__handle-bottom`       | Applied when a handle's [`Position`](/api-reference/types/position) is set to `\"bottom\"` |\n| `.react-flow__handle-left`         | Applied when a handle's [`Position`](/api-reference/types/position) is set to `\"left\"`   |\n| `.connectingfrom`                  | Added to a Handle when a connection line is above a handle.                              |\n| `.connectingto`                    | Added to a Handle when a connection line is above a handle.                              |\n| `.valid`                           | Added to a Handle when a connection line is above **and** the connection is valid        |\n| `.react-flow__background`          | Applied to the [`<Background />`](/api-reference/components/background) component        |\n| `.react-flow__minimap`             | Applied to the [`<MiniMap />`](/api-reference/components/minimap) component              |\n| `.react-flow__controls`            | Applied to the [`<Controls />`](/api-reference/components/controls) component            |\n\n<Callout type=\"warning\">\n  Be careful if you go poking around the source code looking for other classes\n  to override. Some classes are used internally and are required in order for\n  the library to be functional. If you replace them you may end up with\n  unexpected bugs or errors!\n</Callout>\n\n## Third-party solutions\n\nYou can choose to opt-out of React Flow's default styling altogether and use a\nthird-party styling solution instead. If you want to do this, you must make sure\nyou still import the base styles.\n\n```js\nimport '@xyflow/react/dist/base.css';\n```\n\n<Callout type=\"warning\">\n  These base styles are **required** for React Flow to function correctly. If\n  you don't import them or you override them with your own styles, some things\n  might not work as expected!\n</Callout>\n\n<RemoteCodeViewer\n  route=\"examples/styling/base-style\"\n  framework=\"react\"\n/>\n\n### TailwindCSS\n\nCustom nodes and edges are just React components, and you can use any styling\nsolution you'd like to style them. For example, you might want to use\n[Tailwind](https://tailwindcss.com/) to style your nodes:\n\n```jsx\nfunction CustomNode({ data }) {\n  return (\n    <div className=\"px-4 py-2 shadow-md rounded-md bg-white border-2 border-stone-400\">\n      <div className=\"flex\">\n        <div className=\"rounded-full w-12 h-12 flex justify-center items-center bg-gray-100\">\n          {data.emoji}\n        </div>\n        <div className=\"ml-2\">\n          <div className=\"text-lg font-bold\">{data.name}</div>\n          <div className=\"text-gray-500\">{data.job}</div>\n        </div>\n      </div>\n\n      <Handle\n        type=\"target\"\n        position={Position.Top}\n        className=\"w-16 !bg-teal-500\"\n      />\n      <Handle\n        type=\"source\"\n        position={Position.Bottom}\n        className=\"w-16 !bg-teal-500\"\n      />\n    </div>\n  );\n}\n```\n\n<Callout type=\"warning\">\n  If you want to overwrite default styles, make sure to import Tailwinds entry\n  point after React Flows base styles.\n</Callout>\n\n```js\nimport '@xyflow/react/dist/style.css';\nimport 'tailwind.css';\n```\n\nFor a complete example of using Tailwind with React Flow, check out\n[the example](/examples/styling/tailwind)!"
    },
    "learn/customization/utility-classes": {
      "name": "learn/customization/utility-classes",
      "title": "utility-classes",
      "description": "",
      "category": "learn",
      "sections": [
        "`nodrag`",
        "`nopan`",
        "`nowheel`"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Utility Classes\n\nReact Flow provides several built-in utility CSS classes to help you fine-tune how\ninteractions work within your custom elements.\n\n## `nodrag`\n\nAdding the class `nodrag` to an element ensures that interacting with it doesn't trigger a\ndrag. This is particularly useful for elements like buttons or inputs that should not\ninitiate a drag operation when clicked.\n\nNodes have a `drag` class name in place by default. However, this class name can affect\nthe behaviour of the event listeners inside your custom nodes. To prevent unexpected\nbehaviours, add a `nodrag` class name to elements with an event listener. This prevents\nthe default drag behavior as well as the default node selection behavior when elements\nwith this class are clicked.\n\n```tsx\nexport default function CustomNode(props: NodeProps) {\n  return (\n    <div>\n      <input className=\"nodrag\" type=\"range\" min={0} max={100} />\n    </div>\n  );\n}\n```\n\n## `nopan`\n\nIf an element in the canvas does not stop mouse events from propagating, clicking and\ndragging that element will pan the viewport. Adding the \"nopan\" class prevents this\nbehavior and this prop allows you to change the name of that class.\n\n```tsx\nexport default function CustomNode(props: NodeProps) {\n  return (\n    <div className=\"nopan\">\n      <p>fixed content...</p>\n    </div>\n  );\n}\n```\n\n## `nowheel`\n\nIf your custom element contains scrollable content, you can apply the `nowheel` class.\nThis disables the canvas' default pan behavior when you scroll inside your custom node,\nensuring that only the content scrolls instead of moving the entire canvas.\n\n```tsx\nexport default function CustomNode(props: NodeProps) {\n  return (\n    <div className=\"nowheel\" style={{ overflow: 'auto' }}>\n      <p>Scrollable content...</p>\n    </div>\n  );\n}\n```\n\nApplying these utility classes helps you control interaction on a granular level. You can\ncustomize these class names inside React Flow's\n[style props](/api-reference/react-flow/#style-props).\n\n<Callout type=\"info\">\n  When creating your own custom nodes, you will also need to remember to style them!\n  Unlike the built-in nodes, custom nodes have no default styles, so feel free to use any\n  styling method you prefer, such as [Tailwind CSS](/examples/styling/tailwind).\n</Callout>"
    },
    "learn/layouting/layouting": {
      "name": "learn/layouting/layouting",
      "title": "layouting",
      "description": "",
      "category": "learn",
      "sections": [
        "Layouting nodes",
        "Dagre",
        "D3-Hierarchy",
        "D3-Force",
        "Elkjs",
        "Honourable Mentions",
        "Routing Edges"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Overview\n\nWe regularly get asked how to handle layouting in React Flow. We have not implemented our\nown layouting solution yet, but will present some viable external libraries on this page.\nWe'll split things up into resources for layouting nodes and resources for routing edges.\n\nYou can test out some of the layouting options in our\n[playground](https://play.reactflow.dev/) or have a look at the\n[examples](/examples#layout) we've put together.\n\nTo start let's put together a simple example flow that we can use as a base for testing\nout the different layouting options.\n\n<RemoteCodeViewer route=\"learn/layouting-flow-1-empty\" framework=\"react\" />\n\nEach of the examples that follow will be built on this empty flow. Where possible we've\ntried to keep the examples confined to just one `index.js` file so it's easy for you to\ncompare how they're set up.\n\n## Layouting nodes\n\nFor layouting nodes, there are a few third-party libraries that we think are worth\nchecking out:\n\n| Library                                            | Dynamic node sizes | Sub-flow layouting | Edge routing | Bundle size                                                                                                                                   |\n| -------------------------------------------------- | ------------------ | ------------------ | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Dagre](https://github.com/dagrejs/dagre)          | Yes                | Yes¹               | No           | <a href=\"https://pkg-size.dev/@dagrejs/dagre\"><img src=\"https://pkg-size.dev/badge/bundle/39882\" title=\"Bundle size for @dagrejs/dagre\"/></a> |\n| [D3-Hierarchy](https://github.com/d3/d3-hierarchy) | No                 | No                 | No           | <a href=\"https://pkg-size.dev/d3-hierarchy\"><img src=\"https://pkg-size.dev/badge/bundle/14697\" title=\"Bundle size for d3-hierarchy\"/></a>     |\n| [D3-Force](https://github.com/d3/d3-force)         | Yes                | No                 | No           | <a href=\"https://pkg-size.dev/d3-force\"><img src=\"https://pkg-size.dev/badge/bundle/15623\" title=\"Bundle size for d3-force\"/></a>             |\n| [ELK](https://github.com/kieler/elkjs)             | Yes                | Yes                | Yes          | <a href=\"https://pkg-size.dev/elkjs\"><img src=\"https://pkg-size.dev/badge/bundle/1455420\" title=\"Bundle size for elkjs\"/></a>                 |\n\n¹ Dagre currently has an [open issue](https://github.com/dagrejs/dagre/issues/238) that\nprevents it from laying out sub-flows correctly if any nodes in the sub-flow are connected\nto nodes outside the sub-flow.\n\nWe've loosely ordered these options from simplest to most complex, where dagre is largely\na drop-in solution and elkjs is a full-blown highly configurable layouting engine. Below,\nwe'll take a look at a brief example of how each of these libraries can be used with React\nFlow. For dagre and elkjs specifically, we have some separate examples you can refer back\nto [here](/examples/layout/dagre) and [here](/examples/layout/elkjs).\n\n### Dagre\n\n- Repo: https://github.com/dagrejs/dagre\n- Docs: https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n\nDagre is a simple library for layouting directed graphs. It has minimal configuration\noptions and a focus on speed over choosing the most optimal layout. If you need to\norganize your flows into a tree, _we highly recommend dagre_.\n\n<RemoteCodeViewer route=\"learn/layouting-flow-2-dagre\" framework=\"react\" />\n\nWith no effort at all we get a well-organized tree layout! Whenever `getLayoutedElements`\nis called, we'll reset the dagre graph and set the graph's direction (either left-to-right\nor top-to-bottom) based on the `direction` prop. Dagre needs to know the dimensions of\neach node in order to lay them out, so we iterate over our list of nodes and add them to\ndagre's internal graph.\n\nAfter laying out the graph, we'll return an object with the layouted nodes and edges. We\ndo this by mapping over the original list of nodes and updating each node's position\naccording to node stored in the dagre graph.\n\nDocumentation for dagre's configuration options can be found\n[here](https://github.com/dagrejs/dagre/wiki#configuring-the-layout), including properties\nto set for spacing and alignment.\n\n### D3-Hierarchy\n\n- Repo: https://github.com/d3/d3-hierarchy\n- Docs: https://d3js.org/d3-hierarchy\n\nWhen you know your graph is a tree with a single root node, d3-hierarchy can provide a\nhandful of interesting layouting options. While the library can layout a simple tree just\nfine, it also has layouting algorithms for tree maps, partition layouts, and enclosure\ndiagrams.\n\n<RemoteCodeViewer route=\"learn/layouting-flow-3-d3-hierarchy\" framework=\"react\" />\n\n<Callout>\n  D3-hierarchy expects your graphs to have a single root node, so it won't work in all\n  cases. It's also important to note that d3-hierarchy assigns the same width and height\n  to _all_ nodes when calculating the layout, so it's not the best choice if you're\n  displaying lots of different node types.\n</Callout>\n\n### D3-Force\n\n- Repo: https://github.com/d3/d3-force\n- Docs: https://d3js.org/d3-force\n\nFor something more interesting than a tree, a force-directed layout might be the way to\ngo. D3-Force is a physics-based layouting library that can be used to position nodes by\napplying different forces to them.\n\nAs a consequence, it's a little more complicated to configure and use compared to dagre\nand d3-hierarchy. Importantly, d3-force's layouting algorithm is iterative, so we need a\nway to keep computing the layout across multiple renders.\n\nFirst, let's see what it does:\n\n<RemoteCodeViewer route=\"learn/layouting-flow-4-d3-force\" framework=\"react\" />\n\nWe've changed our `getLayoutedElements` to a hook called `useLayoutedElements` instead.\nAdditionally, instead of passing in the nodes and edges explicitly, we'll use get\n`getNodes` and `getEdges` functions from the `useReactFlow` hook. This is important when\ncombined with the store selector in `initialized` because it will prevent us from\nreconfiguring the simulation any time the nodes update.\n\nThe simulation is configured with a number of different forces applied so you can see how\nthey interact: play around in your own code to see how you want to configure those forces.\nYou can find the documentation and some different examples of d3-force\n[here](https://d3js.org/d3-force).\n\n<Callout>\n  <strong>Rectangular collisions</strong>\n  D3-Force has a built-in collision force, but it assumes nodes are circles. We've thrown\n  together a custom force in `collision.js` that uses a similar algorithm but accounts for\n  our rectangular nodes instead. Feel free to steal it or let us know if you have any\n  suggestions for improvements!\n</Callout>\n\nThe tick function progresses the simulation by one step and then updates React Flow with\nthe new node positions. We've also included a demonstration on how to handle node dragging\nwhile the simulation is running: if your flow isn't interactive you can ignore that part!\n\n<Callout>\n  For larger graphs, computing the force layout every render forever is going to incur a\n  big performance hit. In this example we have a simple toggle to turn the layouting on\n  and off, but you might want to come up with some other approach to only compute the\n  layout when necessary.\n</Callout>\n\n### Elkjs\n\n- Repo: https://github.com/kieler/elkjs\n- Docs: https://eclipse.dev/elk/reference.html (good luck!)\n\nElkjs is certainly the most configurable option available, but it's also the most\ncomplicated. Elkjs is a Java library that's been ported to JavaScript, and it provides a\nhuge number of options for configuring the layout of your graph.\n\n<RemoteCodeViewer route=\"learn/layouting-flow-6-elkjs\" framework=\"react\" />\n\nAt it's most basic we can compute layouts similar to dagre, but because the layouting\nalgorithm runs asynchronously we need to create a `useLayoutedElements` hook similar to\nthe one we created for d3-force.\n\n<Callout>\n  <strong>The ELK reference is your new best friend</strong>\n  We don't often recommend elkjs because it's complexity makes it difficult for us to\n  support folks when they need it. If you do decide to use it, you'll want to keep the\n  original [Java API reference](https://eclipse.dev/elk/reference.html) handy.\n</Callout>\n\nWe've also included a few examples of some of the other layouting algorithms available,\nincluding a non-interactive force layout.\n\n### Honourable Mentions\n\nOf course, we can't go through every layouting library out there: we'd never work on\nanything else! Here are some other libraries we've come across that might be worth taking\na look at:\n\n- If you want to use dagre or d3-hierarchy but need to support nodes with different\n  dimensions, both [d3-flextree](https://github.com/klortho/d3-flextree) and\n  [entitree-flex](https://github.com/codeledge/entitree-flex) look promising.\n\n  You can find an example of how to use entitree-flex with React Flow\n  [here](/examples/layout/entitree-flex).\n\n- [Cola.js](https://github.com/tgdwyer/WebCola) looks like a promising option for\n  so-called \"constraint-based\" layouts. We haven't had time to properly investigate it\n  yet, but it looks like you can achieve results similar to d3-force but with a lot more\n  control.\n\n## Routing Edges\n\nIf you don't have any requirements for edge routing, you can use one of the layouting\nlibraries above to position nodes and let the edges fall wherever they may. Otherwise,\nyou'll want to look into some libraries and techniques for edge routing.\n\nYour options here are more limited than for node layouting, but here are some resources we\nthought looked promising:\n\n- [react-flow-smart-edge](https://github.com/tisoap/react-flow-smart-edge)\n- [Routing Orthogonal Diagram Connectors in JavaScript](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70)\n\nIf you do explore some custom edge routing options, consider contributing back to the\ncommunity by writing a blog post or creating a library!\n\nOur [editable edge Pro Example](/examples/edges/editable-edge) could also be used as a\nstarting point for implementing a custom edge that can be routed along a specific path."
    },
    "learn/layouting/sub-flows": {
      "name": "learn/layouting/sub-flows",
      "title": "sub-flows",
      "description": "Learn how to use sub flows to group nodes together in a flow.",
      "category": "learn",
      "sections": [
        "Adding child nodes",
        "Using child specific options",
        "Edge rendering behavior",
        "Using a default node type as a parent"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Sub Flows\n\n<Callout type=\"info\">\n  **Deprecation of `parentNode` property!** We have renamed the `parentNode` option to\n  `parentId` in version 11.11.0. The old property is still supported but will be removed\n  in version 12.\n</Callout>\n\nA sub flow is a flow inside a node. It can be a separate flow or a flow that is connected\nwith other nodes outside of its parent. This feature can also be used for grouping nodes.\nIn this part of the docs we are going to build a flow with sub flows and show you the\nchild node specific options.\n\n<Callout type=\"warning\">\n  <strong>Order of Nodes</strong>\n  It's important that your parent nodes appear before their children in the `nodes`/\n  `defaultNodes` array to get processed correctly.\n</Callout>\n\n### Adding child nodes\n\nIf you want to add a node as a child of another node you need to use the `parentId` (this\nwas called `parentNode` in previous versions) option (you can find a list of all options\nin the [node options section](/api-reference/types/node)). Once we do that, the child node\nis positioned relative to its parent. A position of `{ x: 0, y: 0 }` is the top left\ncorner of the parent.\n\nIn this example we are setting a fixed width and height of the parent node by passing the\nstyle option. Additionally, we set the child extent to `'parent'` so that we can't move\nthe child nodes out of the parent node.\n\n<RemoteCodeViewer route=\"learn/sub-flows\" framework=\"react\" />\n\n### Using child specific options\n\nWhen you move the parent node you can see that the child nodes move, too. Adding a node to\nanother node with the `parentId` option, just does one thing: It positions it relatively\nto its parent. The child node is not really a child markup-wise. You can drag or position\nthe child outside of its parent (when the `extent: 'parent'` option is not set) but when\nyou move the parent, the child moves with it.\n\nIn the example above we are using the `group` type for the parent node but you can use any\nother type as well. The `group` type is just a convenience node type that has no handles\nattached.\n\nNow we are going to add some more nodes and edges. As you can see, we can connect nodes\nwithin a group and create connections that go from a sub flow to an outer node:\n\n<RemoteCodeViewer route=\"learn/sub-flows-2\" framework=\"react\" />\n\n### Edge rendering behavior\n\nEdges are rendered below nodes by default, and this behavior applies to both normal nodes\nand group nodes. However, edges connected to a node with a parent are rendered above\nnodes.\n\nIf you want to customize the z-index of edges, you can use the `zIndex` option. For\nexample:\n\n```tsx\nconst defaultEdgeOptions = { zIndex: 1 };\n\n<ReactFlow defaultEdgeOptions={defaultEdgeOptions} />;\n```\n\nThis allows you to render edges above nodes or adjust their stacking order as needed.\n\n### Using a default node type as a parent\n\nLet's remove the label of node B and add some child nodes. In this example you can see\nthat you can use one of the default node types as parents, too. We also set the child\nnodes to `draggable: false` so that they are not draggable anymore.\n\n<RemoteCodeViewer route=\"learn/sub-flows-3\" framework=\"react\" />"
    },
    "learn/troubleshooting/common-errors": {
      "name": "learn/troubleshooting/common-errors",
      "title": "common-errors",
      "description": "Troubleshooting and fixes for common issues with React Flow.",
      "category": "learn",
      "sections": [
        "Warning: Seems like you have not used zustand provider as an ancestor.",
        "It looks like you have created a new nodeTypes or edgeTypes object.",
        "Node type not found. Using fallback type \"default\".",
        "The React Flow parent container needs a width and a height to render the graph.",
        "Only child nodes can use a parent extent.",
        "Can't create edge. An edge needs a source and a target.",
        "The old edge with id=\"some-id\" does not exist.",
        "Couldn't create edge for source/target handle id: \"some-id\"; edge id: \"some-id\".",
        "Marker type doesn't exist.",
        "Handle: No node id found.",
        "I get an error when building my app with webpack 4.",
        "Mouse events aren't working consistently when my nodes contain a `<canvas />` element.",
        "Edges are not displaying.",
        "Edges are not displaying correctly."
      ],
      "content": "# Common Errors\n\nimport { Callout } from 'nextra/components';\n\nThis guide contains warnings and errors that can occur when using React Flow. We are also\nadding common questions and pitfalls that we collect from our\n[Discord Server](https://discord.gg/RVmnytFmGW),\n[Github Issues](https://github.com/xyflow/xyflow/issues) and\n[Github Discussions](https://github.com/xyflow/xyflow/discussions).\n\n<div id=\"001\" />\n### Warning: Seems like you have not used zustand provider as an ancestor.\n\nThis usually happens when:\n\n**A:** You have two different versions of @reactflow/core installed.<br /> **B:** You are\ntrying to access the internal React Flow state outside of the React Flow context.\n\n#### Solution for A\n\nUpdate reactflow and @reactflow/node-resizer (in case you are using it), remove\nnode_modules and package-lock.json and reinstall the dependencies.\n\n#### Solution for B\n\nA possible solution is to wrap your component with a\n[`<ReactFlowProvider />`](/api-reference/react-flow-provider) or move the code that is\naccessing the state inside a child of your React Flow instance.\n\n<Callout type=\"error\">This will cause an error:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nfunction FlowWithoutProvider(props) {\n  // cannot access the state here\n  const reactFlowInstance = useReactFlow();\n\n  return <ReactFlow {...props} />;\n}\n\nexport default FlowWithoutProvider;\n```\n\n<Callout type=\"error\">This will cause an error, too:</Callout>\n\n```jsx\nimport { ReactFlow, ReactFlowProvider } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nfunction Flow(props) {\n  // still cannot access the state here\n  // only child components of this component can access the state\n  const reactFlowInstance = useReactFlow();\n\n  return (\n    <ReactFlowProvider>\n      <ReactFlow {...props} />\n    </ReactFlowProvider>\n  );\n}\n\nexport default FlowWithProvider;\n```\n\n<Callout type=\"info\">This works:</Callout>\n\nAs soon as you want to access the internal state of React Flow (for example by using the\n`useReactFlow` hook), you need to wrap your component with a `<ReactFlowProvider />`. Here\nthe wrapping is done outside of the component:\n\n```jsx\nimport { ReactFlow, ReactFlowProvider } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nfunction Flow(props) {\n  // you can access the internal state here\n  const reactFlowInstance = useReactFlow();\n\n  return <ReactFlow {...props} />;\n}\n\n// wrapping with ReactFlowProvider is done outside of the component\nfunction FlowWithProvider(props) {\n  return (\n    <ReactFlowProvider>\n      <Flow {...props} />\n    </ReactFlowProvider>\n  );\n}\n\nexport default FlowWithProvider;\n```\n\n<div id=\"002\" />\n### It looks like you have created a new nodeTypes or edgeTypes object.\n\nIf this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component\nor memoize them.\n\nThis warning appears when the `nodeTypes` or `edgeTypes` properties change after the\ninitial render. The `nodeTypes` or `edgeTypes` should only be changed dynamically in very\nrare cases. Usually, they are defined once, along with all the types you use in your\napplication. It can happen easily that you are defining the nodeTypes or edgeTypes object\ninside of your component render function, which will cause React Flow to re-render every\ntime your component re-renders.\n\n<Callout type=\"error\">Causes a warning:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nimport MyCustomNode from './MyCustomNode';\n\nfunction Flow(props) {\n  // new object being created on every render\n  // causing unnecessary re-renders\n  const nodeTypes = {\n    myCustomNode: MyCustomNode,\n  };\n\n  return <ReactFlow nodeTypes={nodeTypes} />;\n}\n\nexport default Flow;\n```\n\n<Callout type=\"info\">Recommended implementation:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport MyCustomNode from './MyCustomNode';\n\n// defined outside of the component\nconst nodeTypes = {\n  myCustomNode: MyCustomNode,\n};\n\nfunction Flow(props) {\n  return <ReactFlow nodeTypes={nodeTypes} />;\n}\n\nexport default Flow;\n```\n\n<Callout type=\"info\">Alternative implementation:</Callout>\n\nYou can use this if you want to change your nodeTypes dynamically without causing\nunnecessary re-renders.\n\n```jsx\nimport { useMemo } from 'react';\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nimport MyCustomNode from './MyCustomNode';\n\nfunction Flow(props) {\n  const nodeTypes = useMemo(\n    () => ({\n      myCustomNode: MyCustomNode,\n    }),\n    [],\n  );\n\n  return <ReactFlow nodeTypes={nodeTypes} />;\n}\n\nexport default Flow;\n```\n\n<div id=\"003\" />\n### Node type not found. Using fallback type \"default\".\n\nThis usually happens when you specify a custom node type for one of your nodes but do not\npass the correct nodeTypes property to React Flow. The string for the type option of your\ncustom node needs to be exactly the same as the key of the nodeTypes object.\n\n<Callout type=\"error\">Doesn't work:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nimport MyCustomNode from './MyCustomNode';\n\nconst nodes = [\n  {\n    id: 'mycustomnode',\n    type: 'custom',\n    // ...\n  },\n];\n\nfunction Flow(props) {\n  // nodeTypes property is missing, so React Flow cannot find the custom node component to render\n  return <ReactFlow nodes={nodes} />;\n}\n```\n\n<Callout type=\"error\">Doesn't work either:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nimport MyCustomNode from './MyCustomNode';\n\nconst nodes = [\n  {\n    id: 'mycustomnode',\n    type: 'custom',\n    // ...\n  },\n];\n\nconst nodeTypes = {\n  Custom: MyCustomNode,\n};\n\nfunction Flow(props) {\n  // node.type and key in nodeTypes object are not exactly the same (capitalized)\n  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;\n}\n```\n\n<Callout type=\"info\">This does work:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nimport MyCustomNode from './MyCustomNode';\n\nconst nodes = [\n  {\n    id: 'mycustomnode',\n    type: 'custom',\n    // ...\n  },\n];\n\nconst nodeTypes = {\n  custom: MyCustomNode,\n};\n\nfunction Flow(props) {\n  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;\n}\n```\n\n<div id=\"004\" />\n### The React Flow parent container needs a width and a height to render the graph.\n\nUnder the hood, React Flow measures the parent DOM element to adjust the renderer. If you\ntry to render React Flow in a regular div without a height, we cannot display the graph.\nIf you encounter this warning, you need to make sure that your wrapper component has some\nCSS attached to it so that it gets a fixed height or inherits the height of its parent.\n\n<Callout type=\"error\">This will cause the warning:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nfunction Flow(props) {\n  return (\n    <div>\n      <ReactFlow {...props} />\n    </div>\n  );\n}\n```\n\n<Callout type=\"info\">Working example:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\n\nfunction Flow(props) {\n  return (\n    <div style={{ height: 800 }}>\n      <ReactFlow {...props} />\n    </div>\n  );\n}\n```\n\n<div id=\"005\" />\n### Only child nodes can use a parent extent.\n\nThis warning appears when you are trying to add the `extent` option to a node that does\nnot have a parent node. Depending on what you are trying to do, you can remove the\n`extent` option or specify a `parentNode`.\n\n<Callout type=\"error\">Does show a warning:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nconst nodes = [\n  {\n    id: 'mycustomnode',\n    extent: 'parent',\n    // ...\n  },\n];\n\nfunction Flow(props) {\n  return <ReactFlow nodes={nodes} />;\n}\n```\n\n<Callout type=\"info\">Warning resolved:</Callout>\n\n```jsx import { ReactFlow } from '@xyflow/react';\nconst nodes = [\n  {\n    id: 'mycustomnode',\n    parentNode: 'someothernode',\n    extent: 'parent',\n    // ...\n  },\n];\n\nfunction Flow(props) {\n  return <ReactFlow nodes={nodes} />;\n}\n```\n\n<div id=\"006\" />\n### Can't create edge. An edge needs a source and a target.\n\nThis happens when you do not pass a `source` and a `target` option to the edge object.\nWithout the source and target, the edge cannot be rendered.\n\n<Callout type=\"error\">Will show a warning:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n\nconst nodes = [\n  /* ... */\n];\n\nconst edges = [\n  {\n    nosource: '1',\n    notarget: '2',\n  },\n];\n\nfunction Flow(props) {\n  return <ReactFlow nodes={nodes} edges={edges} />;\n}\n```\n\n<Callout type=\"info\">This works:</Callout>\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\n\nconst nodes = [\n  /* ... */\n];\n\nconst edges = [\n  {\n    source: '1',\n    target: '2',\n  },\n];\n\nfunction Flow(props) {\n  return <ReactFlow nodes={nodes} edges={edges} />;\n}\n```\n\n<div id=\"007\" />\n### The old edge with id=\"some-id\" does not exist.\n\nThis can happen when you are trying to [reconnect an edge](/examples/edges/reconnect-edge)\nbut the edge you want to update is already removed from the state. This is a very rare\ncase. Please see the [Reconnect Edge example](/examples/edges/reconnect-edge) for\nimplementation details.\n\n<div id=\"008\" />\n### Couldn't create edge for source/target handle id: \"some-id\"; edge id: \"some-id\".\n\nThis can happen if you are working with multiple handles and a handle is not found by its\n`id` property or if you haven't\n[updated the node internals after adding or removing handles](/api-reference/hooks/use-update-node-internals)\nprogrammatically. Please see the [Custom Node Example](/examples/nodes/custom-node) for an\nexample of working with multiple handles.\n\n<div id=\"009\" />\n### Marker type doesn't exist.\n\nThis warning occurs when you are trying to specify a marker type that is not built into\nReact Flow. The existing marker types are documented\n[here](/api-reference/types/edge#edgemarker).\n\n<div id=\"010\" />\n### Handle: No node id found.\n\nThis warning occurs when you try to use a `<Handle />` component outside of a custom node\ncomponent.\n\n### I get an error when building my app with webpack 4.\n\nIf you're using webpack 4, you'll likely run into an error like this:\n\n```\nERROR in /node_modules/@reactflow/core/dist/esm/index.js 16:19\nModule parse failed: Unexpected token (16:19)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n```\n\nReact Flow is a modern JavaScript code base and makes use of lots of newer JavaScript\nfeatures. By default, webpack 4 does not transpile your code and it doesn't know how to\nhandle React Flow.\n\nYou need to add a number of babel plugins to your webpack config to make it work:\n\n```sh npm2yarn copy\nnpm i --save-dev babel-loader@8.2.5 @babel/preset-env @babel/preset-react @babel/plugin-proposal-optional-chaining @babel/plugin-proposal-nullish-coalescing-operator\n```\n\nand configure the loader like this:\n\n```js\n{\n  test: /node_modules[\\/\\\\]@?reactflow[\\/\\\\].*.js$/,\n  use: {\n    loader: 'babel-loader',\n    options: {\n      presets: ['@babel/preset-env', \"@babel/preset-react\"],\n      plugins: [\n        \"@babel/plugin-proposal-optional-chaining\",\n        \"@babel/plugin-proposal-nullish-coalescing-operator\",\n      ]\n    }\n  }\n}\n```\n\n<Callout type=\"info\">\n  If you're using webpack 5, you don't need to do anything! React Flow will work out of\n  the box.\n</Callout>\n\n### Mouse events aren't working consistently when my nodes contain a `<canvas />` element.\n\nIf you’re using a `<canvas />` element inside your custom node, you might run into\nproblems with seemingly incorrect coordinates in mouse events from the canvas.\n\nReact Flow uses CSS transforms to scale nodes as you zoom in and out. However, from the\nDOM’s perspective, the element is still the same size. This can cause problems if you have\nevent listeners that want to calculate the mouse position relative to the canvas element.\n\nTo remedy this in event handlers you control, you can scale your computed relative\nposition by `1 / zoom` where `zoom` is the current zoom level of the flow. To get the\ncurrent zoom level, you can use the `getZoom` method from the\n[`useReactFlow`](/api-reference/hooks/use-react-flow) hook.\n\n### Edges are not displaying.\n\nIf your edges are not displaying in React Flow, this might be due to one of the following\nreasons:\n\n- You have not imported the React Flow stylesheet. If you haven't imported it, you can\n  import it like `import '@xyflow/react/dist/style.css';`.\n- If you have replaced your default nodes with a custom node, check if that custom node\n  has appropriate `source/target` handles in the custom node component. An edge cannot be\n  made without a handle.\n- If you use an external styling library like Tailwind or Bulma, ensure it doesn't\n  override the edge styles. For example, sometimes styling libraries override the\n  `.react-flow__edges` SVG selector with `overflow: hidden`, which hides the edges.\n- If you are using an async operation like a request to the backend, make sure to call the\n  `updateNodeInternals` function returned by the\n  [`useUpdateNodeInternal`](/api-reference/hooks/use-update-node-internals) hook after the\n  async operation so React Flow updates the handle position internally.\n\n### Edges are not displaying correctly.\n\nIf your edges are not rendering as they should, this could be due to one of the following\nreasons:\n\n- If you want to hide your handles, do not use `display: none` to hide them. Use either\n  `opacity: 0` or `visibility: hidden`.\n- If edges are not connected to the correct handle, check if you have added more than one\n  handle of the same type(`source` or `target`) in your custom node component. If that is\n  the case, assign IDs to them. Multiple handles of the same kind on a node need to have\n  distinguishable IDs so that React Flow knows which handle an edge corresponds to.\n- If you are changing the position of the handles (via reordering, etc.), make sure to\n  call the `updateNodeInternals` function returned by the\n  [`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook after so\n  React Flow knows to update the handle position internally.\n- If you are using a custom edge and want your edge to go from the source handle to a\n  target handle, make sure to correctly pass the `sourceX, sourceY, targetX, and targetY`\n  props you get from the custom edge component in the edge path creation function(e.g.,\n  [`getBezierPath`](/api-reference/utils/get-bezier-path), etc.). `sourceX, sourceY`, and\n  `targetX, targetY` represent the `x,y` coordinates for the source and target handle,\n  respectively.\n- If the custom edge from the source or target side is not going towards the handle as\n  expected (entering or exiting from a handle at a weird angle), make sure to pass the\n  `sourcePosition` and `targetPosition` props you get from the custom edge component in\n  the edge path creation function(e.g.,\n  [`getBezierPath`](/api-reference/utils/get-bezier-path)). Passing the source/target\n  handle position in the path creation function is necessary for the edge to start or end\n  properly at a handle."
    },
    "learn/troubleshooting/migrate-to-v10": {
      "name": "learn/troubleshooting/migrate-to-v10",
      "title": "Migrate to v10",
      "description": "Use this guide to migrate from React Flow v9 to v10.",
      "category": "learn",
      "sections": [
        "New Features",
        "Breaking Changes",
        "1. ~~Elements~~ - Nodes and Edges",
        "1.1. Controlled `nodes` and `edges`",
        "1.2 Uncontrolled `defaultNodes` and `defaultEdges`",
        "2. Memoize your custom `nodeTypes` and `edgeTypes`",
        "3. ~~Redux~~ - Zustand",
        "4. ~~onLoad~~ - onInit",
        "5. ~~paneMoveable~~ - panOnDrag",
        "6. ~~useZoomPanHelper transform~~ - unified in `useReactFlow`",
        "7. ~~isHidden~~ - hidden",
        "8. ~~arrowHeadType~~ ~~markerEndId~~ - markerStart / markerEnd",
        "9. ~~ArrowHeadType~~ - MarkerType",
        "10. Attribution"
      ],
      "content": "# Migrate to React Flow v10\n\nimport { Callout } from 'nextra/components';\n\n<Callout type=\"info\">\n  You can find the docs for old versions of React Flow here:\n  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),\n  [v9](https://v9.reactflow.dev)\n</Callout>\n\nWelcome to React Flow v10! With the major version update, there are coming many new features but also some breaking changes.\n\n## New Features\n\n- [**Sub Flows**](/learn/layouting/sub-flows): You can now add nodes to a parent node and create groups and nested flows\n- **Node Type 'group'**: A new node type without handles that can be used as a group node\n- **Touch Device Support**: It is now possible to connect nodes on touch devices\n- **Fit View on Init**: You can use the new `fitView` prop to fit the initial view\n- **Key Handling**: Not only single keys but also multiple keys and key combinations are possible now\n- [**useKeyPress hook**](/api-reference/hooks/use-key-press): A util hook for handling keyboard events\n- [**useReactFlow hook**](/api-reference/hooks/use-react-flow): Returns a React Flow instance that exposes functions to manipulate the flow\n- **[useNodes](/api-reference/hooks/use-nodes), [useEdges](/api-reference/hooks/use-edges) and [useViewport](/api-reference/hooks/use-viewport) hooks**: Hooks for receiving nodes, edges and the viewport\n- **Edge Marker**: More options to configure the start and end markers of an edge\n\n## Breaking Changes\n\nTLDR:\n\n- Split the `elements` array into `nodes` and `edges` arrays and implement `onNodesChange` and `onEdgesChange` handlers (detailed guide in the [core concepts section](/learn/concepts/core-concepts))\n- Memoize your custom `nodeTypes` and `edgeTypes`\n- Rename `onLoad` to `onInit`\n- Rename `paneMoveable` to `panOnDrag`\n- Rename `useZoomPanHelper` to `useReactFlow` (and `setTransform` to `setViewport`)\n- Rename node and edge option `isHidden` to `hidden`\n\nDetailed explanation of breaking changes:\n\n### 1. ~~Elements~~ - Nodes and Edges\n\nWe saw that a lot of people struggle with the semi controlled `elements` prop. It was always a bit messy to sync the local user state with the internal state of React Flow. Some of you used the internal store that was never documented and always a kind of hacky solution. For the new version we offer two ways to use React Flow - uncontrolled and controlled.\n\n### 1.1. Controlled `nodes` and `edges`\n\nIf you want to have the full control and use nodes and edges from your local state or your store, you can use the `nodes`, `edges` props in combination with the `onNodesChange` and `onEdgesChange` handlers. You need to implement these handlers for an interactive flow (if you are fine with just pan and zoom you don't need them). You'll receive a change when a node(s) gets initialized, dragged, selected or removed. This means that you always know the exact position and dimensions of a node or if it's selected for example. We export the helper functions `applyNodeChanges` and `applyEdgeChanges` that you should use to apply the changes.\n\n#### Old API\n\n```jsx\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, removeElements, addEdge } from 'react-flow-renderer';\n\nconst initialElements = [\n  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },\n  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },\n  { id: 'e1-2', source: '1', target: '2' },\n];\n\nconst BasicFlow = () => {\n  const [elements, setElements] = useState(initialElements);\n  const onElementsRemove = useCallback(\n    (elementsToRemove) =>\n      setElements((els) => removeElements(elementsToRemove, els)),\n    [],\n  );\n  const onConnect = useCallback((connection) =>\n    setElements((es) => addEdge(connection, es)),\n  );\n\n  return (\n    <ReactFlow\n      elements={elements}\n      onElementsRemove={onElementsRemove}\n      onConnect={onConnect}\n    />\n  );\n};\n\nexport default BasicFlow;\n```\n\n#### New API\n\n```jsx\nimport { useState, useCallback } from 'react';\nimport {\n  ReactFlow,\n  applyNodeChanges,\n  applyEdgeChanges,\n  addEdge,\n} from 'react-flow-renderer';\n\nconst initialNodes = [\n  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },\n  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },\n];\n\nconst initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];\n\nconst BasicFlow = () => {\n  const [nodes, setNodes] = useState(initialNodes);\n  const [edges, setEdges] = useState(initialEdges);\n\n  const onNodesChange = useCallback(\n    (changes) => setNodes((ns) => applyNodeChanges(changes, ns)),\n    [],\n  );\n  const onEdgesChange = useCallback(\n    (changes) => setEdges((es) => applyEdgeChanges(changes, es)),\n    [],\n  );\n  const onConnect = useCallback((connection) =>\n    setEdges((eds) => addEdge(connection, eds)),\n  );\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      onConnect={onConnect}\n    />\n  );\n};\n\nexport default BasicFlow;\n```\n\nYou can also use the new hooks `useNodesState` and `useEdgesState` for a quick start:\n\n```js\nconst [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\nconst [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n```\n\nrelated changes:\n\n- `onElementsClick` ->`onNodeClick` and `onEdgeClick`\n- `onElementsRemove` -> replaced by the `onNodesChange` and `onEdgesChange` handler\n\n### 1.2 Uncontrolled `defaultNodes` and `defaultEdges`\n\nThe easiest way to get started is to use the `defaultNodes` and `defaultEdges` props. When you set these props, all actions are handled internally. You don't need to add any other handlers to get a fully interactive flow with the ability to drag nodes, connect nodes and remove nodes and edges:\n\n#### New API\n\n```jsx\nimport ReactFlow from 'react-flow-renderer';\n\nconst defaultNodes = [\n  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },\n  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },\n];\n\nconst defaultEdges = [{ id: 'e1-2', source: '1', target: '2' }];\n\nconst BasicFlow = () => {\n  return <ReactFlow defaultNodes={defaultNodes} defaultEdges={defaultEdges} />;\n};\n\nexport default BasicFlow;\n```\n\nIf you want to add, remove or update a node or edge you can only do this by using the [ReactFlow instance](/api-reference/types/react-flow-instance) that you can receive either with the new `useReactFlow` hook or by using the `onInit` handler that gets the instance as a function param.\n\n### 2. Memoize your custom `nodeTypes` and `edgeTypes`\n\nWhenever you pass new node or edge types, we create wrapped node or edge component types in the background. This means that you should not create a new `nodeType` or `edgeType` object on every render. **Memoize your nodeTypes and edgeTypes or define them outside of the component when they don't change**.\n\n**Don't do this:**\n\nThis creates a new object on every render and leads to bugs and performance issues:\n\n```jsx\n// this is bad! Don't do it.\n<ReactFlow\n  nodes={[]}\n  nodeTypes={{\n    specialType: SpecialNode, // bad!\n  }}\n/>\n```\n\n**Do this:**\n\n```jsx\nfunction Flow() {\n  const nodeTypes = useMemo(() => ({ specialType: SpecialNode }), []);\n\n  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;\n}\n```\n\nor create the types outside of the component when they don't change:\n\n```jsx\nconst nodeTypes = { specialType: SpecialNode };\n\nfunction Flow() {\n  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;\n}\n```\n\n### 3. ~~Redux~~ - Zustand\n\nWe switched our state management library from Redux to [Zustand](https://github.com/pmndrs/zustand). With this change we could remove about 300LOC from our state related code. If you need to access the internal store, you can use the [`useStore` hook](/api-reference/hooks/use-store):\n\n#### Old API\n\n```jsx\nimport { useStoreState, useStoreActions } from 'react-flow-renderer';\n\n...\n\nconst transform = useStoreState((store) => store.transform);\n```\n\n#### New API\n\n```jsx\nimport { useStore } from 'react-flow-renderer';\n\n...\nconst transform = useStore((store) => store.transform);\n```\n\nYou still need to wrap your component with the `<ReactFlowProvider />` if you want to access the internal store.\n\nWe are also exporting `useStoreApi` if you need to get the store in an event handler for example without triggering re-renders.\n\n```js\nimport { useStoreApi } from 'react-flow-renderer';\n\n...\n\nconst store = useStoreApi();\n\n...\n// in an event handler\nconst [x, y, zoom] = store.getState().transform;\n```\n\n### 4. ~~onLoad~~ - onInit\n\nThe `onLoad` callback has been renamed to `onInit` and now fires when the nodes are initialized.\n\n#### Old API\n\n```jsx\nconst onLoad = (reactFlowInstance: OnLoadParams) => reactFlowInstance.zoomTo(2);\n...\n<ReactFlow\n   ...\n  onLoad={onLoad}\n/>\n```\n\n#### New API\n\n```jsx\nconst onInit = (reactFlowInstance: ReactFlowInstance) => reactFlowInstance.zoomTo(2);\n...\n<ReactFlow\n   ...\n  onInit={onInit}\n/>\n```\n\n### 5. ~~paneMoveable~~ - panOnDrag\n\nThis is more consistent with the rest of the API (`panOnScroll`, `zoomOnScroll`, etc.)\n\n#### Old API\n\n```jsx\n<ReactFlow\n   ...\n  paneMoveable={false}\n/>\n```\n\n#### New API\n\n```jsx\n<ReactFlow\n   ...\n  panOnDrag={false}\n/>\n```\n\n### 6. ~~useZoomPanHelper transform~~ - unified in `useReactFlow`\n\nAs \"transform\" is also the variable name of the transform in the store and it's not clear that `transform` is a setter we renamed it to `setViewport`. This is also more consistent with the other functions. Also, all `useZoomPanHelper` functions have been moved to the [React Flow instance](/api-reference/types/react-flow-instance) that you get from the [`useReactFlow` hook](/api-reference/hooks/use-react-flow) or the `onInit` handler.\n\n#### Old API\n\n```js\nconst { transform, setCenter, setZoom  } = useZoomPanHelper();\n...\ntransform({ x: 100, y: 100, zoom: 2 });\n```\n\n#### New API\n\n```js\nconst { setViewport, setCenter, setZoom } = useReactFlow();\n...\nsetViewport({ x: 100, y: 100, zoom: 2 });\n```\n\nNew viewport functions:\n\n- `getZoom`\n- `getViewport`\n\n### 7. ~~isHidden~~ - hidden\n\nWe mixed prefixed (`is...`) and non-prefixed boolean option names. All node and edge options are not prefixed anymore. So it's `hidden`, `animated`, `selected`, `draggable`, `selectable` and `connectable`.\n\n#### Old API\n\n```js\nconst hiddenNode = { id: '1', isHidden: true, position: { x: 50, y: 50 } };\n```\n\n#### New API\n\n```js\nconst hiddenNode = { id: '1', hidden: true, position: { x: 50, y: 50 } };\n```\n\n### 8. ~~arrowHeadType~~ ~~markerEndId~~ - markerStart / markerEnd\n\nWe improved the API for customizing the markers for an edge. With the new API you are able to set individual markers at the start and the end of an edge as well as customizing them with colors, strokeWidth etc. You still have the ability to set a markerEndId but instead of using different properties, the `markerStart` and `markerEnd` property accepts either a string (id for the svg marker that you need to define yourself) or a configuration object for using the built in arrowClosed or arrow markers.\n\n#### Old API\n\n```js\nconst markerEdge = { source: '1', target: '2', arrowHeadType: 'arrow' };\n```\n\n#### New API\n\n```js\nconst markerEdge = {\n  source: '1',\n  target: '2',\n  markerStart: 'myCustomSvgMarker',\n  markerEnd: { type: 'arrow', color: '#f00' },\n};\n```\n\n### 9. ~~ArrowHeadType~~ - MarkerType\n\nThis is just a wording change for making the marker API more consistent. As we are now able to set markers for the start of the edge, the name type ArrowHeadType has been renamed to MarkerType. In the future, this can also not only contain arrow shapes but others like circles, diamonds etc.\n\n### 10. Attribution\n\nThis is not really a breaking change to the API but a little change in the general appearance of React Flow. We added a tiny \"React Flow\" attribution to the bottom right (the position is configurable via the `attributionPosition` prop). This change comes with the new \"React Flow Pro\" subscription model. If you want to remove the attribution in a commercial application, please subscribe to [\"React Flow Pro\"](/pro)."
    },
    "learn/troubleshooting/migrate-to-v11": {
      "name": "learn/troubleshooting/migrate-to-v11",
      "title": "Migrate to v11",
      "description": "Use this guide to migrate from React Flow v10 to v11.",
      "category": "learn",
      "sections": [
        "New Features",
        "Breaking Changes",
        "1. New npm package name",
        "2. Importing CSS is mandatory",
        "3. `defaultPosition` and `defaultZoom` have been merged to `defaultViewport`",
        "4. Removal of `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter`",
        "5. Removal of `onClickConnectStop` and `onConnectStop`",
        "6. Pan over nodes"
      ],
      "content": "# Migrate to React Flow v11\n\nimport { Callout } from 'nextra/components';\n\n<Callout type=\"info\">\n  You can find the docs for old versions of React Flow here:\n  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),\n  [v9](https://v9.reactflow.dev)\n</Callout>\n\nA lot changed in v11 but this time we've tried to keep the breaking changes small. The biggest change is the new package name `reactflow` and the new repo structure. React Flow is now managed as a monorepo and separated into multiple packages that can be installed separately. In addition to that, there are some API changes and new APIs introduced in v11. This guide explains the changes in detail and helps you to migrate from v10 to v11.\n\n<Callout>React Flow 11 only works with **React 17** or greater</Callout>\n\n## New Features\n\n- **Better [Accessibility](/learn/advanced-use/accessibility)**\n  - Nodes and edges are focusable, selectable, moveable and deletable with the keyboard.\n  - `aria-` default attributes for all elements and controllable via `ariaLabel` options\n  - Keyboard controls can be disabled with the new `disableKeyboardA11y` prop\n- **Better selectable edges** via new edge option: `interactionWidth` - renders invisible edge that makes it easier to interact\n- **Better routing for smoothstep and step edges**: https://twitter.com/reactflowdev/status/1567535405284614145\n- **Nicer edge updating behavior**: https://twitter.com/reactflowdev/status/1564966917517021184\n- **Node origin**: The new `nodeOrigin` prop lets you control the origin of a node. Useful for layouting.\n- **New background pattern**: `BackgroundVariant.Cross` variant\n- **[`useOnViewportChange`](/api-reference/hooks/use-on-viewport-change) hook** - handle viewport changes within a component\n- **[`use-on-selection-change`](/api-reference/hooks/use-on-selection-change) hook** - handle selection changes within a component\n- **[`useNodesInitialized`](/api-reference/hooks/use-nodes-initialized) hook** - returns true if all nodes are initialized and if there is more than one node\n- **Deletable option** for Nodes and edges\n- **New Event handlers**: `onPaneMouseEnter`, `onPaneMouseMove` and `onPaneMouseLeave`\n- **Edge `pathOptions`** for `smoothstep` and `default` edges\n- **Nicer cursor defaults**: Cursor is grabbing, while dragging a node or panning\n- **Pane moveable** with middle mouse button\n- **Pan over nodes** when they are not draggable (`draggable=false` or `nodesDraggable` false)\n  - you can disable this behavior by adding the class name `nopan` to a wrapper of a custom node\n- **[`<BaseEdge />`](/api-reference/components/base-edge) component** that makes it easier to build custom edges\n- **[Separately installable packages](/learn/concepts/built-in-components)**\n  - @reactflow/core\n  - @reactflow/background\n  - @reactflow/controls\n  - @reactflow/minimap\n\n## Breaking Changes\n\n### 1. New npm package name\n\nThe package `react-flow-renderer` has been renamed to `reactflow`.\n\n#### Old API\n\n```js\n// npm install react-flow-renderer\nimport ReactFlow from 'react-flow-renderer';\n```\n\n#### New API\n\n```js\n// npm install reactflow\nimport { ReactFlow } from '@xyflow/react';\n```\n\n### 2. Importing CSS is mandatory\n\nWe are not injecting CSS anymore. **React Flow won't work if you are not loading the styles!**\n\n```js\n// default styling\nimport '@xyflow/react/dist/style.css';\n\n// or if you just want basic styles\nimport '@xyflow/react/dist/base.css';\n```\n\n#### 2.1. Removal of the nocss entrypoint\n\nThis change also means that there is no `react-flow-renderer/nocss` entry point anymore. If you used that, you need to adjust the CSS entry points as mentioned above.\n\n### 3. `defaultPosition` and `defaultZoom` have been merged to `defaultViewport`\n\n#### Old API\n\n```jsx\nimport ReactFlow from 'react-flow-renderer';\n\nconst Flow = () => {\n  return <ReactFlow defaultPosition={[10, 15]} defaultZoom={5} />;\n};\n\nexport default Flow;\n```\n\n#### New API\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\n\nconst defaultViewport: Viewport = { x: 10, y: 15, zoom: 5 };\n\nconst Flow = () => {\n  return <ReactFlow defaultViewport={defaultViewport} />;\n};\n\nexport default Flow;\n```\n\n### 4. Removal of `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter`\n\nIn v10 we had `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter` for getting the center of a certain edge type.\nIn v11 we changed the helper function for creating the path, so that it also returns the center / label position of an edge.\n\nLet's say you want to get the path and the center / label position of a bezier edge:\n\n#### Old API\n\n```jsx\nimport { getBezierEdgeCenter, getBezierPath } from 'react-flow-renderer';\n\nconst path = getBezierPath(edgeParams);\nconst [centerX, centerY] = getBezierEdgeCenter(params);\n```\n\n#### New API\n\n```jsx\nimport { getBezierPath } from '@xyflow/react';\n\nconst [path, labelX, labelY] = getBezierPath(edgeParams);\n```\n\nWe avoid to call it `centerX` and `centerY` anymore, because it's actually the label position and not always the center for every edge type.\n\n### 5. Removal of `onClickConnectStop` and `onConnectStop`\n\n#### Old API\n\n```jsx\nimport ReactFlow from 'react-flow-renderer';\n\nconst Flow = () => {\n  const onConnectStop = () => console.log('on connect stop');\n\n  return (\n    <ReactFlow\n      defaultNodes={defaultNodes}\n      defaultEdges={defaultEdges}\n      onConnectStop={onConnectStop}\n      onClickConnectStop={onConnectStop}\n    />\n  );\n};\n\nexport default Flow;\n```\n\n#### New API\n\n```jsx\nimport { ReactFlow } from '@xyflow/react';\n\nconst Flow = () => {\n  const onConnectEnd = () => console.log('on connect stop');\n\n  return (\n    <ReactFlow\n      defaultNodes={defaultNodes}\n      defaultEdges={defaultEdges}\n      onConnectEnd={onConnectEnd}\n      onClickConnectEnd={onConnectEnd}\n    />\n  );\n};\n\nexport default Flow;\n```\n\n### 6. Pan over nodes\n\nIn the previous versions you couldn't pan over nodes even if they were not draggable. In v11, you can pan over nodes when `nodesDraggable=false` or node option `draggable=false`. If you want the old behavior back, you can add the class name `nopan` to the wrappers of your custom nodes."
    },
    "learn/troubleshooting/migrate-to-v12": {
      "name": "learn/troubleshooting/migrate-to-v12",
      "title": "Migrate to v12",
      "description": "Use this guide to migrate from React Flow 11 to 12.",
      "category": "learn",
      "sections": [
        "Migration guide",
        "1. A new npm package name",
        "2. Node <code>measured</code> attribute for measured <code>width</code> and <code>height</code>",
        "3. New dimension handling <code>node.width</code> / <code>node.height</code> vs <code>node.measured.width</code> / <code>node.measured.height</code>",
        "4. Updating nodes and edges",
        "5. Rename <code>onEdgeUpdate</code> (and related APIs) to <code>onReconnect</code>",
        "6. Rename <code>parentNode</code> to <code>parentId</code>",
        "7. Custom node props",
        "8. Handle component class names",
        "9. <code>getNodesBounds</code> options",
        "10. Typescript changes for defining nodes and edges",
        "11. Rename <code>nodeInternals</code>",
        "12. Removal of deprecated functions",
        "13. Custom <code>applyNodeChanges</code> and <code>applyEdgeChanges</code>",
        "New features",
        "1. Server side rendering",
        "2. Computing flows",
        "3. Dark mode and CSS variables",
        "4. A better DX with TSDoc",
        "More features and updates",
        "Internal changes"
      ],
      "content": "# Migrate to React Flow 12\n\nimport { Callout } from 'nextra/components';\n\n<Callout type=\"info\">\n  You can find the docs for old versions of React Flow here:\n  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),\n  [v9](https://v9.reactflow.dev)\n</Callout>\n\nBefore you can use the **[new features](#new-features)** that come with React Flow 12 like\nserver side rendering, computing flows, and dark mode, here are the breaking changes\nyou'll have to address first. We tried to keep the breaking changes to a minimum, but some\nof them were necessary to implement the new features.\n\n## Migration guide\n\nBefore you start to migrate, you need to install the new package.\n\n```bash npm2yarn\nnpm install @xyflow/react\n```\n\n### 1. A new npm package name\n\nThe package `reactflow` has been renamed to `@xyflow/react` and it's not a default import\nanymore. You also need to adjust the style import. Before v12, React Flow was divided into\nmultiple packages. That's not the case anymore. If you just used the core, you now need to\ninstall the `@xyflow/react` package.\n\n**Old API**\n\n```js\n// npm install reactflow\nimport ReactFlow from 'reactflow';\n```\n\n**New API**\n\n```js\n// npm install @xyflow/react\nimport { ReactFlow } from '@xyflow/react';\n\n// you also need to adjust the style import\nimport '@xyflow/react/dist/style.css';\n\n// or if you just want basic styles\nimport '@xyflow/react/dist/base.css';\n```\n\n### 2. Node <code>measured</code> attribute for measured <code>width</code> and <code>height</code>\n\nAll measured node values are now stored in `node.measured`. Besides the new package name,\nthis is the biggest change. After React Flow measures your nodes, it writes the dimensions\nto `node.measured.width` and `node.measured.height`. If you are using any layouting\nlibrary like dagre or elk, you now need to take the dimensions from `node.measured`\ninstead of `node`. If you are using `width` and `height`, those values will now be used as\ninline styles to specify the node dimensions.\n\n**Old API**\n\n```js\n// getting the measured width and height\nconst nodeWidth = node.width;\nconst nodeHeight = node.height;\n```\n\n**New API**\n\n```js\n// getting the measured width and height\nconst nodeWidth = node.measured?.width;\nconst nodeHeight = node.measured?.height;\n```\n\n### 3. New dimension handling <code>node.width</code> / <code>node.height</code> vs <code>node.measured.width</code> / <code>node.measured.height</code>\n\nIn order to support server side rendering we had to restructure the API a bit, so that\nusers can pass node dimensions more easily. For this we changed the behavior of the\n`node.width` and `node.height` attributes. In React Flow 11, those attributes were\nmeasured values and only used as a reference. In React Flow 12 those attributes are used\nas inline styles to specify the node dimensions. If you load nodes from a database, you\nprobably want to remove the `width` and `height` attributes from your nodes, because the\nbehavior is slightly different now. Using `width` and `height` now means that the\ndimensions are not dynamic based on the content but fixed.\n\n**Old API**\n\n```js\n// in React Flow 11 you might have used node.style to set the dimensions\nconst nodes = [\n  {\n    id: '1',\n    type: 'input',\n    data: { label: 'input node' },\n    position: { x: 250, y: 5 },\n    style: { width: 180, height: 40 },\n  },\n];\n```\n\n**New API**\n\n```js\n// in React Flow 12 you can used node.width and node.height to set the dimensions\nconst nodes = [\n  {\n    id: '1',\n    type: 'input',\n    data: { label: 'input node' },\n    position: { x: 250, y: 5 },\n    width: 180,\n    height: 40,\n  },\n];\n```\n\nIf you want to read more about how to configure React Flow for server side rendering, you\ncan read about it in the\n[server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).\n\n### 4. Updating nodes and edges\n\nWe are not supporting node and edge updates with object mutations anymore. If you want to\nupdate a certain attribute, you need to create a new node / edge.\n\n**Old API**\n\n```js\nsetNodes((currentNodes) =>\n  currentNodes.map((node) => {\n    node.hidden = true;\n    return node;\n  }),\n);\n```\n\n**New API**\n\n```js\nsetNodes((currentNodes) =>\n  currentNodes.map((node) => ({\n    ...node,\n    hidden: true,\n  })),\n);\n```\n\n### 5. Rename <code>onEdgeUpdate</code> (and related APIs) to <code>onReconnect</code>\n\nWe renamed the `onEdgeUpdate` function to `onReconnect` and all related APIs (mentioned\nbelow). The new name is more descriptive and makes it clear that the function is used to\nreconnect edges.\n\n- `updateEdge` renamed to `reconnectEdge`\n- `onEdgeUpdateStart` renamed to `onReconnectStart`\n- `onEdgeUpdate` renamed to `onReconnect`\n- `onEdgeUpdateEnd` renamed to `onReconnectEnd`\n- `edgeUpdaterRadius` renamed to `reconnectRadius`\n- `edge.updatable` renamed to `edge.reconnectable`\n- `edgesUpdatable` renamed to `edgesReconnectable`\n\n**Old API**\n\n```js\n<ReactFlow\n  onEdgeUpdate={onEdgeUpdate}\n  onEdgeUpdateStart={onEdgeUpdateStart}\n  onEdgeUpdateEnd={onEdgeUpdateEnd}\n/>\n```\n\n**New API**\n\n```js\n<ReactFlow\n  onReconnect={onReconnect}\n  onReconnectStart={onReconnectStart}\n  onReconnectEnd={onReconnectEnd}\n/>\n```\n\n### 6. Rename <code>parentNode</code> to <code>parentId</code>\n\nIf you are working with subflows, you need to rename `node.parentNode` to `node.parentId`.\nThe `parentNode` attribute was a bit misleading, because it was not a reference to the\nparent node, but the `id` of the parent node.\n\n**Old API**\n\n```js\nconst nodes = [\n  // some nodes ...\n  {\n    id: 'xyz-id',\n    position: { x: 0, y: 0 },\n    type: 'default',\n    data: {},\n    parentNode: 'abc-id',\n  },\n];\n```\n\n**New API**\n\n```js\nconst nodes = [\n  // some nodes ...\n  {\n    id: 'xyz-id',\n    position: { x: 0, y: 0 },\n    type: 'default',\n    data: {},\n    parentId: 'abc-id',\n  },\n];\n```\n\n### 7. Custom node props\n\nWe renamed the `xPos` and `yPos` props to `positionAbsoluteX` and `positionAbsoluteY`\n\n**Old API**\n\n```js\nfunction CustomNode({ xPos, yPos }) {\n  ...\n}\n```\n\n**New API**\n\n```js\nfunction CustomNode({ positionAbsoluteX, positionAbsoluteY }) {\n  ...\n}\n```\n\n### 8. Handle component class names\n\nWe renamed some of the classes used to define the current state of a handle.\n\n- `react-flow__handle-connecting` renamed to `connectingto` / `connectingfrom`\n- `react-flow__handle-valid` renamed to `valid`\n\n### 9. <code>getNodesBounds</code> options\n\nThe type of the second param changed from `nodeOrigin` to `options.nodeOrigin`\n\n**Old API**\n\n```js\nconst bounds = getNodesBounds(nodes: Node[], nodeOrigin)\n```\n\n**New API**\n\n```js\nconst bounds = getNodesBounds(nodes: Node[], { nodeOrigin })\n```\n\n### 10. Typescript changes for defining nodes and edges\n\nWe simplified types and fixed issues about functions where users could pass a NodeData\ngeneric. The new way is to define your own node type with a union of all your nodes. With\nthis change, you can now have multiple node types with different data structures and\nalways be able to distinguish by checking the `node.type` attribute.\n\n**New API**\n\n```js\ntype NumberNode = Node<{ value: number }, 'number'>;\ntype TextNode = Node<{ text: string }, 'text'>;\ntype AppNode = NumberNode | TextNode;\n```\n\nYou can then use the `AppNode` type as the following:\n\n```js\nconst nodes: AppNode[] = [\n  { id: '1', type: 'number', data: { value: 1 }, position: { x: 100, y: 100 } },\n  { id: '2', type: 'text', data: { text: 'Hello' }, position: { x: 200, y: 200 } },\n];\n```\n\n```js\nconst onNodesChange: onNodesChange<AppNode> = useCallback((changes) => setNodes(nds => applyChanges(changes, nds)), []);\n```\n\nYou can read more about this in the [Typescript guide](/learn/advanced-use/typescript).\n\n### 11. Rename <code>nodeInternals</code>\n\nIf you are using `nodeInternals` you need to rename it to `nodeLookup`.\n\n**Old API**\n\n```js\nconst node = useStore((s) => s.nodeInternals.get(id));\n```\n\n**New API**\n\n```js\nconst node = useStore((s) => s.nodeLookup.get(id));\n```\n\n### 12. Removal of deprecated functions\n\nWe removed the following deprecated functions:\n\n- `getTransformForBounds` (replaced by `getViewportForBounds`)\n- `getRectOfNodes` (replaced by `getNodesBounds`)\n- `project` (replaced by `screenToFlowPosition`)\n- `getMarkerEndId`\n- `updateEdge` (replaced by `reconnectEdge`)\n\n### 13. Custom <code>applyNodeChanges</code> and <code>applyEdgeChanges</code>\n\nIf you wrote your own function for applying changes, you need to handle the new \"replace\"\nevent. We removed the \"reset\" event and added a \"replace\" event that replaces specific\nnodes or edges.\n\n## New features\n\nNow that you successfully migrated to v12, you can use all the fancy features. As\nmentioned above, the biggest updates for v12 are:\n\n### 1. Server side rendering\n\nYou can define `width`, `height` and `handles` for the nodes. This makes it possible to\nrender a flow on the server and hydrate on the client:\n[server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).\n\n- **Details:** In v11, `width` and `height` were set by the library as soon as the nodes\n  got measured. This still happens, but we are now using `measured.width` and\n  `measured.height` to store this information. In the previous versions there was always a\n  lot of confusion about `width` and `height`. It’s hard to understand, that you can’t use\n  it for passing an actual width or height. It’s also not obvious that those attributes\n  get added by the library. We think that the new implementation solves both of the\n  problems: `width` and `height` are optional attributes that can be used to define\n  dimensions and everything that is set by the library, is stored in `measured`.\n\n### 2. Computing flows\n\nThe new hooks [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and\n[`useNodesData`](/api-reference/hooks/use-nodes-data) and the new\n[`updateNode`](/api-reference/hooks/use-react-flow#update-node) and\n[`updateNodeData`](/api-reference/hooks/use-react-flow#update-node-data) functions (both\nare part of `useReactFlow`) can be used to manage the data flow between your nodes:\n[computing flows guide](/learn/advanced-use/computing-flows). We also added those helpers\nfor edges (`updateEdge` and `updateEdgeData`)!\n\n- **Details:** Working with flows where one node data relies on another node is super\n  common. You update node A and want to react on those changes in the connected node B.\n  Until now everyone had to come up with a custom solution. With this version we want to\n  change this and give you performant helpers to handle use cases like this.\n\n### 3. Dark mode and CSS variables\n\nReact Flow now comes with a built-in dark mode, that can be toggled by using the new\n[`colorMode`](/api-reference/react-flow#color-mode) prop (”light”, “dark” or “system”):\n[dark mode example](/examples/styling/dark-mode)\n\n- **Details:** With this version we want to make it easier to switch between dark and\n  light modes and give you a better starting point for dark flows. If you pass\n  `colorMode=\"dark\"`, we add the class name \"dark\" to the wrapper and use it to adjust the\n  styling. To make the implementation for this new feature easier on our ends, we switched\n  to CSS variables for most of the styles. These variables can also be used in user land\n  to customize a flow.\n\n### 4. A better DX with TSDoc\n\nWe started to use TSDoc for a better DX. While developing your IDE will now show you the\ndocumentation for the props and hooks. This is a big step for us to make the library more\naccessible and easier to use. We will also use TSDoc in the near future to generate the\ndocumentation.\n\n### More features and updates\n\nThere is more! Besides the new main features, we added some minor things that were on our\nlist for a long time:\n\n- **[`useConnection` hook](/api-reference/hooks/use-connection):** With this hook you can\n  access the ongoing connection. For example, you can use it for colorizing handles\n  styling a custom connection line based on the current start / end handles.\n- **Controlled `viewport`:** This is an advanced feature. Possible use cases are to\n  animate the viewport or round the transform for lower res screens for example. This\n  features brings two new props: [`viewport`](/api-reference/react-flow#viewport) and\n  [`onViewportChange`](/api-reference/react-flow#on-viewport-change).\n- **[`ViewportPortal`](/api-reference/components/viewport-portal) component:** This makes\n  it possible to render elements in the viewport without the need to implement a custom\n  node.\n- **[`onDelete`](/api-reference/react-flow#on-delete) handler**: We added a combined\n  handler for `onDeleteNodes` and `onDeleteEdges` to make it easier to react to deletions.\n- **[`onBeforeDelete`](/api-reference/react-flow#on-before-delete) handler**: With this\n  handler you can prevent/ manage deletions.\n- **[`isValidConnection`](/api-reference/react-flow#isvalidconnection) prop:** This makes\n  it possible to implement one validation function for all connections. It also gets\n  called for programmatically added edges.\n- **[`autoPanSpeed`](/api-reference/react-flow#autoPanSpeed) prop:** For controlling the\n  speed while auto panning.\n- **[`paneClickDistance`](/api-reference/react-flow#paneClickDistance) prop:** max\n  distance between mousedown/up that will trigger a click.\n- **Background component**: add\n  [`patternClassName`](/api-reference/components/background#pattern-class-name) prop to be\n  able to style the background pattern by using a class name. This is useful if you want\n  to style the background pattern with Tailwind for example.\n- **`onMove` callback** gets triggered for library-invoked viewport updates (like fitView\n  or zoom-in)\n- **`deleteElements`** now returns deleted nodes and deleted edges\n- add **`origin` attribute** for nodes\n- add **`selectable` attribute** for edges\n- **Node Resizer updates**: child nodes don't move when the group is resized, extent and\n  expand is recognized correctly\n- Correct types for `BezierEdge`, `StepEdge`, `SmoothStepEdge` and `StraightEdge`\n  components\n- New edges created by the library only have `sourceHandle` and `targetHandle` attributes\n  when those attributes are set. (We used to pass `sourceHandle: null` and\n  `targetHandle: null`)\n- Edges do not mount/unmount when their z-index change\n- connection line knows about the target handle position so that the path is drawn\n  correctly\n- `nodeDragThreshold` is 1 by default instead of 0\n- a better selection box usability (capture while dragging out of the flow)\n- add `selectable`, `deletable`, `draggable` and `parentId` to `NodeProps`\n- add a warning when styles not loaded\n\n### Internal changes\n\nThese changes are not really user-facing, but it could be important for folks who are\nworking with the internal React Flow store:\n\n- The biggest internal change is that we created a new package **@xyflow/system with\n  framework agnostic helpers** that can be used by React Flow and Svelte Flow\n  - **XYDrag** for handling dragging node(s) and selection\n  - **XYPanZoom** for controlling the viewport panning and zooming\n  - **XYHandle** for managing new connections\n- We renamed `nodeInternals` to `nodeLookup`. That map serves as a lookup, but we are not\n  creating a new map object on any change so it’s really only useful as a lookup.\n- We removed the internal \"reset\" event and added a \"replace\" event to be able to update\n  specific nodes.\n- We removed `connectionNodeId`, `connectionHandleId`, `connectionHandleType` from the\n  store and added `connection.fromHandle.nodeId`, `connection.fromHandle.id`, …\n- add `data-id` to edges\n- `onNodeDragStart`, `onNodeDrag` and `onNodeDragStop` also get called when user drags a\n  selection (in addition to `onSelectionDragStart`, `onSelectionDrag`,\n  `onSelectionDragStop`)"
    },
    "learn/troubleshooting/remove-attribution": {
      "name": "learn/troubleshooting/remove-attribution",
      "title": "remove-attribution",
      "description": "When and how to remove the React Flow attribution from your flows.",
      "category": "learn",
      "sections": [],
      "content": "import { Callout } from 'nextra/components';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n# Remove Attribution\n\nThis example demonstrates how you can remove the React Flow attribution from the renderer.\n\n<Callout type=\"info\">\nIf you’re considering removing the attribution, we’d first like to mention:\n\n**If you’re using React Flow at your organization and making money from it**, we rely on your support to keep React Flow developed and maintained under an MIT License. Before you remove the attribution, [see the ways you can support React Flow to keep it running](/pro).\n\n**Are you using React Flow for a personal project?** Great! Go ahead and remove the attribution. You can support us by reporting any bugs you find, sending us screenshots of your projects, and starring us on [Github](https://github.com/xyflow/xyflow). If you start making money using React Flow or use it in an organization in the future, we would ask that you re-add the attribution or sign up for one of our subscriptions.\n\nThank you for supporting us ✌🏻\n\n- [the xyflow team](https://xyflow.com/about)\n\n</Callout>\n\n<RemoteCodeViewer route=\"learn/remove-attribution\" framework=\"react\" />"
    },
    "learn/tutorials/getting-started-with-react-flow-components": {
      "name": "learn/tutorials/getting-started-with-react-flow-components",
      "title": "Getting started with React Flow UI",
      "description": "",
      "category": "learn",
      "sections": [
        "Getting started",
        "Setting up a new vite project",
        "Setting up Tailwind CSS",
        "Importing Tailwind CSS as a Vite plugin",
        "Importing the Tailwind CSS file ",
        "Setting up shadcn/ui",
        "Installing React Flow and importing its CSS. ",
        "Adding your first components",
        "Moving fast and making things",
        "The Number Node",
        "The Sum Node",
        "The Data Edge",
        "The Flow",
        "Wrapping up"
      ],
      "content": "import { Emoji } from '@xyflow/xy-ui';\nimport { Callout } from 'nextra/components';\nimport { Image } from 'xy-shared';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\n_**Update November 2025**: We have updated the tutorial to use the latest version of shadcn/ui, on React 19 and Tailwind 4!_\n\n_**Update July 2025**: \"React Flow UI\" was formerly known as \"React Flow Components\". We\nrenamed it because it now includes both components and templates. Additionally, since it's\nbuilt on shadcn/ui, the \"UI\" naming makes it easier for developers to recognize the\nconnection and understand what we offer._\n\nRecently, we launched an exciting new addition to our open-source roster: React Flow\nUI (Previously known as React Flow Components). These are pre-built nodes, edges, and other ui elements that you can quickly\nadd to your React Flow applications to get up and running. The catch is these components\nare built on top of [shadcn/ui](https://ui.shadcn.com) and the shadcn CLI.\n\nWe've previously written about our experience and what led us to choosing shadcn over on\nthe [xyflow blog](https://xyflow.com/blog/react-flow-components), but in this tutorial\nwe're going to focus on how to get started from scratch with shadcn, Tailwind CSS, and\nReact Flow Components.\n\n<Callout>\n**Wait, what's shadcn?**\n\nNo what, **who**! Shadcn is the author of a collection of pre-designed components known as\n`shadcn/ui`. Notice how we didn't say _library_ there? Shadcn takes a different approach\nwhere components are added to your project's source code and are \"owned\" by you: once you\nadd a component you're free to modify it to suit your needs!\n\n</Callout>\n\n## Getting started\n\nTo begin with, we will: \n\n- Set up a new [`vite`](https://vite.dev) project.\n- Set up [shadcn/ui](https://ui.shadcn.com/) along with [Tailwind CSS](https://tailwindcss.com/).\n- Add and configure React Flow.\n- Create our custom React Flow components using the building blocks in our [UI components registry](/ui).\n\n### Setting up a new vite project\n\n```bash copy npm2yarn\nnpm create vite@latest\n```\n\nVite is able to scaffold projects for many popular frameworks, but we only care about\nReact! Additionally, make sure to set up a **TypeScript** project. React Flow's\ndocumentation is a mix of JavaScript and TypeScript, but for shadcn components TypeScript\nis _required_!\n\nDuring the interactive setup, select `React` and `TypeScript`: \n```\n◇  Project name:\n│  my-react-flow-app\n│\n◇  Select a framework:\n│  React\n│\n◇  Select a variant:\n│  TypeScript\n│\n◇  Use rolldown-vite (Experimental)?:\n│  No\n│\n◇  Install with pnpm and start now?\n│  Yes\n│\n◇  Scaffolding project in /Users/alessandro/src/xyflow/wip/component-style-test-2...\n│\n◇  Installing dependencies with pnpm...\n```\n\n### Setting up Tailwind CSS\n\nAll shadcn and React Flow components are styled with\n[Tailwind CSS](https://tailwindcss.com/), so we'll need to install that\nand a few other dependencies next.\n\nWe can follow the instructions in the [shadcn installation guide](https://ui.shadcn.com/docs/installation) \nto install shadcn and Tailwind CSS inside of a freshly scaffolded vite project.\n\n```bash copy npm2yarn\nnpm install tailwindcss @tailwindcss/vite\n```\n\nIt is now a lot simpler to set up Tailwind CSS in a vite project, and Tailwind 4 is configured completely in CSS.\nYou can just replace the generated `src/index.css` file with this one line:\n\n```css filename=\"src/index.css\"\n@import \"tailwindcss\";\n```\n\n### Importing Tailwind CSS as a Vite plugin\n\nStarting with [Tailwind CSS v4](https://tailwindcss.com/blog/tailwindcss-v4), you can use the dedicated Vite plugin `@tailwindcss/vite` \nrather than the traditional PostCSS plugin. This plugin is configured in our `vite.config.ts` file, and makes \nthings a lot simpler, both for us developers, and for the compilers.\n\nWe simply need to import the plugin and add it to the `plugins` array in our `vite.config.ts` file.\nWe also need to add the `alias` property to the `resolve` object to tell Vite where to find our source files, \nas shadcn components use the `@` alias to refer to the `src` directory.\n\n```ts filename=\"vite.config.ts\" {1-2} {8-13}\nimport path from \"path\"\nimport tailwindcss from \"@tailwindcss/vite\"\nimport react from \"@vitejs/plugin-react\"\nimport { defineConfig } from \"vite\"\n \n// https://vite.dev/config/\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n})\n```\n\n\n### Importing the Tailwind CSS file \n\nWe now need to make sure that the only CSS file in our project is the Tailwind CSS file. \nIn the generated `App.tsx`, you can safely remove the import of the `App.css` file, and \nremove everything else that is in the scaffolded `App.tsx` file.\n\nTo verify that Tailwind CSS is working, we can add a simple `div` and `h1` elements with Tailwind classes.\n\nThe updated `App.tsx` file should look like this:\n\n```tsx filename=\"src/App.tsx\"\nexport function App() {\n  return (\n    <div className=\"w-screen h-screen p-8\">\n      <h1 className=\"text-2xl font-bold\">Hello World</h1>\n    </div>\n  );\n}\nexport default App;\n```\n\nAnd, the `main.tsx` file should look like this:\n```tsx filename=\"src/main.tsx\"\nimport { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport App from './App.tsx'\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n)\n```\n\nIf you updated your `index.css` file and configured Vite to use the Tailwind CSS\nplugin, you should be able to run the project and see the \"Hello World\" message\nin your browser, in a nice, large, bold font. \n\n<Callout>\n  The classes `w-screen` and `h-screen` are two examples of Tailwind's utility classes. If\n  you're used to styling React apps using a different approach, you might find this a bit\n  strange at first. You can think of Tailwind classes as supercharged inline styles:\n  they're constrained to a set design system and you have access to responsive media\n  queries or pseudo-classes like `hover` and `focus`.\n</Callout>\n\n### Setting up shadcn/ui\n\nVite scaffolds some `tsconfig` files for us when generating a TypeScript project and we'll\nneed to make some changes to these so the shadcn components can work correctly. The shadcn\nCLI is pretty clever (we'll get to that in a second) but it can't account for every\nproject structure so instead shadcn components that depend on one another make use of\nTypeScript's import paths.\n\nThe current version of Vite splits TypeScript configuration into three files, \ntwo of which need to be edited. Add the `baseUrl` and `paths` properties to the `compilerOptions` section of the \n`tsconfig.json` and `tsconfig.app.json` files:\n\n```json filename=\"tsconfig.json\" {3-8}\n{\n  // ...\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n  // ...\n}\n```\n\n\n```json filename=\"tsconfig.app.json\" {4-7}\n{\n  \"compilerOptions\": {\n    // ...\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n    // ...\n  }\n}\n```\n\n\nNice! Now we're ready to set up the `shadcn/ui` CLI and add our first\ncomponents. Once the CLI is set up, we'll be able to add new components to our\nproject with a single command - even if they have dependencies or need to modify\nexisting files!\n\nWe can now run the following command to set up shadcn/ui in our project:\n\n```bash copy npm2yarn\nnpx shadcn@latest init\n```\n\nThe CLI will perform a few tasks, first it will identify your project's\nframework, tailwind version, and then ask you what color you would like to use\nas the base color for your project. It will then update your `index.css` file and generate a `components.json` file in the\nroot of your project, which will be shadcn's main configuration points. \n\nWe can take all the default options for now\n\n```\n✔ Preflight checks.\n✔ Verifying framework. Found Vite.\n✔ Validating Tailwind CSS config. Found v4.\n✔ Validating import alias.\n✔ Which color would you like to use as the base color? › Neutral\n✔ Writing components.json.\n✔ Checking registry.\n✔ Updating CSS variables in src/index.css\n✔ Installing dependencies.\n✔ Created 1 file:\n  - src/lib/utils.ts\n\nSuccess! Project initialization completed.\nYou may now add components.\n```\n\n## Installing React Flow and importing its CSS. \n\nNow we can install React Flow and import its CSS.\n\n```bash copy npm2yarn\nnpm install @xyflow/react\n```\n\nAnd then import its CSS in our `App.tsx` file:\n\n```tsx filename=\"src/App.tsx\"\nimport '@xyflow/react/dist/style.css';\n\nexport function App() {\n  return (\n    <div className=\"w-screen h-screen p-8\">\n      <h1 className=\"text-2xl font-bold\">Hello World</h1>\n    </div>\n  );\n}\nexport default App;\n```\n\n\n## Adding your first components\n\nTo demonstrate how powerful shadcn can be, let's dive right into making a new **React\nFlow** app! Now everything is set up, we can add the\n[`<BaseNode />`](/ui/components/base-node) component with a single command:\n\n```bash copy npm2yarn\nnpx shadcn@latest add https://ui.reactflow.dev/base-node\n```\n\nThis command will generate a new file `src/components/base-node.tsx`, and install the necessary dependencies.\n\nThat `<BaseNode />` component is not a React Flow node directly. Instead, as the name\nimplies, it's a base that many of our other nodes build upon. It also comes with\nadditional components that you can use to provide a header and content for your nodes.\nThese components are:\n\n- `<BaseNodeHeader />`\n- `<BaseNodeHeaderTitle />`\n- `<BaseNodeContent />`\n- `<BaseNodeFooter />`\n\nYou can use it to have a unified style for all of your nodes as well. Let's see what it\nlooks like by updating our `App.tsx` file:\n\n```tsx filename=\"src/App.tsx\"\nimport '@xyflow/react/dist/style.css';\n\nimport {\n  BaseNode,\n  BaseNodeContent,\n  BaseNodeHeader,\n  BaseNodeHeaderTitle,\n} from \"@/components/base-node\";\n\nfunction App() {\n  return (\n    <div className=\"w-screen h-screen p-8\">\n      <BaseNode>\n        <BaseNodeHeader>\n          <BaseNodeHeaderTitle>Base Node</BaseNodeHeaderTitle>\n        </BaseNodeHeader>\n        <BaseNodeContent>\n          This is a base node component that can be used to build other nodes.\n        </BaseNodeContent>\n      </BaseNode>\n    </div>\n  );\n}\n\nexport default App;\n```\n\nOk, not super exciting...\n\n<Image\n  src=\"/img/tutorials/components/base-node.png\"\n  alt=\"A screenshot of a simple React application. It renders one element, a\n  rounded container with a blue border and the text 'Hi! 👋' inside.\"\n/>\n\n\nThe `<BaseNode />` component is one of the most used components in our [UI components registry](/ui).\nSome components may use it internally, to create custom nodes with a consistent style,\nwhile some other components can be used in combination with it to create more complex nodes.\n\n\nFor example, let's add the `<NodeTooltip />` component to our project, to display a tooltip when hovering over a node.\n\n```bash copy npm2yarn\nnpx shadcn@latest add https://ui.reactflow.dev/node-tooltip\n```\n\nAnd we'll update our `App.tsx` file to render a proper flow. We'll use the same basic\nsetup as most of our examples so we won't break down the individual pieces here. If you're\nstill new to React Flow and want to learn a bit more about how to set up a basic flow from\nscratch, check out our [quickstart guide](/learn).\n\n{/* TODO this could be linked to example app with RemoteCodeViewer editor */}\n\n```tsx filename=\"src/App.tsx\"\nimport { Position, ReactFlow, useNodesState, type Node } from \"@xyflow/react\";\n\nimport \"@xyflow/react/dist/style.css\";\n\nimport { BaseNode, BaseNodeContent } from \"@/components/base-node\";\nimport {\n  NodeTooltip,\n  NodeTooltipContent,\n  NodeTooltipTrigger,\n} from \"@/components/node-tooltip\";\n\nfunction Tooltip() {\n  return (\n    <NodeTooltip>\n      <NodeTooltipContent position={Position.Top}>\n        Hidden Content\n      </NodeTooltipContent>\n      <BaseNode>\n        <BaseNodeContent>\n          <NodeTooltipTrigger>Hover</NodeTooltipTrigger>\n        </BaseNodeContent>\n      </BaseNode>\n    </NodeTooltip>\n  );\n}\n\nconst nodeTypes = {\n  tooltip: Tooltip,\n};\n\nconst initialNodes: Node[] = [\n  {\n    id: \"1\",\n    position: { x: 0, y: 0 },\n    data: {},\n    type: \"tooltip\",\n  },\n];\n\nfunction Flow() {\n  const [nodes, , onNodesChange] = useNodesState(initialNodes);\n\n  return (\n    <div className=\"h-screen w-screen p-8 bg-gray-50 rounded-xl\">\n      <ReactFlow\n        nodes={nodes}\n        nodeTypes={nodeTypes}\n        onNodesChange={onNodesChange}\n        fitView\n      />\n    </div>\n  );\n}\n\nexport default function App() {\n  return <Flow />;\n}\n```\n\nAnd would you look at that, the tooltip node we added automatically uses the\n`<BaseNode />` component we customized!\n\n<RemoteCodeViewer route=\"tutorials/components/tooltip\" framework=\"react\" />\n\n## Moving fast and making things\n\nNow we've got a basic understanding of how shadcn/ui and the CLI works, we can begin to\nsee how easy it is to add new components and build out a flow. To see everything React\nFlow Components has to offer let's build out a simple calculator flow.\n\nFirst let's remove the `<NodeTooltip />` and undo our changes to `<BaseNode />`. In\naddition to pre-made nodes, React Flow UI also contains building blocks for creating your\nown custom nodes. To see them, we'll add the `labeled-handle` component:\n\n```bash copy npm2yarn\nnpx shadcn@latest add https://ui.reactflow.dev/labeled-handle\n```\n\n### The Number Node\n\nThe first node we'll create is a simple number node with some buttons to increment and\ndecrement the value and a handle to connect it to other nodes. Create a folder\n`src/components/nodes` and then add a new file `src/components/nodes/num-node.tsx`.\n\nWe need to install the following `shadcn/ui` components:\n\n```bash copy npm2yarn\nnpx shadcn@latest add dropdown-menu button\n```\n\nNow we can start building the node. We will need to access the `updateNodeData`\nfunction to update the node's data and the `setNodes` function to delete the\nnode, from the `useReactFlow` hook. The hook helps us make self-contained\ncomponents that can be used in other parts of our application, while still\ngiving us quick access to React Flow's state and functions.\n\nWe will need to make four callbacks, to handle the different actions that can be performed on the node.\n- Reset the node's value to 0\n- Delete the node\n- Increment the node's value by 1\n- Decrement the node's value by 1\n\nWe will also need to access the node's data to get the current value and update it.\n\n```tsx filename=\"src/components/nodes/num-node.tsx\"\nimport { type Node, type NodeProps, Position, useReactFlow } from '@xyflow/react';\nimport { useCallback } from 'react';\n\nimport {\n  BaseNode,\n  BaseNodeContent,\n  BaseNodeFooter,\n  BaseNodeHeader,\n  BaseNodeHeaderTitle,\n} from '../base-node';\nimport { LabeledHandle } from '../labeled-handle';\n\nimport { EllipsisVertical } from 'lucide-react';\nimport { Button } from '../ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuTrigger,\n} from '../ui/dropdown-menu';\n\nexport type NumNode = Node<{\n  value: number;\n}>;\n\nexport function NumNode({ id, data }: NodeProps<NumNode>) {\n  const { updateNodeData, setNodes } = useReactFlow();\n\n  const handleReset = useCallback(() => {\n    updateNodeData(id, { value: 0 });\n  }, [id, updateNodeData]);\n\n  const handleDelete = useCallback(() => {\n    setNodes((nodes) => nodes.filter((node) => node.id !== id));\n  }, [id, setNodes]);\n\n  const handleIncr = useCallback(() => {\n    updateNodeData(id, { value: data.value + 1 });\n  }, [id, data.value, updateNodeData]);\n\n  const handleDecr = useCallback(() => {\n    updateNodeData(id, { value: data.value - 1 });\n  }, [id, data.value, updateNodeData]);\n\n  return (\n    <BaseNode>\n      <BaseNodeHeader className=\"border-b\">\n        <BaseNodeHeaderTitle>Num</BaseNodeHeaderTitle>\n\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              className=\"nodrag p-1\"\n              aria-label=\"Node Actions\"\n              title=\"Node Actions\"\n            >\n              <EllipsisVertical className=\"size-4\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent>\n            <DropdownMenuLabel className=\"font-bold\">Node Actions</DropdownMenuLabel>\n            <DropdownMenuItem onSelect={handleReset}>Reset</DropdownMenuItem>\n            <DropdownMenuItem onSelect={handleDelete}>Delete</DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </BaseNodeHeader>\n\n      <BaseNodeContent>\n        <div className=\"flex gap-2 items-center\">\n          <Button onClick={handleDecr}>-</Button>\n          <pre>{String(data.value).padStart(3, ' ')}</pre>\n          <Button onClick={handleIncr}>+</Button>\n        </div>\n      </BaseNodeContent>\n\n      <BaseNodeFooter className=\"bg-gray-100 items-end px-0 py-1 w-full  rounded-b-md\">\n        <LabeledHandle title=\"out\" type=\"source\" position={Position.Right} />\n      </BaseNodeFooter>\n    </BaseNode>\n  );\n}\n```\n\n### The Sum Node\n\nThe second node we can create is a simple sum node that adds the values of the two input nodes.\nCreate a new file `src/components/nodes/sum-node.tsx` and paste the following into it:\n\nParticularly, we will need to access the `getNodeConnections` function to get\nthe values of the two connected input nodes and the `updateNodeData` function to\nupdate the node's data with the sum of the two input nodes inside of a\n`useEffect` hook, whenever one of the values of the input nodes changes.\n\n```tsx filename=\"src/components/nodes/sum-node.tsx\"\nimport {\n  type Node,\n  type NodeProps,\n  Position,\n  useReactFlow,\n  useStore,\n} from '@xyflow/react';\nimport { useCallback, useEffect } from 'react';\n\nimport {\n  BaseNode,\n  BaseNodeContent,\n  BaseNodeFooter,\n  BaseNodeHeader,\n  BaseNodeHeaderTitle,\n} from '../base-node';\nimport { LabeledHandle } from '../labeled-handle';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuTrigger,\n} from '../ui/dropdown-menu';\nimport { EllipsisVertical } from 'lucide-react';\nimport { Button } from '../ui/button';\n\nexport type SumNode = Node<{\n  value: number;\n}>;\n\nexport function SumNode({ id }: NodeProps<SumNode>) {\n  const { updateNodeData, getNodeConnections, setNodes, setEdges } = useReactFlow();\n  const { x, y } = useStore((state) => ({\n    x: getHandleValue(\n      getNodeConnections({ nodeId: id, handleId: 'x', type: 'target' }),\n      state.nodeLookup,\n    ),\n    y: getHandleValue(\n      getNodeConnections({ nodeId: id, handleId: 'y', type: 'target' }),\n      state.nodeLookup,\n    ),\n  }));\n\n  const handleDelete = useCallback(() => {\n    setNodes((nodes) => nodes.filter((node) => node.id !== id));\n    setEdges((edges) => edges.filter((edge) => edge.source !== id));\n  }, [id, setNodes, setEdges]);\n\n  useEffect(() => {\n    updateNodeData(id, { value: x + y });\n  }, [x, y]);\n\n  return (\n    <BaseNode className=\"w-32\">\n      <BaseNodeHeader className=\"border-b\">\n        <BaseNodeHeaderTitle>Sum</BaseNodeHeaderTitle>\n\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              className=\"nodrag p-1\"\n              aria-label=\"Node Actions\"\n              title=\"Node Actions\"\n            >\n              <EllipsisVertical className=\"size-4\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent>\n            <DropdownMenuLabel className=\"font-bold\">Node Actions</DropdownMenuLabel>\n            <DropdownMenuItem onSelect={handleDelete}>Delete</DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </BaseNodeHeader>\n\n      <BaseNodeContent className=\"px-0\">\n        <LabeledHandle title=\"x\" id=\"x\" type=\"target\" position={Position.Left} />\n        <LabeledHandle title=\"y\" id=\"y\" type=\"target\" position={Position.Left} />\n      </BaseNodeContent>\n      <BaseNodeFooter className=\"bg-gray-100 items-end px-0 py-1 w-full rounded-b-md\">\n        <LabeledHandle title=\"out\" type=\"source\" position={Position.Right} />\n      </BaseNodeFooter>\n    </BaseNode>\n  );\n}\n\nfunction getHandleValue(\n  connections: Array<{ source: string }>,\n  lookup: Map<string, Node<any>>,\n) {\n  return connections.reduce((acc, { source }) => {\n    const node = lookup.get(source)!;\n    const value = node.data.value;\n\n    return typeof value === 'number' ? acc + value : acc;\n  }, 0);\n}\n```\n\n### The Data Edge\n\nReact Flow UI doesn't just provide components for building nodes. We also provide\npre-built edges and other UI elements you can drop into your flows for quick building.\n\nTo better visualize data in our calculator flow, let's pull in the `data-edge` component.\nThis edge renders a field from the source node's data object as a label on the edge\nitself. Add the `data-edge` component to your project:\n\n```bash copy npm2yarn\nnpx shadcn@latest add https://ui.reactflow.dev/data-edge\n```\n\nThe `<DataEdge />` component works by looking up a field from its source node's `data`\nobject. We've been storing the value of each node in our calculator field in a `\"value\"`\nproperty so we'll update our `edgeType` object to include the new `data-edge` and we'll\nupdate the `onConnect` handler to create a new edge of this type, making sure to set the\nedge's `data` object correctly:\n\n\n### The Flow\n\nNow we can put everything together and create our flow. \n\nWe will start by defining the custom node and edge types, and the initial nodes and edges that will be \ndisplayed in our app.\n\n```tsx filename=\"src/App.tsx\"\nimport React, { useCallback } from 'react';\nimport {\n  ReactFlow,\n  type Node,\n  type Edge,\n  type OnConnect,\n  addEdge,\n  useNodesState,\n  useEdgesState,\n} from '@xyflow/react';\n\nimport { NumNode } from './components/nodes/num-node';\nimport { SumNode } from './components/nodes/sum-node';\n\nimport { DataEdge } from './components/data-edge';\n\nimport '@xyflow/react/dist/style.css';\n\nconst nodeTypes = {\n  num: NumNode,\n  sum: SumNode,\n};\n\nconst initialNodes: Node[] = [\n  { id: 'a', type: 'num', data: { value: 0 }, position: { x: 0, y: 0 } },\n  { id: 'b', type: 'num', data: { value: 0 }, position: { x: 0, y: 200 } },\n  { id: 'c', type: 'sum', data: { value: 0 }, position: { x: 300, y: 100 } },\n  { id: 'd', type: 'num', data: { value: 0 }, position: { x: 0, y: 400 } },\n  { id: 'e', type: 'sum', data: { value: 0 }, position: { x: 600, y: 400 } },\n];\n\nconst edgeTypes = {\n  data: DataEdge,\n};\n\nconst initialEdges: Edge[] = [\n  {\n    id: 'a->c',\n    type: 'data',\n    data: { key: 'value' },\n    source: 'a',\n    target: 'c',\n    targetHandle: 'x',\n  },\n  {\n    id: 'b->c',\n    type: 'data',\n    data: { key: 'value' },\n    source: 'b',\n    target: 'c',\n    targetHandle: 'y',\n  },\n  {\n    id: 'c->e',\n    type: 'data',\n    data: { key: 'value' },\n    source: 'c',\n    target: 'e',\n    targetHandle: 'x',\n  },\n  {\n    id: 'd->e',\n    type: 'data',\n    data: { key: 'value' },\n    source: 'd',\n    target: 'e',\n    targetHandle: 'y',\n  },\n];\n\nfunction Flow() {\n  const [nodes, , onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n\n  const onConnect: OnConnect = useCallback(\n    (params) => {\n      setEdges((edges) =>\n        addEdge({ type: 'data', data: { key: 'value' }, ...params }, edges),\n      );\n    },\n    [setEdges],\n  );\n\n  return (\n    <div className=\"h-screen w-screen p-8 bg-gray-50 rounded-xl\">\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n        nodeTypes={nodeTypes}\n        edgeTypes={edgeTypes}\n        fitView\n      />\n    </div>\n  );\n}\n\nexport function App() {\n  return <Flow />;\n}\n```\n\nPutting everything together we end up with quite a capable little calculator!\n\n<RemoteCodeViewer route=\"tutorials/components/complete\" framework=\"react\" />\n\nYou could continue to improve this flow by adding nodes to perform other operations or to\ntake user input using additional components from the\n[shadcn/ui registry](https://ui.shadcn.com/docs/components/slider). In fact, keep your\neyes peeled soon for a follow-up to this guide where we'll show a complete application\nbuilt using React Flow Components <Emoji content=\"👀\" />.\n\n## Wrapping up\n\nIn just a short amount of time we've managed to build out a fairly complete flow using the\ncomponents and building blocks provided by shadcn React Flow Components. We've learned:\n\n- How to use building blocks like the [`<BaseNodeHeader />`](/ui/components/base-node) and\n  [`<LabeledHandle />`](/ui/components/labeled-handle) components to build our own custom\n  nodes without starting from scratch.\n\n- That React Flow UI also provides custom edges like the\n  [`<DataEdge />`](/ui/components/data-edge) to drop into our applications.\n\nAnd thanks to the power of Tailwind, tweaking the visual style of these components is as\nsimple as editing the variables in your CSS file.\n\nThat's all for now! You can see all the components we currently have available\nover on the [UI docs page](/ui). If you have any suggestions or requests for new\ncomponents we'd love to hear about them. Or perhaps you're already starting to\nbuild something with shadcn and React Flow UI. Either way make sure you let us\nknow on our [Discord server](https://discord.com/invite/RVmnytFmGW) or on\n[Twitter](https://twitter.com/xyflowdev)!"
    },
    "learn/tutorials/mind-map-app-with-react-flow": {
      "name": "learn/tutorials/mind-map-app-with-react-flow",
      "title": "Build a Mind Map App with React Flow",
      "description": "",
      "category": "learn",
      "sections": [
        "<Emoji content=\"🎬\" /> It's Demo Time!",
        "<Emoji content=\"👩🏻‍💻\" /> Getting started",
        "<Emoji content=\"🏪\" /> A store for nodes and edges",
        "<Emoji content=\"✨\" /> Custom nodes and edges",
        "<Emoji content=\"🆕\" /> New nodes",
        "<Emoji content=\"🤝\" /> Keep data in sync",
        "<Emoji content=\"💅\" /> Simpler UX and nicer styling",
        "1. A node as handle",
        "2. Activate input on focus",
        "3. Dynamic width and auto focus",
        "4. Centered edges and styling details",
        "<Emoji content=\"👋\" /> Final thoughts"
      ],
      "content": "import { Emoji } from '@xyflow/xy-ui';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\nIn this tutorial, you will learn to create a simple mind map tool with React Flow that can be used for brainstorming, organizing an idea, or mapping your thoughts in a visual way. To build this app, we'll be using state management, custom nodes and edges, and more.\n\n## <Emoji content=\"🎬\" /> It's Demo Time!\n\nBefore we get our hands dirty, I want to show you the mind-mapping tool we'll have by the end of this tutorial:\n\n<RemoteCodeViewer route=\"tutorials/mindmap/app\" framework=\"react\"  />\n\nIf you'd like to live dangerously and dive right into the code, you can find the source code on [Github](https://github.com/xyflow/react-flow-mindmap-app).\n\n## <Emoji content=\"👩🏻‍💻\" /> Getting started\n\nTo do this tutorial you will need some knowledge of [React](https://reactjs.org/docs/getting-started.html) and [React Flow](/learn/concepts/terms-and-definitions) (hi, that's us! <Emoji content=\"😁\" /> it's an open source library for building node-based UIs like workflow tools, ETL pipelines, and [more](/showcase/).)\n\nWe'll be using [Vite](https://vitejs.dev/) to develop our app, but you can also use [Create React App](https://create-react-app.dev/) or any other tool you like. To scaffold a new React app with Vite you need to do:\n\n```bash npm2yarn\nnpm create vite@latest reactflow-mind-map -- --template react\n```\n\nif you would like to use Typescript:\n\n```bash npm2yarn\nnpm create vite@latest reactflow-mind-map -- --template react-ts\n```\n\nAfter the initial setup, you need to install some packages:\n\n```bash npm2yarn\nnpm install reactflow zustand classcat nanoid\n```\n\nWe are using [Zustand](https://github.com/pmndrs/zustand) for managing the state of our application. It's a bit like Redux but way smaller and there's less boilerplate code to write. React Flow also uses Zustand, so the installation comes with no additional cost. (For this tutorial we are using Typescript but you can also use plain Javascript.)\n\nTo keep it simple we are putting all of our code in the `src/App` folder. For this you need to create the `src/App` folder and add an index file with the following content:\n\n#### src/App/index.tsx\n\n```tsx\nimport { ReactFlow, Controls, Panel } from '@xyflow/react';\n\n// we have to import the React Flow styles for it to work\nimport '@xyflow/react/dist/style.css';\n\nfunction Flow() {\n  return (\n    <ReactFlow>\n      <Controls showInteractive={false} />\n      <Panel position=\"top-left\">React Flow Mind Map</Panel>\n    </ReactFlow>\n  );\n}\n\nexport default Flow;\n```\n\nThis will be our main component for rendering the mind map. There are no nodes or edges yet, but we added the React Flow [`Controls`](/api-reference/components/controls) component and a [`Panel`](/api-reference/components/panel) to display the title of our app.\n\nTo be able to use React Flow hooks, we need to wrap the application with the [`ReactFlowProvider`](/api-reference/react-flow-provider) component in our main.tsx (entry file for vite). We are also importing the newly created `App/index.tsx` and render it inside the `ReactFlowProvider.` Your main file should look like this:\n\n#### src/main.tsx\n\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { ReactFlowProvider } from '@xyflow/react';\n\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <React.StrictMode>\n    <ReactFlowProvider>\n      <App />\n    </ReactFlowProvider>\n  </React.StrictMode>,\n);\n```\n\nThe parent container of the React Flow component needs a width and a height to work properly. Our app is a fullscreen app, so we add these rules to the `index.css` file:\n\n#### src/index.css\n\n```css\nbody {\n  margin: 0;\n}\n\nhtml,\nbody,\n#root {\n  height: 100%;\n}\n```\n\nWe are adding all styles of our app to the `index.css` file (you could also use [Tailwind](/examples/styling/tailwind)). Now you can start the development server with `npm run dev` and you should see the following:\n\n<RemoteCodeViewer\n  route=\"tutorials/mindmap/getting-started\"\n  framework=\"react\"\n/>\n\n## <Emoji content=\"🏪\" /> A store for nodes and edges\n\nAs mentioned above, we are using Zustand for state management. For this, we create a new file in our `src/App` folder called `store.ts`:\n\n#### src/App/store.ts\n\n```ts\nimport {\n  Edge,\n  EdgeChange,\n  Node,\n  NodeChange,\n  OnNodesChange,\n  OnEdgesChange,\n  applyNodeChanges,\n  applyEdgeChanges,\n} from '@xyflow/react';\nimport { createWithEqualityFn } from 'zustand/traditional';\n\nexport type RFState = {\n  nodes: Node[];\n  edges: Edge[];\n  onNodesChange: OnNodesChange;\n  onEdgesChange: OnEdgesChange;\n};\n\nconst useStore = createWithEqualityFn<RFState>((set, get) => ({\n  nodes: [\n    {\n      id: 'root',\n      type: 'mindmap',\n      data: { label: 'React Flow Mind Map' },\n      position: { x: 0, y: 0 },\n    },\n  ],\n  edges: [],\n  onNodesChange: (changes: NodeChange[]) => {\n    set({\n      nodes: applyNodeChanges(changes, get().nodes),\n    });\n  },\n  onEdgesChange: (changes: EdgeChange[]) => {\n    set({\n      edges: applyEdgeChanges(changes, get().edges),\n    });\n  },\n}));\n\nexport default useStore;\n```\n\nIt seems like a lot of code, but it's mostly types <Emoji content=\"😇\" /> The store keeps track of the nodes and edges and handles the change events. When a user drags a node, React Flow fires a change event, the store then applies the changes and the updated nodes get rendered. (You can read more about this in our [state management library guide](/api-reference/hooks/use-store).)\n\nAs you can see we start with one initial node placed at `{ x: 0, y: 0 }` of type 'mindmap'. To connect the store with our app, we use the `useStore` hook:\n\n#### src/App/index.tsx\n\n```tsx\nimport { ReactFlow, Controls, Panel, NodeOrigin } from '@xyflow/react';\nimport { shallow } from 'zustand/shallow';\n\nimport useStore, { RFState } from './store';\n\n// we have to import the React Flow styles for it to work\nimport '@xyflow/react/dist/style.css';\n\nconst selector = (state: RFState) => ({\n  nodes: state.nodes,\n  edges: state.edges,\n  onNodesChange: state.onNodesChange,\n  onEdgesChange: state.onEdgesChange,\n});\n\n// this places the node origin in the center of a node\nconst nodeOrigin: NodeOrigin = [0.5, 0.5];\n\nfunction Flow() {\n  // whenever you use multiple values, you should use shallow to make sure the component only re-renders when one of the values changes\n  const { nodes, edges, onNodesChange, onEdgesChange } = useStore(selector, shallow);\n\n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      nodeOrigin={nodeOrigin}\n      fitView\n    >\n      <Controls showInteractive={false} />\n      <Panel position=\"top-left\">React Flow Mind Map</Panel>\n    </ReactFlow>\n  );\n}\n\nexport default Flow;\n```\n\nWe access the nodes, edges and change handlers from the store and pass them to the React Flow component. We also use the `fitView` prop to make sure that the initial node is centered in the view and set the node origin to `[0.5, 0.5]` to set the origin to the center of a node. After this, your app should look like this:\n\n<RemoteCodeViewer route=\"tutorials/mindmap/store-nodes-edges\" framework=\"react\" />\n\nYou can move the node around and zoom in and out, we are getting somewhere <Emoji content=\"🚀\" /> Now let's add some more functionality.\n\n## <Emoji content=\"✨\" /> Custom nodes and edges\n\nWe want to use a custom type called 'mindmap' for our nodes. We need to add a new component for this. Let's create a new folder called `MindMapNode` with an index file under `src/App` with the following content:\n\n#### src/App/MindMapNode/index.tsx\n\n```tsx\nimport { Handle, NodeProps, Position } from '@xyflow/react';\n\nexport type NodeData = {\n  label: string;\n};\n\nfunction MindMapNode({ id, data }: NodeProps<NodeData>) {\n  return (\n    <>\n      <input defaultValue={data.label} />\n\n      <Handle type=\"target\" position={Position.Top} />\n      <Handle type=\"source\" position={Position.Bottom} />\n    </>\n  );\n}\n\nexport default MindMapNode;\n```\n\nWe are using an input for displaying and editing the labels of our mind map nodes, and two handles for connecting them. This is necessary for React Flow to work; the handles are used as the start and end position of the edges.\n\nWe also add some CSS to the `index.css` file to make the nodes look a bit prettier:\n\n#### src/index.css\n\n```css\n.react-flow__node-mindmap {\n  background: white;\n  border-radius: 2px;\n  border: 1px solid transparent;\n  padding: 2px 5px;\n  font-weight: 700;\n}\n```\n\n(For more on this, you can read the [guide to custom nodes](/learn/customization/custom-nodes) in our docs.)\n\nLet's do the same for the custom edge. Create a new folder called `MindMapEdge` with an index file under `src/App`:\n\n#### src/App/MindMapEdge/index.tsx\n\n```tsx\nimport { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';\n\nfunction MindMapEdge(props: EdgeProps) {\n  const { sourceX, sourceY, targetX, targetY } = props;\n\n  const [edgePath] = getStraightPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n  });\n\n  return <BaseEdge path={edgePath} {...props} />;\n}\n\nexport default MindMapEdge;\n```\n\nI will get into more detail about the custom nodes and edges in the next section. For now it's important that we can use the new types in our app, by adding the following to our `Flow` component:\n\n```tsx\nimport MindMapNode from './MindMapNode';\nimport MindMapEdge from './MindMapEdge';\n\nconst nodeTypes = {\n  mindmap: MindMapNode,\n};\n\nconst edgeTypes = {\n  mindmap: MindMapEdge,\n};\n```\n\nand then pass the newly created types to the React Flow component.\n\n<RemoteCodeViewer route=\"tutorials/mindmap/custom-nodes-edges\" framework=\"react\" />\n\nNice! We can already change the labels of our nodes by clicking in the input field and typing something.\n\n## <Emoji content=\"🆕\" /> New nodes\n\nWe want to make it super quick for a user to create a new node. The user should be able to add a new node by clicking on a node and drag to the position where a new node should be placed. This functionality is not built into React Flow, but we can implement it by using the [`onConnectStart` and `onConnectEnd`](/api-reference/react-flow#onconnectstart) handlers.\n\nWe are using the start handler to remember the node that was clicked and the end handler to create the new node:\n\n#### Add to src/App/index.tsx\n\n```tsx\nconst connectingNodeId = useRef<string | null>(null);\n\nconst onConnectStart: OnConnectStart = useCallback((_, { nodeId }) => {\n  connectingNodeId.current = nodeId;\n}, []);\n\nconst onConnectEnd: OnConnectEnd = useCallback((event) => {\n  // we only want to create a new node if the connection ends on the pane\n  const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');\n\n  if (targetIsPane && connectingNodeId.current) {\n    console.log(`add new node with parent node ${connectingNodeId.current}`);\n  }\n}, []);\n```\n\nSince our nodes are managed by the store, we create an action to add a new node and its edge. This is how our `addChildNode` action looks:\n\n#### New action in src/store.ts\n\n```ts\naddChildNode: (parentNode: Node, position: XYPosition) => {\n  const newNode = {\n    id: nanoid(),\n    type: 'mindmap',\n    data: { label: 'New Node' },\n    position,\n    parentNode: parentNode.id,\n  };\n\n  const newEdge = {\n    id: nanoid(),\n    source: parentNode.id,\n    target: newNode.id,\n  };\n\n  set({\n    nodes: [...get().nodes, newNode],\n    edges: [...get().edges, newEdge],\n  });\n};\n```\n\nWe are using the passed node as a parent. Normally this feature is used to implement [grouping](/examples/nodes/dynamic-grouping) or [sub flows](/examples/grouping/sub-flows). Here we are using it to move all child nodes when their parent is moved. It enables us to clean up and re-order the mind map so that we don't have to move all child nodes manually. Let's use the new action in our `onConnectEnd` handler:\n\n#### Adjustments in src/App/index.tsx\n\n```tsx\nconst store = useStoreApi();\n\nconst onConnectEnd: OnConnectEnd = useCallback(\n  (event) => {\n    const { nodeLookup } = store.getState();\n    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');\n\n    if (targetIsPane && connectingNodeId.current) {\n      const parentNode = nodeLookup.get(connectingNodeId.current);\n      const childNodePosition = getChildNodePosition(event, parentNode);\n\n      if (parentNode && childNodePosition) {\n        addChildNode(parentNode, childNodePosition);\n      }\n    }\n  },\n  [getChildNodePosition],\n);\n```\n\nFirst we are getting the `nodeLookup` from the React Flow store via `store.getState()`. `nodeLookup` is a map that contains all nodes and their current state. We need it to get the position and dimensions of the clicked node. Then we check if the target of the onConnectEnd event is the React Flow pane. If it is, we want to add a new node. For this we are using our `addChildNode` and the newly created `getChildNodePosition` helper function.\n\n#### Helper function in src/App/index.tsx\n\n```tsx\nconst getChildNodePosition = (event: MouseEvent, parentNode?: Node) => {\n  const { domNode } = store.getState();\n\n  if (\n    !domNode ||\n    // we need to check if these properties exist, because when a node is not initialized yet,\n    // it doesn't have a positionAbsolute nor a width or height\n    !parentNode?.computed?.positionAbsolute ||\n    !parentNode?.computed?.width ||\n    !parentNode?.computed?.height\n  ) {\n    return;\n  }\n\n  const panePosition = screenToFlowPosition({\n    x: event.clientX,\n    y: event.clientY,\n  });\n\n  // we are calculating with positionAbsolute here because child nodes are positioned relative to their parent\n  return {\n    x:\n      panePosition.x -\n      parentNode.computed?.positionAbsolute.x +\n      parentNode.computed?.width / 2,\n    y:\n      panePosition.y -\n      parentNode.computed?.positionAbsolute.y +\n      parentNode.computed?.height / 2,\n  };\n};\n```\n\nThis function returns the position of the new node we want to add to our store. We are using the [`project` function](/api-reference/types/react-flow-instance#project) to convert screen coordinates into React Flow coordinates. As mentioned earlier, child nodes are positioned relative to their parents. That's why we need to subtract the parent position from the child node position. That was a lot to take in, let's see it in action:\n\n<RemoteCodeViewer route=\"tutorials/mindmap/create-nodes\" framework=\"react\" />\n\nTo test the new functionality you can start a connection from a handle and then end it on the pane. You should see a new node being added to the mind map.\n\n## <Emoji content=\"🤝\" /> Keep data in sync\n\nWe can already update the labels but we are not updating the nodes data object. This is important to keep our app in sync and if we want to save our nodes on the server for example. To achieve this we add a new action called `updateNodeLabel` to the store. This action takes a node id and a label. The implementation is pretty straight forward: we iterate over the existing nodes and update the matching one with the passed label:\n\n#### src/store.ts\n\n```ts\nupdateNodeLabel: (nodeId: string, label: string) => {\n  set({\n    nodes: get().nodes.map((node) => {\n      if (node.id === nodeId) {\n        // it's important to create a new object here, to inform React Flow about the changes\n        node.data = { ...node.data, label };\n      }\n\n      return node;\n    }),\n  });\n},\n```\n\nLet's use the new action in our `MindmapNode` component:\n\n#### src/App/MindmapNode/index.tsx\n\n```tsx\nimport { Handle, NodeProps, Position } from '@xyflow/react';\n\nimport useStore from '../store';\n\nexport type NodeData = {\n  label: string;\n};\n\nfunction MindMapNode({ id, data }: NodeProps<NodeData>) {\n  const updateNodeLabel = useStore((state) => state.updateNodeLabel);\n\n  return (\n    <>\n      <input\n        // from now on we can use value instead of defaultValue\n        // this makes sure that the input always shows the current label of the node\n        value={data.label}\n        onChange={(evt) => updateNodeLabel(id, evt.target.value)}\n        className=\"input\"\n      />\n\n      <Handle type=\"target\" position={Position.Top} />\n      <Handle type=\"source\" position={Position.Top} />\n    </>\n  );\n}\n\nexport default MindMapNode;\n```\n\nThat was quick! The input fields of the custom nodes now display the current label of the nodes. You could take your nodes data, save it on the server and then load it again.\n\n## <Emoji content=\"💅\" /> Simpler UX and nicer styling\n\nFunctionality-wise we are finished with our mind map app! We can add new nodes, update their labels and move them around. But the UX and styling could use some improvements. Let's make it easier to drag the nodes and to create new nodes!\n\n### 1. A node as handle\n\nLet's use the whole node as a handle, rather than displaying the default handles. This makes it easier to create nodes, because the area where you can start a new connection gets bigger. We need to style the source handle to be the size of the node and hide the target handle visually. React Flow still needs it to connect the nodes but we don't need to display it since we are creating new nodes by dropping an edge on the pane. We use plain old CSS to hide the target handle and position it in the center of the node:\n\n#### src/index.css\n\n```css\n.react-flow__handle.target {\n  top: 50%;\n  pointer-events: none;\n  opacity: 0;\n}\n```\n\nIn order to make the whole node a handle, we also update the style of the source:\n\n#### src/index.css\n\n```css\n.react-flow__handle.source {\n  top: 0;\n  left: 0;\n  transform: none;\n  background: #f6ad55;\n  height: 100%;\n  width: 100%;\n  border-radius: 2px;\n  border: none;\n}\n```\n\n<RemoteCodeViewer route=\"tutorials/mindmap/node-as-handle\" framework=\"react\" />\n\nThis works but we can't move the nodes anymore because the source handle is now the whole node and covers the input field. We fix that by using the [`dragHandle` node option](/api-reference/types/node#drag-handle). It allows us to specify a selector for a DOM element that should be used as a drag handle. For this we adjust the custom node a bit:\n\n#### src/App/MindmapNode/index.tsx\n\n```tsx\nimport { Handle, NodeProps, Position } from '@xyflow/react';\n\nimport useStore from '../store';\n\nexport type NodeData = {\n  label: string;\n};\n\nfunction MindMapNode({ id, data }: NodeProps<NodeData>) {\n  const updateNodeLabel = useStore((state) => state.updateNodeLabel);\n\n  return (\n    <>\n      <div className=\"inputWrapper\">\n        <div className=\"dragHandle\">\n          {/* icon taken from grommet https://icons.grommet.io */}\n          <svg viewBox=\"0 0 24 24\">\n            <path\n              fill=\"#333\"\n              stroke=\"#333\"\n              strokeWidth=\"1\"\n              d=\"M15 5h2V3h-2v2zM7 5h2V3H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2z\"\n            />\n          </svg>\n        </div>\n        <input\n          value={data.label}\n          onChange={(evt) => updateNodeLabel(id, evt.target.value)}\n          className=\"input\"\n        />\n      </div>\n\n      <Handle type=\"target\" position={Position.Top} />\n      <Handle type=\"source\" position={Position.Top} />\n    </>\n  );\n}\n\nexport default MindMapNode;\n```\n\nWe add a wrapper div with the class name `inputWrapper` and a div with the class name `dragHandle` that acts as the drag handle (surprise!). Now we can style the new elements:\n\n#### src/index.css\n\n```css\n.inputWrapper {\n  display: flex;\n  height: 20px;\n  z-index: 1;\n  position: relative;\n}\n\n.dragHandle {\n  background: transparent;\n  width: 14px;\n  height: 100%;\n  margin-right: 4px;\n  display: flex;\n  align-items: center;\n}\n\n.input {\n  border: none;\n  padding: 0 2px;\n  border-radius: 1px;\n  font-weight: 700;\n  background: transparent;\n  height: 100%;\n  color: #222;\n}\n```\n\n<RemoteCodeViewer route=\"tutorials/mindmap/node-as-handle-2\" framework=\"react\" />\n\n### 2. Activate input on focus\n\nWe are almost there but we need to adjust some more details. We want to start our new connection from the center of the node. For this we set the pointer events of the input to \"none\" and check if the user releases the button on top of the node. Only then we want to activate the input field. We can use our `onConnectEnd` function to achieve this:\n\n#### src/App/index.tsx\n\n```tsx\nconst onConnectEnd: OnConnectEnd = useCallback(\n  (event) => {\n    const { nodeLookup } = store.getState();\n    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');\n    const node = (event.target as Element).closest('.react-flow__node');\n\n    if (node) {\n      node.querySelector('input')?.focus({ preventScroll: true });\n    } else if (targetIsPane && connectingNodeId.current) {\n      const parentNode = nodeLookup.get(connectingNodeId.current);\n      const childNodePosition = getChildNodePosition(event, parentNode);\n\n      if (parentNode && childNodePosition) {\n        addChildNode(parentNode, childNodePosition);\n      }\n    }\n  },\n  [getChildNodePosition],\n);\n```\n\nAs you see we are focusing the input field if the user releases the mouse button on top of a node. We can now add some styling so that the input field is activated (pointerEvents: all) only when it's focused:\n\n```css\n/* we want the connection line to be below the node */\n.react-flow .react-flow__connectionline {\n  z-index: 0;\n}\n\n/* pointer-events: none so that the click for the connection goes through */\n.inputWrapper {\n  display: flex;\n  height: 20px;\n  position: relative;\n  z-index: 1;\n  pointer-events: none;\n}\n\n/* pointer-events: all so that we can use the drag handle (here the user cant start a new connection) */\n.dragHandle {\n  background: transparent;\n  width: 14px;\n  height: 100%;\n  margin-right: 4px;\n  display: flex;\n  align-items: center;\n  pointer-events: all;\n}\n\n/* pointer-events: none by default */\n.input {\n  border: none;\n  padding: 0 2px;\n  border-radius: 1px;\n  font-weight: 700;\n  background: transparent;\n  height: 100%;\n  color: #222;\n  pointer-events: none;\n}\n\n/* pointer-events: all when it's focused so that we can type in it */\n.input:focus {\n  border: none;\n  outline: none;\n  background: rgba(255, 255, 255, 0.25);\n  pointer-events: all;\n}\n```\n\n<RemoteCodeViewer route=\"tutorials/mindmap/node-as-handle-3\" framework=\"react\" />\n\n### 3. Dynamic width and auto focus\n\nAlmost done! We want to have a dynamic width for the nodes based on the length of the text. To keep it simple we do a calculation based on the length of text for this:\n\n#### Added effect in src/app/MindMapNode.tsx\n\n```jsx\nuseLayoutEffect(() => {\n  if (inputRef.current) {\n    inputRef.current.style.width = `${data.label.length * 8}px`;\n  }\n}, [data.label.length]);\n```\n\nWe also want to focus / activate a node right after it gets created:\n\n#### Added effect in src/app/MindMapNode.tsx\n\n```jsx\nuseEffect(() => {\n  setTimeout(() => {\n    if (inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    }\n  }, 1);\n}, []);\n```\n\n<RemoteCodeViewer\n  route=\"tutorials/mindmap/node-as-handle-4\"\n  framework=\"react\"\n  activeFile=\"MindMapNode.tsx\"\n/>\n\nNow when you adjust a node label, the width of the node will adjust accordingly. You can also create a new node and it will be focused right away.\n\n### 4. Centered edges and styling details\n\nYou may have noticed that the edges are not centered. We created a custom edge at the beginning for this, and now we can adjust it a bit so that the edge starts in the center of the node and not at the top of the handle (the default behavior):\n\n#### src/App/MindMapEdge.tsx\n\n```tsx\nimport { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';\n\nfunction MindMapEdge(props: EdgeProps) {\n  const { sourceX, sourceY, targetX, targetY } = props;\n\n  const [edgePath] = getStraightPath({\n    sourceX,\n    sourceY: sourceY + 20,\n    targetX,\n    targetY,\n  });\n\n  return <BaseEdge path={edgePath} {...props} />;\n}\n\nexport default MindMapEdge;\n```\n\nWe are passing all props to the [`getStraightPath`](/api-reference/utils/get-straight-path) helper function but adjust the sourceY so that it is in the center of the node.\n\nMore over we want the title to be a bit more subtle and choose a color for our background. We can do this by adjusting the color of the panel (we added the class name `\"header\"`) and the background color of the body element:\n\n```css\nbody {\n  margin: 0;\n  background-color: #f8f8f8;\n  height: 100%;\n}\n\n.header {\n  color: #cdcdcd;\n}\n```\n\nNicely done! <Emoji content=\"💯\" /> You can find the final code here:\n\n<RemoteCodeViewer\n  route=\"tutorials/mindmap/node-as-handle-4\"\n  framework=\"react\"\n  activeFile=\"MindMapNode.tsx\"\n/>\n\n## <Emoji content=\"👋\" /> Final thoughts\n\nWhat a trip! We started with an empty pane and ended with a fully functional mind map app. If you want to move on you could work on some of the following features:\n\n- Add new nodes by clicking on the pane\n- Save and restore button to store current state to local storage\n- Export and import UI\n- Collaborative editing\n\nI hope you enjoyed this tutorial and learned something new! If you have any questions or feedback, feel free to reach out to me on [Twitter](https://twitter.com/moklick) or join our [Discord server](https://discord.com/invite/RVmnytFmGW). React Flow is an independent company financed by its users. If you want to support us you can [sponsor us on Github](https://github.com/sponsors/xyflow) or [subscribe to one of our Pro plans](/pro/)."
    },
    "learn/tutorials/react-flow-and-the-web-audio-api": {
      "name": "learn/tutorials/react-flow-and-the-web-audio-api",
      "title": "Integrating React Flow and the Web Audio API",
      "description": "",
      "category": "learn",
      "sections": [
        "A demo!",
        "The Web Audio API",
        "Hello, sound!",
        "Scaffolding a React Flow project",
        "1. State management with Zustand",
        "2. Custom nodes",
        "Do sound to it",
        "1. Node changes",
        "2. Edge changes",
        "3. Switching the speakers on",
        "4. Creating new nodes",
        "Final thoughts"
      ],
      "content": "import { Emoji } from '@xyflow/xy-ui';\nimport { Callout, Tabs } from 'nextra/components';\nimport { Embed, Image } from 'xy-shared';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\nToday we'll be looking at how to create an interactive audio playground using React Flow\nand the Web Audio API. We'll start from scratch, first learning about the Web Audio API\nbefore looking at how to handle many common scenarios in React Flow: state management,\nimplementing custom nodes, and adding interactivity.\n\n<Image\n  src=\"/img/tutorials/webaudio/bleep-cafe.png\"\n  alt=\"A screenshot of bleep.cafe, a visual audio programming environment. In it,\n    there are four nodes connected together: an xy pad, an oscillator node, a\n    volume node, and a master output.\"\n  wide\n  caption=\"This is bleep.cafe. We're going to learn everything we need to know to\n    build something just like it!\"\n/>\nA while back I shared a project I was working on to the React Flow [discord\nserver](https://discord.com/invite/RVmnytFmGW). It's called\n[bleep.cafe](https://bleep.cafe) and it's a little web app for learning digital synthesis\nall inside the browser. A lot of folks were interested to see how something like that was\nput together: most people don't even know **their browser has a whole synth engine built\nin!**\n\nThis tutorial will take us step-by-step to build something similar. We may skip over some\nbits here and there, but for the most part if you're new to React Flow _or_ the Web Audio\nAPI you should be able to follow along and have something working by the end.\n\nIf you're already a React Flow wizard you might want to read the first section covering\nthe Web Audio API and then jump to the third to see how things are tied together!\n\nBut first...\n\n## A demo!\n\n<Embed src=\"https://xyflow.github.io/react-flow-web-audio/\" />\n<Callout type=\"warning\">\n  This and other examples in this tutorial _make sound_. To avoid creating an avant-garde\n  masterpiece, remember to mute each example before moving on!\n</Callout>\n\n## The Web Audio API\n\nBefore we get stuck in to React Flow and interactive node editor goodness, we need to take\na crash course on the\n[Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API). Here are\nthe highlights you need to know:\n\n- The Web Audio API provides a variety of different audio nodes, including sources (e.g.\n  [OscillatorNode](https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode),\n  [MediaElementAudioSourceNode](https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode)),\n  effects (e.g. [GainNode](https://developer.mozilla.org/en-US/docs/Web/API/GainNode),\n  [DelayNode](https://developer.mozilla.org/en-US/docs/Web/API/DelayNode),\n  [ConvolverNode](https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode)), and\n  outputs (e.g.\n  [AudioDestinationNode](https://developer.mozilla.org/en-US/docs/Web/API/AudioDestinationNode)).\n- Audio nodes can be connected together to form a (potentially cyclic) graph. We tend to\n  call this the audio-processing graph, signal graph, or signal chain.\n- Audio processing is handled in a separate thread by native code. This means we can keep\n  generating sounds even when the main UI thread is busy or blocked.\n- An [AudioContext](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext) acts as\n  the brain of an audio-processing graph. We can use it to create new audio nodes and\n  suspend or resume audio processing entirely.\n\n### Hello, sound!\n\nLet's see some of this stuff in action and build our first Web Audio app! We won't be\ndoing anything too wild: we'll make a simple mouse\n[theremin](http://www.thereminworld.com/Article/14232/what-s-a-theremin-). We'll use React\nfor these examples and everything else moving forward (we're called React Flow after all!)\nand [`vite`](https://vitejs.dev) to handle bundling and hot reloading.\n\nIf you prefer another bundler like parcel or Create React App that's cool too, they all do\nlargely the same thing. You could also choose to use TypeScript instead of JavaScript. To\nkeep things simple we won't use it today, but React Flow is fully typed (and written\nentirely in TypeScript) so it's a breeze to use!\n\n```bash npm2yarn\nnpm create vite@latest -- --template react\n```\n\nVite will scaffold out a simple React application for us, but can delete the assets and\njump right into `App.jsx`. Remove the demo component generated for us and start by\ncreating a new AudioContext and putting together the nodes we need. We want an\nOscillatorNode to generate some tones and a GainNode to control the volume.\n\n```js filename=\"./src/App.jsx\"\n// Create the brain of our audio-processing graph\nconst context = new AudioContext();\n\n// Create an oscillator node to generate tones\nconst osc = context.createOscillator();\n\n// Create a gain node to control the volume\nconst amp = context.createGain();\n\n// Pass the oscillator's output through the gain node and to our speakers\nosc.connect(amp);\namp.connect(context.destination);\n\n// Start generating those tones!\nosc.start();\n```\n\n<Callout type=\"info\">\nOscillator nodes need to be started.\n\nDon't forget that call to `osc.start`. The oscillator won't start generating tones without\nit!\n\n</Callout>\n\nFor our app, we'll track the mouse's position on the screen and use that to set the pitch\nof the oscillator node and the volume of the gain node.\n\n```jsx filename=\"./src/App.jsx\" {12-27}\nimport React from 'react';\n\nconst context = new AudioContext();\nconst osc = context.createOscillator();\nconst amp = context.createGain();\n\nosc.connect(amp);\namp.connect(context.destination);\n\nosc.start();\n\nconst updateValues = (e) => {\n  const freq = (e.clientX / window.innerWidth) * 1000;\n  const gain = e.clientY / window.innerHeight;\n\n  osc.frequency.value = freq;\n  amp.gain.value = gain;\n};\n\nexport default function App() {\n  return <div style={{ width: '100vw', height: '100vh' }} onMouseMove={updateValues} />;\n}\n```\n\n<Callout type=\"info\">\n`osc.frequency.value`, `amp.gain.value`...\n\nThe Web Audio API makes a distinction between simple object properties and audio node\n_parameters_. That distinction appears in the form of an `AudioParam`. You can read up on\nthem in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam) but\nfor now it's enough to know that you need to use `.value` to set the value of an\n`AudioParam` rather than just assigning a value to the property directly.\n\n</Callout>\n\nIf you try this example as it is, you'll probably find that nothing happens. An\nAudioContext often starts in a suspended state in an attempt to avoid ads hijacking our\nspeakers. We can fix that easily by adding a click handler on the `<div />` to resume the\ncontext if it's suspended.\n\n```jsx filename=\"./src/App.jsx\" {1-7,12}\nconst toggleAudio = () => {\n  if (context.state === 'suspended') {\n    context.resume();\n  } else {\n    context.suspend();\n  }\n};\n\nexport default function App() {\n  return (\n    <div ...\n      onClick={toggleAudio}\n    />\n  );\n};\n```\n\nAnd that's everything we need to start making some sounds with the Web Audio API! Here's\nwhat we put together, in case you weren't following along at home:\n\n<RemoteCodeViewer route=\"tutorials/webaudio/mouse-theremin\" framework=\"react\" />\nNow let's put this knowledge to one side and take a look at how to build a React Flow\nproject from scratch.\n\n<Callout type=\"info\">\n  Already a React Flow pro? If you're already familiar with React Flow, you can\n  comfortably skip over the next section and head straight on over to [making some\n  sounds](#do-sound-to-it). For everyone else, let's take a look at how to build a React\n  Flow project from scratch.\n</Callout>\n\n## Scaffolding a React Flow project\n\nLater on we'll take what we've learned about the Web Audio API, oscillators, and gain\nnodes and use React Flow to interactively build audio-processing graphs. For now though,\nwe need to put together an empty React Flow app.\n\nWe already have a React app set up with Vite, so we'll keep using that. If you skipped\nover the last section, we ran `npm create vite@latest -- --template react` to get started.\nYou can use whatever bundler and/or dev server you like, though. Nothing here is vite\nspecific.\n\nWe only need three additional dependencies for this project: `@xyflow/react` for our UI\n(obviously!), `zustand` as our simple state management library (that's what we use under\nthe hood at React Flow) and `nanoid` as a lightweight id generator.\n\n```bash npm2yarn\nnpm install @xyflow/react zustand nanoid\n```\n\nWe're going to remove everything from our Web Audio crash course and start from scratch.\nStart by modifying `main.jsx` to match the following:\n\n```jsx filename=\"./src/main.jsx\"\nimport App from './App';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { ReactFlowProvider } from '@xyflow/react';\n\n// 👇 Don't forget to import the styles!\nimport '@xyflow/react/dist/style.css';\nimport './index.css';\n\nconst root = document.querySelector('#root');\n\nReactDOM.createRoot(root).render(\n  <React.StrictMode>\n    {/* React flow needs to be inside an element with a known height and width to work */}\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <ReactFlowProvider>\n        <App />\n      </ReactFlowProvider>\n    </div>\n  </React.StrictMode>,\n);\n```\n\nThere are three important things to pay attention to here:\n\n1. You need to remember to **import the React Flow CSS styles** to make sure everything\n   works correctly.\n2. The React Flow renderer needs to be inside an element with a known height and width, so\n   we've set the containing `<div />` to take up the entire screen.\n3. To use some of the hooks React Flow provides, your components need to be inside a\n   `<ReactFlowProvider />` or inside the `<ReactFlow />` component itself, so we've\n   wrapped the entire app in the provider to be sure.\n\nNext, hop into `App.jsx` and create an empty flow:\n\n```jsx filename=\"./src/App.jsx\"\nimport React from 'react';\nimport { ReactFlow, Background } from '@xyflow/react';\n\nexport default function App() {\n  return (\n    <ReactFlow>\n      <Background />\n    </ReactFlow>\n  );\n}\n```\n\nWe'll expand and add on to this component over time. For now, we've added one of React\nFlow's built-in components - [`<Background />`](/api-reference/components/background) - to\ncheck if everything is setup correctly. Go ahead and run `npm run dev` (or whatever you\nneed to do to spin up a dev server if you didn't choose vite) and check out your browser.\nYou should see an empty flow:\n\n<Image\n  src=\"/img/tutorials/webaudio/empty-flow.png\"\n  alt=\"Screenshot of an empty React Flow graph\"\n/>\n\nLeave the dev server running. We can keep checking back on our progress as we add new bits\nand bobs.\n\n### 1. State management with Zustand\n\nA Zustand store will hold all the UI state for our application. In practical terms that\nmeans it'll hold the nodes and edges of our React Flow graph, a few other pieces of state,\nand a handful of _actions_ to update that state.\n\nTo get a basic interactive React Flow graph going we need three actions:\n\n1. `onNodesChange` to handle nodes being moved around or deleted.\n2. `onEdgesChange` to handle _edges_ being moved around or deleted.\n3. `addEdge` to connect two nodes in the graph.\n\nGo ahead and create a new file, `store.js`, and add the following:\n\n```js filename=\"./src/store.js\"\nimport { applyNodeChanges, applyEdgeChanges } from '@xyflow/react';\nimport { nanoid } from 'nanoid';\nimport { createWithEqualityFn } from 'zustand/traditional';\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  nodes: [],\n  edges: [],\n\n  onNodesChange(changes) {\n    set({\n      nodes: applyNodeChanges(changes, get().nodes),\n    });\n  },\n\n  onEdgesChange(changes) {\n    set({\n      edges: applyEdgeChanges(changes, get().edges),\n    });\n  },\n\n  addEdge(data) {\n    const id = nanoid(6);\n    const edge = { id, ...data };\n\n    set({ edges: [edge, ...get().edges] });\n  },\n}));\n```\n\nZustand is dead simple to use. We create a function that receives both a `set` and a `get`\nfunction and returns an object with our initial state along with the actions we can use to\nupdate that state. Updates happen immutably and we can use the `set` function for that.\nThe `get` function is how we read the current state. And... that's it for zustand.\n\nThe `changes` argument in both `onNodesChange` and `onEdgesChange` represents events like\na node or edge being moved or deleted. Fortunately, React Flow provides some\n[helper](/api-reference/utils/apply-node-changes)\n[functions](/api-reference/utils/apply-edge-changes) to apply those changes for us. We\njust need to update the store with the new array of nodes.\n\n`addEdge` will be called whenever two nodes get connected. The `data` argument is _almost_\na valid edge, it's just missing an id. Here we're getting nanoid to generate a 6 character\nrandom id and then adding the edge to our graph, nothing exciting.\n\nIf we hop back over to our `<App />` component we can hook React Flow up to our actions\nand get something working.\n\n```jsx filename=\"./src/App.jsx\" {3,5,7-13,16,20-24}\nimport React from 'react';\nimport { ReactFlow, Background } from '@xyflow/react';\nimport { shallow } from 'zustand/shallow';\n\nimport { useStore } from './store';\n\nconst selector = (store) => ({\n  nodes: store.nodes,\n  edges: store.edges,\n  onNodesChange: store.onNodesChange,\n  onEdgesChange: store.onEdgesChange,\n  addEdge: store.addEdge,\n});\n\nexport default function App() {\n  const store = useStore(selector, shallow);\n\n  return (\n    <ReactFlow\n      nodes={store.nodes}\n      edges={store.edges}\n      onNodesChange={store.onNodesChange}\n      onEdgesChange={store.onEdgesChange}\n      onConnect={store.addEdge}\n    >\n      <Background />\n    </ReactFlow>\n  );\n}\n```\n\nSo what's this `selector` thing all about? Zustand let's us supply a selector function to\npluck out the exact bits of state we need from the store. Combined with the `shallow`\nequality function, this means we typically don't have re-renders when state we don't care\nabout changes.\n\nRight now, our store is small and we actually want everything from it to help render our\nReact Flow graph, but as we expand on it this selector will make sure we're not\nre-rendering _everything_ all the time.\n\nThis is everything we need to have an interactive graph: we can move nodes around, connect\nthem together, and remove them. To demonstrate, _temporarily_ add some dummy nodes to your\nstore:\n\n```js filename=\"./store.jsx\" {2-6}\nconst useStore = createWithEqualityFn((set, get) => ({\n  nodes: [\n    { id: 'a', data: { label: 'oscillator' }, position: { x: 0, y: 0 } },\n    { id: 'b', data: { label: 'gain' }, position: { x: 50, y: 50 } },\n    { id: 'c', data: { label: 'output' }, position: { x: -50, y: 100 } }\n  ],\n  ...\n}));\n```\n\n<RemoteCodeViewer route=\"tutorials/webaudio/state-management\" framework=\"react\" />\n### 2. Custom nodes\n\nOK great, we have an interactive React Flow instance we can start playing with. We added\nsome dummy nodes but they're just the default unstyled ones right now. In this step we'll\nadd three custom nodes with interactive controls:\n\n1. An oscillator node and controls for the pitch and waveform type.\n2. A gain node and a control for the volume\n3. An output node and a button to toggle audio processing on and off.\n\nLet's create a new folder, `nodes/`, and create a file for each custom node we want to\ncreate. Starting with the oscillator we need two controls and a source handle to connect\nthe output of the oscillator to other nodes.\n\n```jsx filename=\"./src/nodes/Osc.jsx\"\nimport React from 'react';\nimport { Handle } from '@xyflow/react';\n\nimport { useStore } from '../store';\n\nexport default function Osc({ id, data }) {\n  return (\n    <div>\n      <div>\n        <p>Oscillator Node</p>\n\n        <label>\n          <span>Frequency</span>\n          <input\n            className=\"nodrag\"\n            type=\"range\"\n            min=\"10\"\n            max=\"1000\"\n            value={data.frequency} />\n          <span>{data.frequency}Hz</span>\n        </label>\n\n        <label>\n          <span>Waveform</span>\n          <select className=\"nodrag\" value={data.type}>\n            <option value=\"sine\">sine</option>\n            <option value=\"triangle\">triangle</option>\n            <option value=\"sawtooth\">sawtooth</option>\n            <option value=\"square\">square</option>\n          </select>\n      </div>\n\n      <Handle type=\"source\" position=\"bottom\" />\n    </div>\n  );\n};\n```\n\n<Callout type=\"info\">\n\"nodrag\" is important.\n\nPay attention to the `\"nodrag\"` class being added to both the `<input />` and `<select />`\nelements. It's _super important_ that you remember to add this class otherwise you'll find\nthat React Flow intercepts the mouse events and you'll be stuck dragging the node around\nforever!\n\n</Callout>\n\nIf we try rendering this custom node we'll find that the inputs don't do anything. That's\nbecause the input values are fixed by `data.frequency` and `data.type` but we have no\nevent handlers listening to changes and no mechanism to update a node's data!\n\nTo fix the situation we need to jump back to our store and add an `updateNode` action:\n\n```js filename=\"./src/store.js\"\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  updateNode(id, data) {\n    set({\n      nodes: get().nodes.map(node =>\n        node.id === id\n          ? { ...node, data: { ...node.data, ...data } }\n          : node\n      )\n    });\n  },\n\n  ...\n}));\n```\n\nThis action will handle partial data updates, such that if we only want to update a node's\n`frequency`, for example, we could just call `updateNode(id, { frequency: 220 }`. Now we\njust need to bring the action into our `<Osc />` component and call it whenever an input\nchanges.\n\n```jsx filename=\"./src/nodes/Osc.jsx\" {3,7-10,13,28,35}\nimport React from 'react';\nimport { Handle } from '@xyflow/react';\nimport { shallow } from 'zustand/shallow';\n\nimport { useStore } from '../store';\n\nconst selector = (id) => (store) => ({\n  setFrequency: (e) => store.updateNode(id, { frequency: +e.target.value }),\n  setType: (e) => store.updateNode(id, { type: e.target.value }),\n});\n\nexport default function Osc({ id, data }) {\n  const { setFrequency, setType } = useStore(selector(id), shallow);\n\n  return (\n    <div>\n      <div>\n        <p>Oscillator Node</p>\n\n        <label>\n          <span>Frequency:</span>\n          <input\n            className=\"nodrag\"\n            type=\"range\"\n            min=\"10\"\n            max=\"1000\"\n            value={data.frequency}\n            onChange={setFrequency}\n          />\n          <span>{data.frequency}Hz</span>\n        </label>\n\n        <label>\n          <span>Waveform:</span>\n          <select className=\"nodrag\" value={data.type} onChange={setType}>\n            <option value=\"sine\">sine</option>\n            <option value=\"triangle\">triangle</option>\n            <option value=\"sawtooth\">sawtooth</option>\n            <option value=\"square\">square</option>\n          </select>\n        </label>\n      </div>\n\n      <Handle type=\"source\" position=\"bottom\" />\n    </div>\n  );\n}\n```\n\nHey, that `selector` is back! Notice how this time we're using it to derive two event\nhandlers, `setFrequency` and `setType`, from the general `updateNode` action.\n\nThe last piece of the puzzle is to tell React Flow how to render our custom node. For that\nwe need to create a `nodeTypes` object: the keys should correspond to a node's `type` and\nthe value will be the React component to render.\n\n```jsx filename=\"./src/App.jsx\" {5,16-18,26}\nimport React from 'react';\nimport { ReactFlow } from '@xyflow/react';\nimport { shallow } from 'zustand/shallow';\n\nimport { useStore } from './store';\nimport Osc from './nodes/Osc';\n\nconst selector = (store) => ({\n  nodes: store.nodes,\n  edges: store.edges,\n  onNodesChange: store.onNodesChange,\n  onEdgesChange: store.onEdgesChange,\n  addEdge: store.addEdge,\n});\n\nconst nodeTypes = {\n  osc: Osc,\n};\n\nexport default function App() {\n  const store = useStore(selector, shallow);\n\n  return (\n    <ReactFlow\n      nodes={store.nodes}\n      nodeTypes={nodeTypes}\n      edges={store.edges}\n      onNodesChange={store.onNodesChange}\n      onEdgesChange={store.onEdgesChange}\n      onConnect={store.addEdge}\n    >\n      <Background />\n    </ReactFlow>\n  );\n}\n```\n\n<Callout type=\"info\">\nAvoid unnecessary renders.\n\nIt's important to define `nodeTypes` outside of the `<App />` component (or use React's\n[`useMemo`](https://react.dev/reference/react/useMemo)) to avoid recomputing it every\nrender.\n\n</Callout>\n\nIf you've got the dev server running, don't panic if things haven't changed yet! None of\nour temporary nodes have been given the right type yet, so React Flow just falls back to\nrendering the default node. If we change one of those nodes to be an `osc` with some\ninitial values for `frequency` and `type` we should see our custom node being rendered.\n\n```js title\"./src/store.js\"\nconst useStore = createWithEqualityFn((set, get) => ({\n  nodes: [\n    { type: 'osc',\n      id: 'a',\n      data: { frequency: 220, type: 'square' },\n      position: { x: 0, y: 0 }\n    },\n    ...\n  ],\n  ...\n}));\n```\n\n  <RemoteCodeViewer\n    route=\"tutorials/webaudio/custom-node\"\n    framework=\"react\"\n    \n  />\n<Callout type=\"info\">\nStuck on styling?\n\nIf you're just implementing the code from this post as you go along, you'll see that your\ncustom node doesn't look like the one in the preview above. To keep things easy to digest,\nwe've left out styling in the code snippets.\n\nTo learn how to style your custom nodes, check out our docs on\n[theming](/learn/customization/theming) or our example using\n[Tailwind](/examples/styling/tailwind).\n\n</Callout>\n\nImplementing a gain node is pretty much the same process, so we'll leave that one to you.\nInstead, we'll turn our attention to the output node. This node will have no parameters\ncontrol, but we do want to toggle signal processing on and off. That's a bit difficult\nright now when we haven't implemented any audio code yet, so in the meantime we'll add\njust a flag to our store and an action to toggle it.\n\n```js filename=\"./src/store.js\"\nconst useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  isRunning: false,\n\n  toggleAudio() {\n    set({ isRunning: !get().isRunning });\n  },\n\n  ...\n}));\n```\n\nThe custom node itself is then pretty simple:\n\n```jsx filename=\"./src/nodes/Out.jsx\"\nimport React from 'react';\nimport { Handle } from '@xyflow/react';\nimport { shallow } from 'zustand/shallow';\nimport { useStore } from '../store';\n\nconst selector = (store) => ({\n  isRunning: store.isRunning,\n  toggleAudio: store.toggleAudio,\n});\n\nexport default function Out({ id, data }) {\n  const { isRunning, toggleAudio } = useStore(selector, shallow);\n\n  return (\n    <div>\n      <Handle type=\"target\" position=\"top\" />\n\n      <div>\n        <p>Output Node</p>\n\n        <button onClick={toggleAudio}>\n          {isRunning ? (\n            <span role=\"img\" aria-label=\"mute\">\n              🔇\n            </span>\n          ) : (\n            <span role=\"img\" aria-label=\"unmute\">\n              🔈\n            </span>\n          )}\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\nThings are starting to shape up quite nicely!\n\n<RemoteCodeViewer route=\"tutorials/webaudio/custom-nodes\" framework=\"react\" />\nThe next step, then, is to…\n\n## Do sound to it\n\nWe have an interactive graph and we're able to update node data, now let's add in what we\nknow about the Web Audio API. Start by creating a new file, `audio.js`, and create a new\naudio context and an empty `Map`.\n\n```js filename=\"./src/audio.js\"\nconst context = new AudioContext();\nconst nodes = new Map();\n```\n\nThe way we'll manage our audio graph is by hooking into the different actions in our\nstore. So we might connect two audio nodes when the `addEdge` action is called, or update\nan audio node's properties when `updateNode` is called, and so on.\n\n<Callout type=\"warning\">\nHardcoded nodes\n\nWe hardcoded a couple of nodes in our store earlier on in this post but our audio graph\ndoesn't know anything about them! For the finished project we can do away with all these\nhardcoded bits, but for now it's **really important** that we also hardcode some audio\nnodes.\n\nHere's how we did it:\n\n```js filename=\"./src/audio.js\" {4-7,9-10,12,14-16}\nconst context = new AudioContext();\nconst nodes = new Map();\n\nconst osc = context.createOscillator();\nosc.frequency.value = 220;\nosc.type = 'square';\nosc.start();\n\nconst amp = context.createGain();\namp.gain.value = 0.5;\n\nconst out = context.destination;\n\nnodes.set('a', osc);\nnodes.set('b', amp);\nnodes.set('c', out);\n```\n\n</Callout>\n\n### 1. Node changes\n\nRight now, there are two types of node changes that can happen in our graph and that we\nneed to respond to: updating a node's `data`, and removing a node from the graph. We\nalready have an action for the former, so let's handle that first.\n\nIn `audio.js` we'll define a function, `updateAudioNode`, that we'll call with a node's id\nand a partial `data` object and use it to update an existing node in the `Map`:\n\n```js filename=\"./src/audio.js\"\nexport function updateAudioNode(id, data) {\n  const node = nodes.get(id);\n\n  for (const [key, val] of Object.entries(data)) {\n    if (node[key] instanceof AudioParam) {\n      node[key].value = val;\n    } else {\n      node[key] = val;\n    }\n  }\n}\n```\n\n<Callout type=\"info\">\n  Remember that properties on an audio node may be special `AudioParams` that must be\n  updated differently to regular object properties.\n</Callout>\n\nNow we'll want to update our `updateNode` action in the store to call this function as\npart of the update:\n\n```js filename=\"./src/store.js\"\nimport { updateAudioNode } from './audio';\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  updateNode(id, data) {\n    updateAudioNode(id, data);\n    set({ nodes: ... });\n  },\n\n  ...\n}));\n\n```\n\nThe next change we need to handle is removing a node from the graph. If you select a node\nin the graph and hit backspace, React Flow will remove it. This is implicitly handled for\nus by the `onNodesChange` action we hooked up, but now we want some additional handling\nwe'll need to wire up a new action to React Flow's `onNodesDelete` event.\n\nThis is actually pretty simple, so I'll save you some reading and present the next three\nsnippets of code without comment.\n\n<Tabs items={['./src/audio.js', './src/store.js', './src/App.jsx']}>\n  <Tabs.Tab>\n\n```js\nexport function removeAudioNode(id) {\n  const node = nodes.get(id);\n\n  node.disconnect();\n  node.stop?.();\n\n  nodes.delete(id);\n}\n```\n\n  </Tabs.Tab>\n  <Tabs.Tab>\n\n```js\nimport { ..., removeAudioNode } from './audio';\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  removeNodes(nodes) {\n    for (const { id } of nodes) {\n      removeAudioNode(id)\n    }\n  },\n\n  ...\n}));\n```\n\n  </Tabs.Tab>\n  <Tabs.Tab>\n\n```jsx\nconst selector = store => ({\n  ...,\n  onNodesDelete: store.removeNodes\n});\n\nexport default function App() {\n  const store = useStore(selector, shallow);\n\n  return (\n    <ReactFlow\n      onNodesDelete={store.onNodesDelete}\n      ...\n    >\n      <Background />\n    </ReactFlow>\n  )\n};\n```\n\n  </Tabs.Tab>\n</Tabs>\n\nThe only thing to note is that `onNodesDelete` calls the provided callback with an _array_\nof deleted nodes, because it is possible to delete more than one node at once!\n\n### 2. Edge changes\n\nWe're getting super close to actually making some sounds! All that's left is to handle\nchanges to our graph's edges. Like with node changes, we already have an action to handle\ncreating new edges and we're also implicitly handling removed edges in `onEdgesChange`.\n\nTo handle new connections, we just need the `source` and `target` ids from the edge\ncreated in our `addEdge` action. Then we can just look up the two nodes in our `Map` and\nconnect them up.\n\n<Tabs items={[\"./src/audio.js\", \"./src/store.js\"]}>\n  <Tabs.Tab>\n\n```js\nexport function connect(sourceId, targetId) {\n  const source = nodes.get(sourceId);\n  const target = nodes.get(targetId);\n\n  source.connect(target);\n}\n```\n\n  </Tabs.Tab>\n  <Tabs.Tab>\n\n```js\nimport { ..., connect } from './audio';\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  addEdge(data) {\n    ...\n\n    connect(data.source, data.target);\n  },\n\n  ...\n}));\n```\n\n  </Tabs.Tab>\n</Tabs>\n\nWe saw React Flow accepted an `onNodesDelete` handler and wouldn't you know it, there's an\n`onEdgesDelete` handler too! The approach we'd take to implement `disconnect` and hook it\nup to our store and React Flow instance is pretty much the same as before, so we'll leave\nthat one down to you as well!\n\n### 3. Switching the speakers on\n\nYou'll remember that our `AudioContext` probably begins in a suspended state to prevent\npotentially annoying autoplay issues. We already faked the data and actions we need for\nour `<Out />` component in the store, now we just need to replace them with the real\ncontext's state and resume/suspend methods.\n\n```js filename=\"./src/audio.js\"\nexport function isRunning() {\n  return context.state === 'running';\n}\n\nexport function toggleAudio() {\n  return isRunning() ? context.suspend() : context.resume();\n}\n```\n\nAlthough we haven't been returning anything from our audio functions up until now, we need\nto return from `toggleAudio` because those methods are asynchronous and we don't want to\nupdate the store prematurely!\n\n```js filename=\"./src/store.js\"\nimport { ..., isRunning, toggleAudio } from './audio'\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  isRunning: isRunning(),\n\n  toggleAudio() {\n    toggleAudio().then(() => {\n      set({ isRunning: isRunning() });\n    });\n  }\n}));\n```\n\nEt voilà, we did it! We've now put enough together to actually _make sounds_! Let's see\nwhat we have in action.\n\n<RemoteCodeViewer route=\"tutorials/webaudio/hardcoded-audio\" framework=\"react\" />\n### 4. Creating new nodes\n\nUp until now we have been dealing with a hard-coded set of nodes in our graph. This has\nbeen fine for prototyping but for it to actually be useful we'll want a way to add new\nnodes to the graph dynamically. Our final task will be adding this functionality: we'll\nwork backwards starting with the audio code and ending by creating a basic toolbar.\n\nImplementing a `createAudioNode` function will be simple enough. All we need is an id for\nthe new node, the type of node to create, and its initial data:\n\n```js filename=\"./src/audio.js\"\nexport function createAudioNode(id, type, data) {\n  switch (type) {\n    case 'osc': {\n      const node = context.createOscillator();\n      node.frequency.value = data.frequency;\n      node.type = data.type;\n      node.start();\n\n      nodes.set(id, node);\n      break;\n    }\n\n    case 'amp': {\n      const node = context.createGain();\n      node.gain.value = data.gain;\n\n      nodes.set(id, node);\n      break;\n    }\n  }\n}\n```\n\nNext we'll need a `createNode` function in our store. The node id will be generated by\nnanoid and we'll hardcode some initial data for each of the node types, so the only thing\nwe need to pass in is the type of node to create:\n\n```js filename=\"./src/store.js\"\nimport { ..., createAudioNode } from './audio';\n\nexport const useStore = createWithEqualityFn((set, get) => ({\n  ...\n\n  createNode(type) {\n    const id = nanoid();\n\n    switch(type) {\n      case 'osc': {\n        const data = { frequency: 440, type: 'sine' };\n        const position = { x: 0, y: 0 };\n\n        createAudioNode(id, type, data);\n        set({ nodes: [...get().nodes, { id, type, data, position }] });\n\n        break;\n      }\n\n      case 'amp': {\n        const data = { gain: 0.5 };\n        const position = { x: 0, y: 0 };\n\n        createAudioNode(id, type, data);\n        set({ nodes: [...get().nodes, { id, type, data, position }] });\n\n        break;\n      }\n    }\n  }\n}));\n```\n\nWe could be a bit smarter about calculating the position of the new node, but to keep\nthings simple we'll just hardcode it to `{ x: 0, y: 0 }` for now.\n\nThe final piece of the puzzle is to create a toolbar component that can trigger the new\n`createNode` action. To do that we'll jump back to `App.jsx` and make use of the\n[`<Panel />`](/docs/api-reference/components/panel/) built-in component.\n\n```jsx filename=\"./src/App.jsx\"\n...\nimport { ReactFlow,  Panel } from '@xyflow/react';\n...\n\nconst selector = (store) => ({\n  ...,\n  createNode: store.createNode,\n});\n\nexport default function App() {\n  const store = useStore(selector, shallow);\n\n  return (\n    <ReactFlow>\n      <Panel position=\"top-right\">\n        ...\n      </Panel>\n      <Background />\n    </ReactFlow>\n  );\n};\n```\n\nWe don't need anything fancy here, just a couple of buttons that trigger the `createNode`\naction with the appropriate type:\n\n```jsx filename=\"./src/App.jsx\"\n<Panel position=\"top-right\">\n  <button onClick={() => store.createNode('osc')}>osc</button>\n  <button onClick={() => store.createNode('amp')}>amp</button>\n</Panel>\n```\n\nAnd that's... everything! We've now got a fully functional audio graph editor that can:\n\n- Create new audio nodes\n- Update node data with some UI controls\n- Connect nodes together\n- Delete nodes and connections\n- Start and stop audio processing\n\nHere's the demo from the beginning, but this time you can see the source code to make sure\nyou haven't missed anything.\n\n<RemoteCodeViewer route=\"tutorials/webaudio/demo\" framework=\"react\" />\n## Final thoughts\n\nWhew that was a long one, but we made it! For our efforts we've come out the other side\nwith a fun little interactive audio playground, learned a little bit about the Web Audio\nAPI along the way, and have a better idea of one approach to \"running\" a React Flow graph.\n\nIf you've made it this far and are thinking \"Hayleigh, I'm never going to write a Web\nAudio app. Did I learn _anything_ useful?\" Then you're in luck, because you did! You could\ntake our approach to connecting to the Web Audio API and apply it to some other\ngraph-based computation engine like\n[behave-graph](https://github.com/bhouston/behave-graph). In fact, some has done just that\nand created [behave-flow](https://github.com/beeglebug/behave-flow)!\n\nThere are still plenty of ways to expand on this project. If you'd like to keep working on\nit, here are some ideas:\n\n- Add more node types.\n- Allow nodes to connect to `AudioParams` on other nodes.\n- Use the [`AnalyserNode`](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode)\n  to visualize the output of a node or signal.\n- Anything else you can think of!\n\nAnd if you're looking for inspiration, there are quite a few projects out in the wild that\nare using node-based UIs for audio things. Some of my favorites are\n[Max/MSP](https://cycling74.com/products/max/),\n[Reaktor](https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/), and\n[Pure Data](https://puredata.info/). Max and Reaktor are closed-source commercial\nsoftware, but you can still steal some ideas from them <Emoji content=\"🕵️\" />.\n\nYou can use the completed [source code](https://github.com/xyflow/react-flow-web-audio) as\na starting point, or you can just keep building on top of what we've made today. We'd love\nto see what you build so please share it with us over on our\n[Discord server](https://discord.com/invite/RVmnytFmGW) or\n[Twitter](https://twitter.com/xyflowdev).\n\nReact Flow is an independent company financed by its users. If you want to support us you\ncan [sponsor us on Github](https://github.com/sponsors/xyflow) or\n[subscribe to one of our Pro plans](/pro/)."
    },
    "learn/tutorials/slide-shows-with-react-flow": {
      "name": "learn/tutorials/slide-shows-with-react-flow",
      "title": "Create a slide show presentation with React Flow",
      "description": "",
      "category": "learn",
      "sections": [
        "Setting up the project",
        "Rendering markdown",
        "Laying out the nodes",
        "Navigating between slides",
        "Focus on click",
        "Slide controls",
        "Keyboard navigation",
        "Final thoughts"
      ],
      "content": "import { Emoji } from '@xyflow/xy-ui';\nimport { Callout, Cards } from 'nextra/components';\nimport { Image } from 'xy-shared';\nimport { RemoteCodeViewer } from 'xy-shared/server';\n\nWe recently published the findings from our React Flow 2023 end-of-year survey with an\n[interactive presentation](/developer-survey-2023) of the key findings, using React Flow\nitself. There were lots of useful bits built into this slideshow app, so we wanted to\nshare how we built it!\n\n<Image\n  src=\"/img/tutorials/presentation/survey.png\"\n  caption=\"Our 2023 end of year survey app was made up of many static nodes and buttons to navigate between them.\"\n  alt=\"Screenshot of slides laid out on an infinite canvas, each with information pulled from a survey of React Flow users\"\n/>\n\nBy the end of this tutorial, you will have built a presentation app with\n\n- Support for markdown slides\n- Keyboard navigation around the viewport\n- Automatic layouting\n- Click-drag panning navigation (à la Prezi)\n\nAlong the way, you'll learn a bit about the basics of layouting algorithms, creating\nstatic flows, and custom nodes.\n\nOnce you're done, the app will look like this!\n\n<RemoteCodeViewer route=\"tutorials/presentation/app\" framework=\"react\" />\n\nTo follow along with this tutorial we'll assume you have a basic understanding of\n[React](https://reactjs.org/docs/getting-started.html) and\n[React Flow](/learn/concepts/terms-and-definitions), but if you get stuck on the way feel\nfree to reach out to us on [Discord](https://discord.com/invite/RVmnytFmGW)!\n\nHere's the [repo with the final code](https://github.com/xyflow/react-flow-slide-show) if\nyou'd like to skip ahead or refer to it as we go.\n\nLet's get started!\n\n## Setting up the project\n\nWe like to recommend using [Vite](https://vitejs.dev) when starting new React Flow\nprojects, and this time we'll use TypeScript too. You can scaffold a new project with the\nfollowing command:\n\n```bash npm2yarn\nnpm create vite@latest -- --template react-ts\n```\n\nIf you'd prefer to follow along with JavaScript feel free to use the `react` template\ninstead. You can also follow along in your browser by using our Codesandbox templates:\n\n<Cards num={2}>\n  <Cards.Card\n    title=\"new.reactflow.dev/js\"\n    href=\"https://new.reactflow.dev/js\"\n    icon={\n      <div className=\"rounded-full w-10 h-10 bg-yellow-200 text-gray-700 font-black flex items-center justify-center\">\n        JS\n      </div>\n    }\n  />\n  <Cards.Card\n    title=\"new.reactflow.dev/ts\"\n    href=\"https://new.reactflow.dev/ts\"\n    icon={\n      <div className=\"rounded-full w-10 h-10 bg-blue-500 text-white font-black flex items-center justify-center\">\n        TS\n      </div>\n    }\n  />\n</Cards>\n\nBesides React Flow we only need to pull in one dependency,\n[`react-remark`](https://www.npmjs.com/package/react-remark), to help us render markdown\nin our slides.\n\n```bash npm2yarn\nnpm install @xyflow/react react-remark\n```\n\nWe'll modify the generated `main.tsx` to include React Flow's styles, as well as wrap the\napp in a `<ReactFlowProvider />` to make sure we can access the React Flow instance inside\nour components;\n\n```tsx filename=\"main.tsx\" {3,7,12,20}\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { ReactFlowProvider } from '@xyflow/react';\n\nimport App from './App';\n\nimport '@xyflow/react/dist/style.css';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <ReactFlowProvider>\n      {/* The parent element of the React Flow component needs a width and a height\n          to work properly. If you're styling your app as you follow along, you\n          can remove this div and apply styles to the #root element in your CSS.\n       */}\n      <div style={{ width: '100vw', height: '100vh' }}>\n        <App />\n      </div>\n    </ReactFlowProvider>\n  </React.StrictMode>,\n);\n```\n\nThis tutorial is going to gloss over the styling of the app, so feel free to use any CSS\nframework or styling solution you're familiar with. If you're going to style your app\ndifferently from just writing CSS, [Tailwind CSS](/examples/styling/tailwind), you can\nskip the import to `index.css`.\n\n<Callout>\n  How you style your app is up to you, but you must **always** include React Flow's\n  styles! If you don't need the default styles, at a minimum you should include the base\n  styles from `@xyflow/react/dist/base.css`.\n</Callout>\n\nEach slide of our presentation will be a node on the canvas, so let's create a new file\n`Slide.tsx` that will be our custom node used to render each slide.\n\n```tsx filename=\"Slide.tsx\"\nimport { type Node, type NodeProps } from '@xyflow/react';\n\nexport const SLIDE_WIDTH = 1920;\nexport const SLIDE_HEIGHT = 1080;\n\nexport type SlideNode = Node<SlideData, 'slide'>;\n\nexport type SlideData = {};\n\nconst style = {\n  width: `${SLIDE_WIDTH}px`,\n  height: `${SLIDE_HEIGHT}px`,\n} satisfies React.CSSProperties;\n\nexport function Slide({ data }: NodeProps<SlideNode>) {\n  return (\n    <article className=\"slide nodrag\" style={style}>\n      <div>Hello, React Flow!</div>\n    </article>\n  );\n}\n```\n\nWe're setting the slide width and height as constants here (rather than styling the node\nin CSS) because we'll want access to those dimensions later on. We've also stubbed out the\n`SlideData` type so we can properly type the component's props.\n\nThe last thing to do is to register our new custom node and show something on the screen.\n\n```tsx filename=\"App.tsx\"\nimport { ReactFlow } from '@xyflow/react';\nimport { Slide } from './Slide.tsx';\n\nconst nodeTypes = {\n  slide: Slide,\n};\n\nexport default function App() {\n  const nodes = [{ id: '0', type: 'slide', position: { x: 0, y: 0 }, data: {} }];\n\n  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView />;\n}\n```\n\n<Callout>\n  It's important to remember to define your `nodeTypes` object _outside_ of the component\n  (or to use React's `useMemo` hook)! When the `nodeTypes` object changes, the entire flow\n  is re-rendered.\n</Callout>\n\nWith the basics put together, you can start the development server by running\n`npm run dev` and see the following:\n\n<RemoteCodeViewer route=\"tutorials/presentation/scaffold\" framework=\"react\" />\n\nNot super exciting yet, but let's add markdown rendering and create a few slides side by\nside!\n\n## Rendering markdown\n\nWe want to make it easy to add content to our slides, so we'd like the ability to write\n[Markdown](https://www.markdownguide.org/basic-syntax/) in our slides. If you're not\nfamiliar, Markdown is a simple markup language for creating formatted text documents. If\nyou've ever written a README on GitHub, you've used Markdown!\n\nThanks to the `react-remark` package we installed earlier, this step is a simple one. We\ncan use the `<Remark />` component to render a string of markdown content into our slides.\n\n```tsx filename=\"Slide.tsx\" {2,9-11,21}\nimport { type Node, type NodeProps } from '@xyflow/react';\nimport { Remark } from 'react-remark';\n\nexport const SLIDE_WIDTH = 1920;\nexport const SLIDE_HEIGHT = 1080;\n\nexport type SlideNode = Node<SlideData, 'slide'>;\n\nexport type SlideData = {\n  source: string;\n};\n\nconst style = {\n  width: `${SLIDE_WIDTH}px`,\n  height: `${SLIDE_HEIGHT}px`,\n} satisfies React.CSSProperties;\n\nexport function Slide({ data }: NodeProps<SlideNode>) {\n  return (\n    <article className=\"slide nodrag\" style={style}>\n      <Remark>{data.source}</Remark>\n    </article>\n  );\n}\n```\n\nIn React Flow, nodes can have data stored on them that can be used during rendering. In\nthis case we're storing the markdown content to display by adding a `source` property to\nthe `SlideData` type and passing that to the `<Remark />` component. We can update our\nhardcoded nodes with some markdown content to see it in action:\n\n```tsx filename=\"App.tsx\" {2, 10-27, 34}\nimport { ReactFlow } from '@xyflow/react';\nimport { Slide, SLIDE_WIDTH } from './Slide';\n\nconst nodeTypes = {\n  slide: Slide,\n};\n\nexport default function App() {\n  const nodes = [\n    {\n      id: '0',\n      type: 'slide',\n      position: { x: 0, y: 0 },\n      data: { source: '# Hello, React Flow!' },\n    },\n    {\n      id: '1',\n      type: 'slide',\n      position: { x: SLIDE_WIDTH, y: 0 },\n      data: { source: '...' },\n    },\n    {\n      id: '2',\n      type: 'slide',\n      position: { x: SLIDE_WIDTH * 2, y: 0 },\n      data: { source: '...' },\n    },\n  ];\n\n  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView minZoom={0.1} />;\n}\n```\n\nNote that we've added the `minZoom` prop to the `<ReactFlow />` component. Our slides are\nquite large, and the default minimum zoom level is not enough to zoom out and see multiple\nslides at once.\n\n<RemoteCodeViewer route=\"tutorials/presentation/rendering-markdown\" framework=\"react\" />\n\nIn the nodes array above, we've made sure to space the slides out by doing some manual\nmath with the `SLIDE_WIDTH` constant. In the next section we'll come up with an algorithm\nto automatically lay out the slides in a grid.\n\n## Laying out the nodes\n\nWe often get asked how to automatically lay out nodes in a flow, and we have some\ndocumentation on how to use common layouting libraries like dagre and d3-hierarchy in our\n[layouting guide](/learn/layouting/layouting). Here you'll be writing your own\nsuper-simple layouting algorithm, which gets a bit nerdy, but stick with us!\n\nFor our presentation app we'll construct a simple grid layout by starting from 0,0 and\nupdating the x or y coordinates any time we have a new slide to the left, right, up, or\ndown.\n\nFirst, we need to update our `SlideData` type to include optional ids for the slides to\nthe left, right, up, and down of the current slide.\n\n```tsx filename=\"Slide.tsx\" {3-6}\nexport type SlideData = {\n  source: string;\n  left?: string;\n  up?: string;\n  down?: string;\n  right?: string;\n};\n```\n\nStoring this information on the node data directly gives us some useful benefits:\n\n- We can write fully declarative slides without worrying about the concept of nodes and\n  edges\n\n- We can compute the layout of the presentation by visiting connecting slides\n\n- We can add navigation buttons to each slide to navigate between them automatically.\n  We'll handle that in a later step.\n\nThe magic happens in a function we're going to define called `slidesToElements`. This\nfunction will take an object containing all our slides addressed by their id, and an id\nfor the slide to start at. Then it will work through each connecting slide to build an\narray of nodes and edges that we can pass to the `<ReactFlow />` component.\n\nThe algorithm will go something like this:\n\n- Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.\n- While that stack is not empty...\n  - Pop the current position and slide id off the stack.\n\n  - Look up the slide data by id.\n  - Push a new node onto the nodes array with the current id, position, and slide data.\n  - Add the slide's id to a set of visited slides.\n  - For every direction (left, right, up, down)...\n    - Make sure the slide has not already been visited.\n    - Take the current position and update the x or y coordinate by adding or subtracting\n      `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.\n    - Push the new position and the new slide's id onto a stack.\n    - Push a new edge onto the edges array connecting the current slide to the new slide.\n\n    - Repeat for the remaining directions...\n\nIf all goes to plan, we should be able to take a stack of slides shown below and turn them\ninto a neatly laid out grid!\n\n<Image src=\"/img/tutorials/presentation/ideal-layout.png\" wide />\n\nLet's see the code. In a file called `slides.ts` add the following:\n\n```tsx filename=\"slides.ts\"\nimport { SlideData, SLIDE_WIDTH, SLIDE_HEIGHT } from './Slide';\n\nexport const slidesToElements = (initial: string, slides: Record<string, SlideData>) => {\n  // Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.\n  const stack = [{ id: initial, position: { x: 0, y: 0 } }];\n  const visited = new Set();\n  const nodes = [];\n  const edges = [];\n\n  // While that stack is not empty...\n  while (stack.length) {\n    // Pop the current position and slide id off the stack.\n    const { id, position } = stack.pop();\n    // Look up the slide data by id.\n    const data = slides[id];\n    const node = { id, type: 'slide', position, data };\n\n    // Push a new node onto the nodes array with the current id, position, and slide\n    // data.\n    nodes.push(node);\n    // add the slide's id to a set of visited slides.\n    visited.add(id);\n\n    // For every direction (left, right, up, down)...\n    // Make sure the slide has not already been visited.\n    if (data.left && !visited.has(data.left)) {\n      // Take the current position and update the x or y coordinate by adding or\n      // subtracting `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.\n      const nextPosition = {\n        x: position.x - SLIDE_WIDTH,\n        y: position.y,\n      };\n\n      // Push the new position and the new slide's id onto a stack.\n      stack.push({ id: data.left, position: nextPosition });\n      // Push a new edge onto the edges array connecting the current slide to the\n      // new slide.\n      edges.push({ id: `${id}->${data.left}`, source: id, target: data.left });\n    }\n\n    // Repeat for the remaining directions...\n  }\n\n  return { nodes, edges };\n};\n```\n\nWe've left out the code for the right, up, and down directions for brevity, but the logic\nis the same for each direction. We've also included the same breakdown of the algorithm as\ncomments, to help you navigate the code.\n\nBelow is a demo app of the layouting algorithm, you can edit the `slides` object to see\nhow adding slides to different directions affects the layout. For example, try extending\n4's data to include `down: '5'` and see how the layout updates.\n\n<RemoteCodeViewer route=\"tutorials/presentation/layout-demo\" framework=\"react\" />\n\nIf you spend a little time playing with this demo, you'll likely run across two\nlimitations of this algorithm:\n\n1. It is possible to construct a layout that overlaps two slides in the same position.\n\n2. The algorithm will ignore nodes that cannot be reached from the initial slide.\n\nAddressing these shortcomings is totally possible, but a bit beyond the scope of this\ntutorial. If you give a shot, be sure to share your solution with us on the\n[discord server](https://discord.com/invite/RVmnytFmGW)!\n\nWith our layouting algorithm written, we can hop back to `App.tsx` and remove the\nhardcoded nodes array in favor of the new `slidesToElements` function.\n\n```tsx filename=\"App.tsx\" {2,3,5-9,15-16,24}\nimport { ReactFlow } from '@xyflow/react';\nimport { slidesToElements } from './slides';\nimport { Slide, SlideData, SLIDE_WIDTH } from './Slide';\n\nconst slides: Record<string, SlideData> = {\n  '0': { source: '# Hello, React Flow!', right: '1' },\n  '1': { source: '...', left: '0', right: '2' },\n  '2': { source: '...', left: '1' },\n};\n\nconst nodeTypes = {\n  slide: Slide,\n};\n\nconst initialSlide = '0';\nconst { nodes, edges } = slidesToElements(initialSlide, slides);\n\nexport default function App() {\n  return (\n    <ReactFlow\n      nodes={nodes}\n      nodeTypes={nodeTypes}\n      fitView\n      fitViewOptions={{ nodes: [{ id: initialSlide }] }}\n      minZoom={0.1}\n    />\n  );\n}\n```\n\nThe slides in our flow are static, so we can move the `slidesToElements` call _outside_\nthe component to make sure we're not recalculating the layout if the component re-renders.\nAlternatively, you could use React's `useMemo` hook to define things inside the component\nbut only calculate them once.\n\nBecause we have the idea of an \"initial\" slide now, we're also using the `fitViewOptions`\nto ensure the initial slide is the one that is focused when the canvas is first loaded.\n\n## Navigating between slides\n\nSo far we have our presentation laid out in a grid but we have to manually pan the canvas\nto see each slide, which isn't very practical for a presentation! We're going to add three\ndifferent ways to navigate between slides:\n\n- Click-to-focus on nodes for jumping to different slides by clicking on them.\n\n- Navigation buttons on each slide for moving sequentially between slides in any valid\n  direction.\n\n- Keyboard navigation using the arrow keys for moving around the presentation without\n  using the mouse or interacting with a slide directly.\n\n### Focus on click\n\nThe `<ReactFlow />` element can receive an\n[`onNodeClick`](/api-reference/react-flow#on-node-click) callback that fires when _any_\nnode is clicked. Along with the mouse event itself, we also receive a reference to the\nnode that was clicked on, and we can use that to pan the canvas thanks to the `fitView`\nmethod.\n\n[`fitView`](/api-reference/types/react-flow-instance#fit-view) is a method on the React\nFlow instance, and we can get access to it by using the\n[`useReactFlow`](/api-reference/types/react-flow-instance#use-react-flow) hook.\n\n```tsx filename=\"App.tsx\" {1-2,17-23,29}\nimport { useCallback } from 'react';\nimport { ReactFlow, useReactFlow, type NodeMouseHandler } from '@xyflow/react';\nimport { Slide, SlideData, SLIDE_WIDTH } from './Slide';\n\nconst slides: Record<string, SlideData> = {\n  ...\n}\n\nconst nodeTypes = {\n  slide: Slide,\n};\n\nconst initialSlide = '0';\nconst { nodes, edges } = slidesToElements(initialSlide, slides);\n\nexport default function App() {\n  const { fitView } = useReactFlow();\n  const handleNodeClick = useCallback<NodeMouseHandler>(\n    (_, node) => {\n      fitView({ nodes: [node], duration: 150 });\n    },\n    [fitView],\n  );\n\n  return (\n    <ReactFlow\n      ...\n      fitViewOptions={{ nodes: [{ id: initialSlide }] }}\n      onNodeClick={handleNodeClick}\n    />\n  );\n}\n```\n\n<Callout>\n  It's important to remember to include `fitView` as in the dependency array of our\n  `handleNodeClick` callback. That's because the `fitView` function is replaced once React\n  Flow has initialized the viewport. If you forget this step you'll likely find out that\n  `handleNodeClick` does nothing at all (and yes, we also forget this ourselves sometimes\n  too <Emoji content=\"🫠\" />\n  ).\n</Callout>\n\nCalling `fitView` with no arguments would attempt to fit every node in the graph into\nview, but we only want to focus on the node that was clicked! The\n[`FitViewOptions`](/api-reference/types/fit-view-options) object lets us provide an array\nof just the nodes we want to focus on: in this case, that's just the node that was\nclicked.\n\n<RemoteCodeViewer route=\"tutorials/presentation/focus-on-click\" framework=\"react\" />\n\n### Slide controls\n\nClicking to focus a node is handy for zooming out to see the big picture before focusing\nback in on a specific slide, but it's not a very practical way for navigating around a\npresentation. In this step we'll add some controls to each slide that allow us to move to\na connected slide in any direction.\n\nLet's add a `<footer>` to each slide that conditionally renders a button in any direction\nwith a connected slide. We'll also preemptively create a `moveToNextSlide` callback that\nwe'll use in a moment.\n\n```tsx filename=\"Slide.tsx\" {3,8,13-18}\nimport { type NodeProps, fitView } from '@xyflow/react';\nimport { Remark } from 'react-remark';\nimport { useCallback } from 'react';\n\n...\n\nexport function Slide({ data }: NodeProps<SlideNide>) {\n  const moveToNextSlide = useCallback((id: string) => {}, []);\n\n  return (\n    <article className=\"slide nodrag\" style={style}>\n      <Remark>{data.source}</Remark>\n      <footer className=\"slide__controls nopan\">\n        {data.left && (<button onClick={() => moveToNextSlide(data.left)}>←</button>)}\n        {data.up && (<button onClick={() => moveToNextSlide(data.up)}>↑</button>)}\n        {data.down && (<button onClick={() => moveToNextSlide(data.down)}>↓</button>)}\n        {data.right && (<button onClick={() => moveToNextSlide(data.right)}>→</button>)}\n      </footer>\n    </article>\n  );\n}\n```\n\nYou can style the footer however you like, but it's important to add the `\"nopan\"` class\nto prevent prevent the canvas from panning as you interact with any of the buttons.\n\nTo implement `moveToSlide`, we'll make use of `fitView` again. Previously we had a\nreference to the actual node that was clicked on to pass to `fitView`, but this time we\nonly have a node's id. You might be tempted to look up the target node by its id, but\nactually that's not necessary! If we look at the type of\n[`FitViewOptions`](/api-reference/types/fit-view-options) we can see that the array of\nnodes we pass in only _needs_ to have an `id` property:\n\n```ts filename=\"https://reactflow.dev/api-reference/types/fit-view-options\" {7}\nexport type FitViewOptions = {\n  padding?: number;\n  includeHiddenNodes?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  duration?: number;\n  nodes?: (Partial<Node> & { id: Node['id'] })[];\n};\n```\n\n`Partial<Node>` means that all of the fields of the `Node` object type get marked as\noptional, and then we intersect that with `{ id: Node['id'] }` to ensure that the `id`\nfield is always required. This means we can just pass in an object with an `id` property\nand nothing else, and `fitView` will know what to do with it!\n\n```tsx filename=\"Slide.tsx\" {1,4,6-9}\nimport { type NodeProps, useReactFlow } from '@xyflow/react';\n\nexport function Slide({ data }: NodeProps<SlideNide>) {\n  const { fitView } = useReactFlow();\n\n  const moveToNextSlide = useCallback(\n    (id: string) => fitView({ nodes: [{ id }] }),\n    [fitView],\n  );\n\n  return (\n    <article className=\"slide\" style={style}>\n      ...\n    </article>\n  );\n}\n```\n\n<RemoteCodeViewer route=\"tutorials/presentation/slide-controls\" framework=\"react\" />\n\n### Keyboard navigation\n\nThe final piece of the puzzle is to add keyboard navigation to our presentation. It's not\nvery convenient to have to _always_ click on a slide to move to the next one, so we'll add\nsome keyboard shortcuts to make it easier. React Flow lets us listen to keyboard events on\nthe `<ReactFlow />` component through handlers like\n[`onKeyDown`](/api-reference/react-flow#on-key-down).\n\nUp until now the slide currently focused is implied by the position of the canvas, but if\nwe want to handle key presses on the entire canvas we need to _explicitly_ track the\ncurrent slide. We need to this because we need to know which slide to navigate to when an\narrow key is pressed!\n\n```tsx filename=\"App.tsx\" {1,2,13-14,17,23}\nimport { useState, useCallback } from 'react';\nimport { ReactFlow, useReactFlow } from '@xyflow/react';\nimport { Slide, SlideData, SLIDE_WIDTH } from './Slide';\n\nconst slides: Record<string, SlideData> = {\n  ...\n}\n\nconst nodeTypes = {\n  slide: Slide,\n};\n\nconst initialSlide = '0';\nconst { nodes, edges } = slidesToElements(initialSlide, slides)\n\nexport default function App() {\n  const [currentSlide, setCurrentSlide] = useState(initialSlide);\n  const { fitView } = useReactFlow();\n\n  const handleNodeClick = useCallback<NodeMouseHandler>(\n    (_, node) => {\n      fitView({ nodes: [node] });\n      setCurrentSlide(node.id);\n    },\n    [fitView],\n  );\n\n  return (\n    <ReactFlow\n      ...\n      onNodeClick={handleNodeClick}\n    />\n  );\n}\n```\n\nHere we've added a bit of state, `currentSlide`, to our flow component and we're making\nsure to update it whenever a node is clicked. Next, we'll write a callback to handle\nkeyboard events on the canvas:\n\n```tsx filename=\"App.tsx\"\nexport default function App() {\n  const [currentSlide, setCurrentSlide] = useState(initialSlide);\n  const { fitView } = useReactFlow();\n\n  ...\n\n  const handleKeyPress = useCallback<KeyboardEventHandler>(\n    (event) => {\n      const slide = slides[currentSlide];\n\n      switch (event.key) {\n        case 'ArrowLeft':\n        case 'ArrowUp':\n        case 'ArrowDown':\n        case 'ArrowRight':\n          const direction = event.key.slice(5).toLowerCase();\n          const target = slide[direction];\n\n          if (target) {\n            event.preventDefault();\n            setCurrentSlide(target);\n            fitView({ nodes: [{ id: target }] });\n          }\n      }\n    },\n    [currentSlide, fitView],\n  );\n\n  return (\n    <ReactFlow\n      ...\n      onKeyPress={handleKeyPress}\n    />\n  );\n}\n```\n\nTo save some typing we're extracting the direction from the key pressed - if the user\npressed `'ArrowLeft'` we'll get `'left'` and so on. Then, if there is actually a slide\nconnected in that direction we'll update the current slide and call `fitView` to navigate\nto it!\n\nWe're also preventing the default behavior of the arrow keys to prevent the window from\nscrolling up and down. This is necessary for this tutorial because the canvas is only one\npart of the page, but for an app where the canvas is the entire viewport you might not\nneed to do this.\n\nAnd that's everything! To recap let's look at the final result and talk about what we've\nlearned.\n\n<RemoteCodeViewer route=\"tutorials/presentation/app\" framework=\"react\" />\n\n## Final thoughts\n\nEven if you're not planning on making the next [Prezi](https://prezi.com), we've still\nlooked at a few useful features of React Flow in this tutorial:\n\n- The [`useReactFlow`](/api-reference/hooks/use-react-flow) hook to access the `fitView`\n  method.\n\n- The [`onNodeClick`](/api-reference/react-flow#on-node-click) event handler to listen to\n  clicks on every node in a flow.\n\n- The [`onKeyPress`](/api-reference/react-flow#on-key-press) event handler to listen to\n  keyboard events on the entire canvas.\n\nWe've also looked at how to implement a simple layouting algorithm ourselves. Layouting is\na _really_ common question we get asked about, but if your needs aren't that complex you\ncan get quite far rolling your own solution!\n\nIf you're looking for ideas on how to extend this project, you could try addressing the\nissues we pointed out with the layouting algorithm, coming up with a more sophisticated\n`Slide` component with different layouts, or something else entirely.\n\nYou can use the completed [source code](https://github.com/xyflow/react-flow-slide-show)\nas a starting point, or you can just keep building on top of what we've made today. We'd\nlove to see what you build so please share it with us over on our\n[Discord server](https://discord.com/invite/RVmnytFmGW) or\n[Twitter](https://twitter.com/reactflowdev)."
    },
    "ui": {
      "name": "ui",
      "title": "index",
      "description": "",
      "category": "ui",
      "sections": [
        "Prerequisites",
        "Usage"
      ],
      "content": "# React Flow UI\n\nReady-to-use React Flow components built with [shadcn/ui](https://ui.shadcn.com/)\ncomponents and [Tailwind CSS](https://tailwindcss.com/). Useful for new projects, MVPs, or\nwhen you need to get up and running quickly.\n\n> [!NOTE]\n>\n> React Flow UI has been updated to support the latest version of shadcn/ui, on **React 19\n> and Tailwind 4**! Read more about the changes and how to upgrade\n> [here](/whats-new/2025-10-28).\n\n## Prerequisites\n\nYou need to have **shadcn and tailwind configured in your project**. If you haven't\ninstalled it, you can follow the steps explained in the\n[shadcn installation guide](https://ui.shadcn.com/docs/installation). If shadcn and\ntailwind are part of your project, you can initialize shadcn-ui by running:\n\n```bash copy npm2yarn\nnpx shadcn@latest init\n```\n\nIf you want to learn more about the motivation behind this project, you can find a\ndetailed blog post [here](https://xyflow.com/blog/react-flow-components). For a more\nin-depth tutorial, we also recently published a new guide on\n[getting started with React Flow UI](/learn/tutorials/getting-started-with-react-flow-components).\n\n> [!IMPORTANT]\n>\n> Using React Flow UI components **requires importing the main React Flow CSS stylesheet**\n> before you import the **shadcn UI stylesheet**. You usually do so in the Typescript or\n> Javascript file where you use the main [`<ReactFlow>`](/api-reference/react-flow)\n> component.\n\n```tsx filename=\"App.tsx\"\nimport '@xyflow/react/dist/style.css';\n```\n\n## Usage\n\nFind a component you like and run the command to add it to your project.\n\n```bash copy npm2yarn\nnpx shadcn@latest add https://ui.reactflow.dev/component-name\n```\n\n- This command copies the component code inside your components folder. You can change\n  this folder by adding an alias inside your `components.json`.\n\n- It automatically installs all necessary dependencies\n\n- It utilizes previously added and even modified components or asks you if you'd like to\n  overwrite them.\n\n- It uses your existing tailwind configuration.\n\n- The components are **not black-boxes** and can be **modified and extended** to fit your\n  needs.\n\nFor more information visit the [shadcn documentation](https://ui.shadcn.com/docs)."
    },
    "ui/components/animated-svg-edge": {
      "name": "ui/components/animated-svg-edge",
      "title": "animated-svg-edge",
      "description": "An edge that animates a custom SVG element along the edge's path.",
      "category": "ui",
      "sections": [
        "Custom shapes"
      ],
      "content": "import { Callout } from 'nextra/components';\nimport UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Animated SVG Edge\n\nAn edge that animates a custom SVG element along the edge's path. This component\nis based on the [animating SVG elements example](/examples/edges/animating-edges).\n\n<UiComponentViewer id=\"animated-svg-edge\" />\n\n## Custom shapes\n\nIt is intended that you add your own SVG shapes to the module. Each shape should\nbe a React component that takes one prop, `animateMotionProps`, and returns some\nSVG.\n\nYou can define these shapes in a separate file or in the same file as the edge\ncomponent. In order to use them, you need to add them to the `shapes` record like\nso:\n\n```tsx\nconst shapes = {\n  box: ({ animateMotionProps }) => (\n    <rect width=\"5\" height=\"5\" fill=\"#ff0073\">\n      <animateMotion {...animateMotionProps} />\n    </rect>\n  ),\n} satisfies Record<string, AnimatedSvg>;\n```\n\nThe keys of the `shapes` record are valid values for the `shape` field of the\nedge's data:\n\n```ts\nconst initialEdges = [\n  {\n    // ...\n    type: \"animatedSvgEdge\",\n    data: {\n      duration: 2,\n      shape: \"box\",\n    },\n  } satisfies AnimatedSvgEdge,\n];\n```\n\n<Callout type=\"info\">\n  If you want to render regular HTML elements, be sure to wrap them in an SVG\n  `<foreignObject />` element. Make sure to give the `<foreignObject />` an `id`\n  attribute and use that as the `href` attribute when rendering the  `<animateMotion />`\n  element.\n</Callout>"
    },
    "ui/components/base-handle": {
      "name": "ui/components/base-handle",
      "title": "base-handle",
      "description": "A handle component with basic styling",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Base Handle\n\nA handle with some basic styling used for creating a shared design among all handles in your application.\n\n<UiComponentViewer id=\"base-handle\" />"
    },
    "ui/components/base-node": {
      "name": "ui/components/base-node",
      "title": "base-node",
      "description": "A node component with basic styling",
      "category": "ui",
      "sections": [
        "Theming"
      ],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Base Node\n\nA node wrapper with some basic styling used for creating a shared design among all nodes in your application.\nSimilarly to [shadcn ui's card](https://ui.shadcn.com/docs/components/card) the components file exports:\n\n- The `BaseNode` main container,\n- The `BaseNodeHeader` container where you would usually add actions and a `BaseNodeHeaderTitle`\n- The `BaseNodeContent` container where you would add the main contents of the node.\n- The `BaseNodeFooter` container where you may want to add extra information, or visible actions.\n\nIn case you need to fine-tune how interactions like dragging and scrolling work with your custom components, \nReact Flow provides [several CSS utility classes](/learn/customization/utility-classes)\n\nYou should use the `nodrag` [React Flow utility class](/learn/customization/utility-classes)\nin interactive components of your node such as buttons, to disable dragging\nthe node inside the flow when the user is interacting with buttons or sliders.\n\n<UiComponentViewer id=\"base-node\" />\n\n## Theming\n\nTo customize the visual appearance of your custom nodes, you can simply use\n[Tailwind CSS](https://tailwindcss.com/) classes. All of the React Flow\ncomponents are based on [shadcn UI](https://ui.shadcn.com/), and you should follow\nthe [shadcn UI theming guide](https://ui.shadcn.com/docs/theming) to customize aspects like typography and colors\nin your application.\n\nIn most occasions though, when developing custom nodes, you may simply need to\nadd custom Tailwind CSS classes. All of the `BaseNode` components are just light wrappers around `<div>`.\n\nFor example, to change the border color of a node, based on an hypothetical execution status,\nyou can pass extra `className`s:\n\n```tsx\n// Assuming your component is receiving a `data` prop\nexport const BaseNodeSimpleDemo = memo(({ data }: NodeProps) => {\n  return (\n    <BaseNode\n      className={cn('w-[350px] p-0 hover:ring-orange-500', {\n        'border-orange-500': data.status === 'loading',\n        'border-red-500': data.status === 'error',\n      })}\n    >\n      {/* Your custom node definiton goes here */}\n    </BaseNode>\n  );\n});\n```"
    },
    "ui/components/button-edge": {
      "name": "ui/components/button-edge",
      "title": "Edge with Button",
      "description": "A custom edge component with a button",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Button Edge\n\nAn edge with a button that can be used to trigger a custom action.\n\n<UiComponentViewer id=\"button-edge\" />"
    },
    "ui/components/button-handle": {
      "name": "ui/components/button-handle",
      "title": "button-handle",
      "description": "A handle component that lets you add new nodes with a dropdown.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Button Handle\n\nA handle component with a button attached.\n\n<UiComponentViewer id=\"button-handle\" />"
    },
    "ui/components/data-edge": {
      "name": "ui/components/data-edge",
      "title": "Edge with Node Data",
      "description": "A custom edge component that shows a value from the source node's data.",
      "category": "ui",
      "sections": [
        "Additional type safety"
      ],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Data Edge\n\nAn edge that displays one field from the source node's `data` object.\n\n<UiComponentViewer id=\"data-edge\" />\n\n## Additional type safety\n\nWhen creating new edges of this type, you can use TypeScript's `satisfies` predicate\nalong with the specific type of a node in your application to ensure the `key`\nproperty of the edge's data is a valid key of the node's data.\n\n```ts\ntype CounterNode = Node<{ count: number }>;\n\nconst initialEdges = [\n  {\n    id: 'edge-1',\n    source: 'node-1',\n    target: 'node-2',\n    type: 'dataEdge',\n    data: {\n      key: 'count',\n    } satisfies DataEdge<CounterNode>,\n  },\n];\n```\n\nIf you try to use a key that is not present in the node's data, TypeScript will\nshow an error message like:\n\n> ts: Type '\"value\"' is not assignable to type '\"count\"'."
    },
    "ui/components/database-schema-node": {
      "name": "ui/components/database-schema-node",
      "title": "database-schema-node",
      "description": "A node that can be used to visualize a database schema",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Database Schema Node\n\nA node that can be used to visualize a database schema.\n\n<UiComponentViewer id=\"database-schema-node\" />"
    },
    "ui/components/devtools": {
      "name": "ui/components/devtools",
      "title": "DevTools",
      "description": "A debugging tool that provides data on the viewport, the state of each node, and logs change events.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# DevTools\n\nA debugging tool that provides data on the viewport, the state of each node, and logs change events. This component\nis based on [DevTools and Debugging](/learn/advanced-use/devtools-and-debugging) under Advanced Use.\n\nYou can import the entire `<DevTools />` component, or optionally, import individual components for greater flexibility. These components include:\n\n- A `<ViewportLogger />` component that shows the current position and zoom level of the viewport.\n- A `<NodeInspector />` component that reveals the state of each node.\n- A `<ChangeLogger />` that wraps your flow’s onNodesChange handler and logs each change as it is dispatched.\n\nYou can read more about the individual components at [DevTools and Debugging](/learn/advanced-use/devtools-and-debugging). While we find these tools useful for making sure React Flow is working properly, you might also find them useful for debugging your applications as your flows and their interactions become more complex.\n\n<UiComponentViewer id=\"devtools\" />"
    },
    "ui/components/labeled-group-node": {
      "name": "ui/components/labeled-group-node",
      "title": "labeled-group-node",
      "description": "A group node with an optional label.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Labeled Group Node\n\nA group node with an optional label.\n\n<UiComponentViewer id=\"labeled-group-node\" />"
    },
    "ui/components/labeled-handle": {
      "name": "ui/components/labeled-handle",
      "title": "labeled-handle",
      "description": "A handle component with a label",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Labeled Handle\n\nA handle with a label that can be used to display additional information.\n\n<UiComponentViewer id=\"labeled-handle\" />"
    },
    "ui/components/node-appendix": {
      "name": "ui/components/node-appendix",
      "title": "node-appendix",
      "description": "A wrapper component for dynamically appending information to nodes in an absolutely positioned container.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Node Appendix\n\nA wrapper component for dynamically appending information to nodes in an absolutely positioned container.\n\n<UiComponentViewer id=\"node-appendix\" />"
    },
    "ui/components/node-search": {
      "name": "ui/components/node-search",
      "title": "node-search",
      "description": "A slider component that can be used to zoom in and out",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Node Search\n\nA search bar component that can be used to search for nodes in the flow.\n\nIt uses the [Command](https://ui.shadcn.com/docs/components/command) component from [shadcn ui](https://ui.shadcn.com).\n\nBy default, it will check for lowercase string inclusion in the node's label, and \nselect the node and fit the view to the node when it is selected.\nYou can override this behavior by passing a custom `onSearch` function.\nYou can also override the default `onSelectNode` function to customize the behavior when a node is selected.\n\n<UiComponentViewer id=\"node-search\" />"
    },
    "ui/components/node-status-indicator": {
      "name": "ui/components/node-status-indicator",
      "title": "node-status-indicator",
      "description": "A node wrapper that has multiple states for indicating the status of a node.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Node Status Indicator\n\nA node wrapper that has multiple states for indicating the status of a node. Status can be one of the following: `\"success\"`, `\"loading\"`, `\"error\"` and `\"initial\"`.\n\nAdditionally, the `NodeStatusIndicator` component supports different loading variants: `\"border\"` and `\"overlay\"`, which can be set using the `loadingVariant` prop.\n- The `\"border\"` variant is the default and shows a spinning border around the node when it is in loading state.\n- The `\"overlay\"` variant shows a full overlay, with an animated spinner on the node when it is in loading state.\n\n<UiComponentViewer id=\"node-status-indicator\" />"
    },
    "ui/components/node-tooltip": {
      "name": "ui/components/node-tooltip",
      "title": "node-tooltip",
      "description": "A node that displays a tooltip when hovered",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Node Tooltip\n\nA wrapper for node components that displays a tooltip when hovered. \nBuilt on top of the [NodeToolbar](/api-reference/components/node-toolbar) component that comes with React Flow.\n\n<UiComponentViewer id=\"node-tooltip\" />"
    },
    "ui/components/placeholder-node": {
      "name": "ui/components/placeholder-node",
      "title": "placeholder-node",
      "description": "A custom node that can be clicked to create a new node.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Placeholder Node\n\nA custom node that can be clicked to create a new node.\n\n<UiComponentViewer id=\"placeholder-node\" />"
    },
    "ui/components/zoom-select": {
      "name": "ui/components/zoom-select",
      "title": "zoom-select",
      "description": "A zoom control that lets you zoom in and out seamlessly using a select dropdown.",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Zoom Select\n\nA zoom control that lets you zoom in and out seamlessly using a select dropdown.\n\n<UiComponentViewer id=\"zoom-select\" />"
    },
    "ui/components/zoom-slider": {
      "name": "ui/components/zoom-slider",
      "title": "zoom-slider",
      "description": "A slider component that can be used to zoom in and out",
      "category": "ui",
      "sections": [],
      "content": "import UiComponentViewer from '@/components/ui-component-viewer.mdx';\n\n# Zoom Slider\n\nA zoom control that lets you zoom in and out seamlessly using a slider.\n\n<UiComponentViewer id=\"zoom-slider\" />"
    },
    "ui/templates/ai-workflow-editor": {
      "name": "ui/templates/ai-workflow-editor",
      "title": "AI Workflow Editor",
      "description": "Starting point for building AI-powered workflow editors using React Flow UI.",
      "category": "ui",
      "sections": [
        "Tech Stack"
      ],
      "content": "import ProExampleViewer from '@/components/pro-example-viewer';\n\n# AI Workflow Editor\n\nThe AI Workflow Editor template is a Next.js template for getting started quickly with an\nAI workflow app. It's based on our\n[workflow editor template](/ui/templates/workflow-editor), [AI SDK](https://ai-sdk.dev/)\nand [shadcn/ui](https://ui.shadcn.com/).\n\n<ProExampleViewer slug=\"ai-workflow-editor\" type=\"template\" />\n\n## Tech Stack\n\n- **React Flow UI**: The project uses [React Flow UI](/ui) for the nodes. These components\n  are designed to help you quickly get up to speed on projects.\n\n- **shadcn CLI**: The project uses [shadcn CLI](https://ui.shadcn.com/docs/cli) to manage\n  UI components. This tool builds on top of [Tailwind CSS](https://tailwindcss.com/) and\n  [shadcn/ui](https://ui.shadcn.com/) components, making it easy to add and customize UI\n  elements.\n\n- **AI SDK**: The template uses [AI SDK](https://ai-sdk.dev/) to provide AI-powered\n  features within the workflow editor.\n\n- **State Management with Zustand**: The AI workflow editor template uses Zustand for\n  state management, providing a simple and efficient way to manage the state of nodes,\n  edges, and other workflow-related data."
    },
    "ui/templates/workflow-editor": {
      "name": "ui/templates/workflow-editor",
      "title": "Workflow Editor",
      "description": "",
      "category": "ui",
      "sections": [
        "Tech Stack",
        "Features"
      ],
      "content": "import ProExampleViewer from '@/components/pro-example-viewer';\n\n# Workflow Editor\n\nThe Workflow Editor template is a Next.js-based application designed to help you quickly\ncreate, manage, and visualize workflows. Built with [React Flow UI](/ui) and styled using\n[Tailwind CSS](https://tailwindcss.com/) and [shadcn/ui](https://ui.shadcn.com/), this\nproject provides a highly customizable foundation for building and extending workflow\neditors.\n\n<ProExampleViewer slug=\"workflow-editor\" type=\"template\" />\n\n## Tech Stack\n\n- **React Flow UI**: The project uses [React Flow UI](/ui) to build nodes. These\n  components are designed to help you quickly get up to speed on projects.\n\n- **shadcn CLI**: The project uses the [shadcn CLI](https://ui.shadcn.com/docs/cli) to\n  manage UI components. This tool builds on top of\n  [Tailwind CSS](https://tailwindcss.com/) and [shadcn/ui](https://ui.shadcn.com/)\n  components, making it easy to add and customize UI elements.\n\n- **State Management with Zustand**: The application uses Zustand for state management,\n  providing a simple and efficient way to manage the state of nodes, edges, and other\n  workflow-related data.\n\n## Features\n\n- **Automatic Layouting**: Utilizes the [ELKjs](https://github.com/kieler/elkjs) layout\n  engine to automatically arrange nodes and edges.\n- **Drag-and-Drop Sidebar**: Add and arrange nodes using a drag-and-drop mechanism.\n- **Customizable Components**: Uses React Flow UI and the shadcn library to create\n  highly-customizable nodes and edges.\n- **Dark Mode**: Toggles between light and dark themes, managed through the Zustand store.\n- **Runner Functionality**: Executes and monitors nodes sequentially with a workflow\n  runner."
    }
  }
}